# A0126240W
###### \java\seedu\whatnow\logic\commands\AddCommand.java
``` java
	public AddCommand(Task taskToAdd, Set<String> tags) throws IllegalValueException, ParseException {
        TaskTime validateTime = null;
        TaskDate validateDate = null;
        String validatedTime = taskToAdd.getTaskTime();
        String validatedDate = taskToAdd.getTaskDate();
        
        if (taskToAdd.getTaskTime() != null || taskToAdd.getStartTime() != null || taskToAdd.getEndTime() != null) {
            validateTime = new TaskTime(taskToAdd.getTaskTime(), taskToAdd.getStartTime(), taskToAdd.getEndTime(), taskToAdd.getTaskDate(), taskToAdd.getStartDate(), taskToAdd.getEndDate());
            if (taskToAdd.getTaskDate() == null && taskToAdd.getStartDate() == null && taskToAdd.getEndDate() == null)
                validatedDate = validateTime.getDate();
        }
        
        if (taskToAdd.getTaskDate() != null || taskToAdd.getStartDate() != null || taskToAdd.getEndDate() != null) {
            validateDate = new TaskDate(taskToAdd.getTaskDate(), taskToAdd.getStartDate(), taskToAdd.getEndDate());
            if (taskToAdd.getTaskDate() != null) {
                validatedDate = validateDate.getDate();
            } else if (taskToAdd.getStartDate() != null) {
                taskToAdd.setStartDate(validateDate.getStartDate());
                taskToAdd.setEndDate(validateDate.getEndDate());
            }
        }
        
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        
        this.toAdd = new Task(taskToAdd.getName(), validatedDate, taskToAdd.getStartDate(), taskToAdd.getEndDate(), 
                validatedTime, taskToAdd.getStartTime(), taskToAdd.getEndTime(), taskToAdd.getPeriod(), taskToAdd.getEndPeriod(), 
                new UniqueTagList(tagSet), STATUS_INCOMPLETE, null);
    }
	
	public void addRecurring(Recurrence recurring) throws DuplicateTaskException {
	    String currentDate;
	    Task nextToAdd = recurring.getNextTask(toAdd);
	    
	    if (nextToAdd.getTaskDate() != null) {
            currentDate = nextToAdd.getTaskDate();
        } else if (nextToAdd.getStartDate() != null) {
            currentDate = nextToAdd.getStartDate();
        } else {
            return;
        }
	    
	    while (recurring.hasNextTask(currentDate)) {  	        
	        model.addTask(nextToAdd);
	        model.getUndoStack().push(COMMAND_WORD);
	        model.getDeletedStackOfTasksAdd().push(nextToAdd);
	        
	        nextToAdd = recurring.getNextTask(nextToAdd);
	        
	        if (nextToAdd.getTaskDate() != null) {
	            currentDate = nextToAdd.getTaskDate();
	        } else if (nextToAdd.getStartDate() != null) {
	            currentDate = nextToAdd.getStartDate();
	        } else {
	            return;
	        }
	    }
	}

```
###### \java\seedu\whatnow\logic\commands\UpdateCommand.java
``` java
package seedu.whatnow.logic.commands;

import java.text.ParseException;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Logger;

import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.core.Messages;
import seedu.whatnow.commons.core.UnmodifiableObservableList;
import seedu.whatnow.commons.exceptions.IllegalValueException;
import seedu.whatnow.model.tag.Tag;
import seedu.whatnow.model.tag.UniqueTagList;
import seedu.whatnow.model.task.Name;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.Task;
import seedu.whatnow.model.task.TaskDate;
import seedu.whatnow.model.task.TaskTime;
import seedu.whatnow.model.task.UniqueTaskList;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Update a task with new description/date/time/tag using it's last displayed
 * index from WhatNow.
 */
public class UpdateCommand extends Command {

    private static final Logger logger = LogsCenter.getLogger(UpdateCommand.class);

    public static final String COMMAND_WORD = "update";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Updates the description/date/time/tag of the task identified by the index number used in the last task listing.\n"
            + "Parameters: todo/schedule INDEX (must be a positive integer) description/date/time/tag DESCRIPTION/DATE/TIME/TAG\n"
            + "Example: " + COMMAND_WORD + " todo 1 date from 23/2/2017 to 22/9/2017";

    public static final String MESSAGE_UPDATE_TASK_SUCCESS = "Updated Task: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in WhatNow";

    private static final String ARG_TYPE_DESCRIPTION = "description";
    private static final String ARG_TYPE_DATE = "date";
    private static final String ARG_TYPE_TIME = "time";
    private static final String ARG_TYPE_TAG = "tag";
    private static final String DELIMITER_BLANK_SPACE = " ";
    private static final String TASK_TYPE_TODO = "todo";
    private static final String TASK_TYPE_FLOATING = "floating";
    private static final String TASK_TYPE_NOT_FLOATING = "not_floating";
    private static final String DEFAULT = "default";

    private static final int ZERO = 0;
    private static final int ONE = 1;
    private static final int TWO = 2;

    public final int targetIndex;
    public final String taskType;
    public final String arg_type;
    public final String arg;
    private static Task toUpdate;

    public UpdateCommand(String taskType, int targetIndex, String arg_type, String arg)
            throws IllegalValueException, ParseException {
        this.taskType = taskType;
        this.targetIndex = targetIndex;
        this.arg_type = arg_type;
        this.arg = arg;
        processArg();
    }

    /**
     * Processes the arguments in the update command
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     * @throws ParseException
     */
    private void processArg() throws IllegalValueException, ParseException {
        String newName = DEFAULT;
        String date = null;
        String startDate = null;
        String endDate = null;
        String time = null;
        String startTime = null;
        String endTime = null;
        String period = null;
        String endPeriod = null;
        final Set<Tag> tagSet = new HashSet<>();

        if (arg_type.toUpperCase().compareToIgnoreCase(ARG_TYPE_DESCRIPTION) == ZERO) {
            newName = arg;
        }

        if (arg_type.toUpperCase().compareToIgnoreCase(ARG_TYPE_DATE) == ZERO) {
            if (arg != null) {
                String[] argComponents = arg.trim().split(DELIMITER_BLANK_SPACE);

                if (argComponents.length == ONE) {
                    date = argComponents[ZERO];
                } else if (argComponents.length == TWO) {
                    startDate = argComponents[ZERO];
                    endDate = argComponents[ONE];
                }
            }
        }

        if (arg_type.toUpperCase().compareToIgnoreCase(ARG_TYPE_TIME) == ZERO) {
            if (arg != null) {
                String[] argComponents = arg.trim().split(DELIMITER_BLANK_SPACE);
                if (argComponents.length == ONE) {
                    time = argComponents[ZERO];
                } else if (argComponents.length == TWO) {
                    startTime = argComponents[ZERO];
                    endTime = argComponents[ONE];
                }
            }
        }

        if (arg_type.toUpperCase().compareToIgnoreCase(ARG_TYPE_TAG) == ZERO) {
            if (arg != null) {
                Set<String> tags = processTag();
                for (String tagName : tags) {
                    tagSet.add(new Tag(tagName));
                }
            }
        }

        TaskTime validateTime = null;
        TaskDate validateDate = null;

        if (time != null || startTime != null || endTime != null) {
            validateTime = new TaskTime(time, startTime, endTime, date, startDate, endDate);
            if (date == null && startDate == null && endDate == null) {
                date = validateTime.getDate();
            }
        }

        if (date != null || startDate != null || endDate != null) {
            validateDate = new TaskDate(date, startDate, endDate);
            if (date != null) {
                date = validateDate.getDate();
            } else if (startDate != null) {
                startDate = validateDate.getStartDate();
                endDate = validateDate.getEndDate();
            }
        }

        toUpdate = new Task(new Name(newName), date, startDate, endDate, time, startTime, endTime, period, endPeriod, new UniqueTagList(tagSet), null, null);
    }

    /**
     * Processes the tags in the update command
     */
    private Set<String> processTag() {
        if (arg.isEmpty()) {
            return Collections.emptySet();
        }
        final Collection<String> tagStrings = Arrays.asList(arg.split(DELIMITER_BLANK_SPACE));
        return new HashSet<>(tagStrings);
    }

    private void updateTheCorrectField(ReadOnlyTask taskToUpdate) {
        if (arg_type.compareToIgnoreCase(ARG_TYPE_DESCRIPTION) == ZERO) {
            toUpdate.setTags(taskToUpdate.getTags());
            toUpdate.setTaskDate(taskToUpdate.getTaskDate());
            toUpdate.setStartDate(taskToUpdate.getStartDate());
            toUpdate.setEndDate(taskToUpdate.getEndDate());
            toUpdate.setTaskTime(taskToUpdate.getTaskTime());
            toUpdate.setStartTime(taskToUpdate.getStartTime());
            toUpdate.setEndTime(taskToUpdate.getEndTime());
            toUpdate.setStatus(taskToUpdate.getStatus());
            toUpdate.setTaskType(taskToUpdate.getTaskType());
        }
        if (arg_type.compareToIgnoreCase(ARG_TYPE_DATE) == ZERO) {
            toUpdate.setName(taskToUpdate.getName());
            if (arg != null) {
                toUpdate.setTaskTime(taskToUpdate.getTaskTime());
                toUpdate.setStartTime(taskToUpdate.getStartTime());
                toUpdate.setEndTime(taskToUpdate.getEndTime());
            }
            toUpdate.setTags(taskToUpdate.getTags());
            toUpdate.setStatus(taskToUpdate.getStatus());
        }
        if (arg_type.compareToIgnoreCase(ARG_TYPE_TIME) == ZERO) {
            toUpdate.setName(taskToUpdate.getName());
            if (taskToUpdate.getTaskDate() != null) {
                toUpdate.setTaskDate(taskToUpdate.getTaskDate());
            }

            if (taskToUpdate.getStartDate() != null) {
                toUpdate.setStartDate(taskToUpdate.getStartDate());
            }

            if (taskToUpdate.getEndDate() != null) {
                toUpdate.setEndDate(taskToUpdate.getEndDate());
            }

            toUpdate.setTags(taskToUpdate.getTags());
            toUpdate.setStatus(taskToUpdate.getStatus());
        }
        if (arg_type.compareToIgnoreCase(ARG_TYPE_TAG) == ZERO) {
            toUpdate.setName(taskToUpdate.getName());
            toUpdate.setTaskDate(taskToUpdate.getTaskDate());
            toUpdate.setStartDate(taskToUpdate.getStartDate());
            toUpdate.setEndDate(taskToUpdate.getEndDate());
            toUpdate.setTaskTime(taskToUpdate.getTaskTime());
            toUpdate.setStartTime(taskToUpdate.getStartTime());
            toUpdate.setEndTime(taskToUpdate.getEndTime());
            toUpdate.setStatus(taskToUpdate.getStatus());
            toUpdate.setTaskType(taskToUpdate.getTaskType());
        }

        if (toUpdate.getTaskDate() == null && toUpdate.getStartDate() == null && toUpdate.getEndDate() == null
                && toUpdate.getTaskTime() == null && toUpdate.getStartTime() == null && toUpdate.getEndTime() == null) {
            toUpdate.setTaskType(TASK_TYPE_FLOATING);
        } else {
            toUpdate.setTaskType(TASK_TYPE_NOT_FLOATING);
        }
    }

    public static Task getToUpdate()  {
        return toUpdate;
    }
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    /**
     * Regular Expressions
     */
    private static final Pattern UPDATE_FORMAT = Pattern
            .compile("^((todo|schedule)\\s(\\d+)\\s(description|date|time|tag)($|\\s))");

    private static final Pattern DATE = Pattern.compile("^(([3][0-1])|([1-2][0-9])|([0]??[1-9]))$");
    private static final Pattern DATE_WITH_SUFFIX = Pattern
            .compile("^((([3][0-1])|([1-2][0-9])|([0]??[1-9]))(st|nd|rd|th))$");
    private static final Pattern MONTH_IN_FULL = Pattern
            .compile("^(january|february|march|april|may|june|july|august|september|october|november|december)$");
    private static final Pattern MONTH_IN_SHORT = Pattern
            .compile("^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)$");
    private static final Pattern YEAR = Pattern.compile("^([0-9]{4})$");

    private static final Pattern DATE_WITH_SLASH_FORMAT = Pattern
            .compile("^(([3][0-1])|([1-2][0-9])|([0]??[1-9]))[/](([1][0-2])|([0]??[1-9]))[/]([0-9]{4})$");
    private static final Pattern DATE_WITH_HYPHEN_FORMAT = Pattern
            .compile("^(([3][0-1])|([1-2][0-9])|([0]??[1-9]))[-](([1][0-2])|([0]??[1-9]))[-]([0-9]{4})$");
    private static final Pattern DATE_WITH_DOT_FORMAT = Pattern
            .compile("^(([3][0-1])|([1-2][0-9])|([0]??[1-9]))[.](([1][0-2])|([0]??[1-9]))[.]([0-9]{4})$");
    private static final Pattern TIME_FORMAT = Pattern
            .compile("^(([1][0-2])|([0-9])|([0][1-9]))((:|\\.)([0-5][0-9]))??((am)|(pm))$");
    private static final Pattern TAG_FORMAT = Pattern.compile("^(t/)");

    private static final Pattern TODAY_OR_TOMORROW = Pattern.compile("^(today|tomorrow|tdy|tmr)$");
    private static final Pattern DAYS_IN_FULL = Pattern
            .compile("^(monday|tuesday|wednesday|thursday|friday|saturday|sunday)$");
    private static final Pattern DAYS_IN_SHORT = Pattern.compile("^(mon|tue|tues|wed|thu|thur|fri|sat|sun)$");
    private static final Pattern RECURRING_PERIOD = Pattern.compile("^(day|week|month|year)$");

    private static final Pattern KEYWORD_FOR_DATE = Pattern.compile("^((on)|(by)|(from)|(to))$");
    private static final Pattern KEYWORD_FOR_TIME = Pattern.compile("^((at)|(by)|(from)|(to)|(till))$");
    private static final Pattern KEYWORD_FOR_RECURRING = Pattern.compile("^(every)$");
    private static final Pattern KEYWORD_FOR_END_OF_RECURRING = Pattern.compile("^(until|till)$");

    /**
     * Integer Constants
     */
    private static final int ZERO = 0;
    private static final int ONE = 1;
    private static final int TWO = 2;

    private static final int TASK_TYPE = 0;
    private static final int INDEX = 1;
    private static final int ARG_TYPE = 2;
    private static final int ARG = 3;

    private static final int TIME_WITHOUT_PERIOD = 0;
    private static final int TIME_HOUR = 0;
    private static final int TIME_MINUTES = 1;

    private static final int ADD_COMMAND_DESCRIPTION_INDEX = 1;
    private static final int ADD_COMMAND_TAG_INDEX = 1;
    private static final int ADD_COMMAND_MIN_ARGUMENTS = 2;
    private static final int NUM_OF_QUOTATION_MARKS = 2;

    private static final int UPDATE_COMMAND_MIN_ARGUMENTS = 3;

    private static final int LIST_ARG = 0;

    private static final int CHANGE_LOCATION = 0;
    private static final int CHANGE_LOCATION_TO = 1;
    private static final int CHANGE_LOCATION_TO_PATH = 2;

    /**
     * String Constants
     */
    private static final String NONE = "none";

    private static final String DELIMITER_BLANK_SPACE = " ";
    private static final String DELIMITER_DOUBLE_QUOTATION_MARK = "\"";
    private static final String DELIMITER_FORWARD_SLASH = "/";
    private static final String DELIMITER_HYPHEN = "-";
    private static final String DELIMITER_DOT = "\\.";

    private static final String BACK_SLASH = "\\";
    private static final String FORWARD_SLASH = "/";
    private static final String HYPHEN = "-";
    private static final String DOT = ".";
    private static final String EMPTY_STRING = "";

    private static final String DATE_SUFFIX_REGEX = "(st|nd|rd|th)$";
    private static final String SINGLE_DIGIT = ("^(\\d)$");

    private static final String TIME_COLON = ":";
    private static final String TIME_DOT = ".";
    private static final String TIME_AM = "am";
    private static final String TIME_PM = "pm";
    private static final String TIME_DEFAULT_MINUTES = "00";
    private static final String DEFAULT_START_TIME = "12:00am";
    private static final String DEFAULT_END_TIME = "11:59pm";

    private static final String TASK_TYPE_FLOATING = "todo";
    private static final String TASK_TYPE_NON_FLOATING = "schedule";

    private static final String LIST_COMMAND_ARG_COMPLETED = "done";
    private static final String LIST_COMMAND_ARG_NOT_SPECIFIED = "";
    private static final String LIST_COMMAND_ARG_ALL_TASKS = "all";

    private static final String TASK_ARG_DESCRIPTION = "description";
    private static final String TASK_ARG_TAG = "tag";
    private static final String TASK_ARG_DATE = "date";
    private static final String TASK_ARG_TIME = "time";

    private static HashMap<String, Integer> MONTHS_IN_FULL = new HashMap<String, Integer>();
    private static HashMap<String, Integer> MONTHS_IN_SHORT = new HashMap<String, Integer>();
    
    private Task taskToAdd = new Task();
    Set<String> tags = new HashSet<String>();
    private boolean validArgument = true;
    private boolean hasDate = false;
    private boolean hasSubDate = false;
    private boolean hasTime = false;
    private boolean hasRecurring = false;
    private boolean hasRecurringEndDate = false;
    
    private int numOfDate = 0;
    private int numOfTime = 0;

    public Parser() {
        mapFullMonthsToMonthsInNumFormat();
        mapShortMonthsToMonthsInNumFormat();
    }

```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    private static void mapFullMonthsToMonthsInNumFormat() {
        MONTHS_IN_FULL.put("january", 1);
        MONTHS_IN_FULL.put("february", 2);
        MONTHS_IN_FULL.put("march", 3);
        MONTHS_IN_FULL.put("april", 4);
        MONTHS_IN_FULL.put("may", 5);
        MONTHS_IN_FULL.put("june", 6);
        MONTHS_IN_FULL.put("july", 7);
        MONTHS_IN_FULL.put("august", 8);
        MONTHS_IN_FULL.put("september", 9);
        MONTHS_IN_FULL.put("october", 10);
        MONTHS_IN_FULL.put("november", 11);
        MONTHS_IN_FULL.put("december", 12);
    }

```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    private static void mapShortMonthsToMonthsInNumFormat() {
        MONTHS_IN_SHORT.put("jan", 1);
        MONTHS_IN_SHORT.put("feb", 2);
        MONTHS_IN_SHORT.put("mar", 3);
        MONTHS_IN_SHORT.put("apr", 4);
        MONTHS_IN_SHORT.put("may", 5);
        MONTHS_IN_SHORT.put("jun", 6);
        MONTHS_IN_SHORT.put("jul", 7);
        MONTHS_IN_SHORT.put("aug", 8);
        MONTHS_IN_SHORT.put("sep", 9);
        MONTHS_IN_SHORT.put("oct", 10);
        MONTHS_IN_SHORT.put("nov", 11);
        MONTHS_IN_SHORT.put("dec", 12);
    }

```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    /**
     * Counts the number of occurrence of a substring in a string
     * 
     * @param str
     *            The given string
     * @param findStr
     *            The substring to look for in a given string
     * @return the number of occurrence
     */
    private static int countOccurence(String str, String findStr) {
        int lastIndex = 0;
        int count = 0;

        while (lastIndex != -1) {
            lastIndex = str.indexOf(findStr, lastIndex);

            if (lastIndex != -1) {
                count++;
                lastIndex += findStr.length();
            }
        }

        return count;
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    private void setupAddVariables() {
        validArgument = true;
        hasDate = false;
        hasSubDate = false;
        hasTime = false;
        hasRecurring = false;
        hasRecurringEndDate = false;
        
        numOfDate = 0;
        numOfTime = 0;
        
        taskToAdd.setTaskDate(null);
        taskToAdd.setStartDate(null);
        taskToAdd.setEndDate(null);
        taskToAdd.setTaskTime(null);
        taskToAdd.setStartTime(null);
        taskToAdd.setEndTime(null);
        taskToAdd.setPeriod(null);
        taskToAdd.setEndPeriod(null);
        tags = new HashSet<String>();
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    private boolean isInvalidAddFormat(String[] arguments) {
        return arguments.length < ADD_COMMAND_MIN_ARGUMENTS;
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    private boolean isTodoTask(String[] arguments) {
        return arguments.length == ADD_COMMAND_MIN_ARGUMENTS;
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    private boolean isScheduleTask(String[] arguments) {
        return arguments.length > ADD_COMMAND_MIN_ARGUMENTS;
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    private boolean isValidAddFormat(String[] arguments) {
        if (isInvalidAddFormat(arguments)) {
            return false;
        } else if (isTodoTask(arguments)) {
            return true;
        } else if (isScheduleTask(arguments)) {
            return true;
        } else {
            return false;
        }
    }

```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    /**
     * Formats the input date to the DD/MM/YYYY format
     * @param date The date to be formatted in DD/MM/YYYY format but DD and MM may be single digit
     * @return the formatted date with a zero padded in front of single digits in DD and MM
     */
    public static String formatDate(String date) {
        String[] splitDate = null;
        String formattedDate = EMPTY_STRING;
        if (date.contains(FORWARD_SLASH)) {
            splitDate = date.split(DELIMITER_FORWARD_SLASH);
        } else if (date.contains(HYPHEN)) {
            splitDate = date.split(DELIMITER_HYPHEN);
        } else if (date.contains(DOT)) {
            splitDate = date.split(DELIMITER_DOT);
        } else {
            return date;
        }

        for (int i = 0; i < splitDate.length; i++) {
            formattedDate += splitDate[i].replaceAll(SINGLE_DIGIT, ZERO + splitDate[i]);
            if (i < splitDate.length - ONE) {
                formattedDate += FORWARD_SLASH;
            }
        }

        return formattedDate;
    }

```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    /**
     * Formats the input time to the colon format E.g. 12:30am, 4:20pm etc
     * 
     * @param time
     *            The time to be formatted
     * @param period
     *            The time period
     * @return the formatted time
     */
    public static String formatTime(String time, String period) {
        String[] splitTimePeriod = null;
        String[] splitTime = null;
        String formattedTime;

        splitTimePeriod = time.toLowerCase().split(period);
        if (splitTimePeriod[TIME_WITHOUT_PERIOD].contains(TIME_COLON)) {
            splitTime = splitTimePeriod[TIME_WITHOUT_PERIOD].split(TIME_COLON);
        }

        if (splitTimePeriod[TIME_WITHOUT_PERIOD].contains(TIME_DOT)) {
            splitTime = splitTimePeriod[TIME_WITHOUT_PERIOD].split(BACK_SLASH + TIME_DOT);
        }
        
        formattedTime = (splitTime != null) ? splitTime[TIME_HOUR].replaceAll(SINGLE_DIGIT, ZERO + splitTime[TIME_HOUR]) : splitTimePeriod[TIME_WITHOUT_PERIOD].replaceAll(SINGLE_DIGIT, ZERO + splitTimePeriod[TIME_WITHOUT_PERIOD]);
        formattedTime += TIME_COLON;
        formattedTime += (splitTime != null) ? splitTime[TIME_MINUTES] : TIME_DEFAULT_MINUTES;
        formattedTime += period;

        return formattedTime;
    }

```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    /**
     * Calls the formatTime method to format the time
     * 
     * @param time
     *            The time to be formatted
     * @return the formatted time
     */
    public static String formatTime(String time) {
        String formattedTime;
        if (time.contains(TIME_AM)) {
            formattedTime = formatTime(time, TIME_AM);
        } else {
            formattedTime = formatTime(time, TIME_PM);
        }

        return formattedTime;
    }

```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    /**
     * Formats all the date and time in taskToAdd to the following format:
     * Date: dd/MM/yyyy
     * Time: HH:MM (With am/pm without any space)
     */
    private void formatDateTimeInTask() {
        if (taskToAdd.getEndPeriod() != null) {
            taskToAdd.setEndPeriod(formatDate(taskToAdd.getEndPeriod()));
        }

        if (taskToAdd.getTaskDate() != null) {
            taskToAdd.setTaskDate(formatDate(taskToAdd.getTaskDate()));
        } else if (taskToAdd.getStartDate() != null) {
            taskToAdd.setStartDate(formatDate(taskToAdd.getStartDate()));
            taskToAdd.setEndDate(formatDate(taskToAdd.getEndDate()));
        }

        if (taskToAdd.getTaskTime() != null) {
            taskToAdd.setTaskTime(formatTime(taskToAdd.getTaskTime()));
        } else if (taskToAdd.getStartTime() != null) {
            taskToAdd.setStartTime(formatTime(taskToAdd.getStartTime()));
            taskToAdd.setEndTime(formatTime(taskToAdd.getEndTime()));
        }
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    private boolean hasKeyword(String argument) {
        if (KEYWORD_FOR_DATE.matcher(argument).find()) {
            hasDate = true;
            if (KEYWORD_FOR_TIME.matcher(argument).find()) {
                hasTime = true;
            }
        } else if (KEYWORD_FOR_TIME.matcher(argument).find()) {
            hasTime = true;
            if (KEYWORD_FOR_END_OF_RECURRING.matcher(argument).find()) {
                hasDate = true;
                hasRecurringEndDate = true;
            } 
        } else if (KEYWORD_FOR_RECURRING.matcher(argument).find()) {
            hasRecurring = true;
        } else if (KEYWORD_FOR_END_OF_RECURRING.matcher(argument).find()) {
            hasDate = true;
            hasRecurringEndDate = true;
        } else {
            return false;
        }
        
        return true;
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    private boolean hasTags(String argument) {
        if (TAG_FORMAT.matcher(argument).find()) {
            return true;
        } else {
            return false;
        }
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    public boolean hasDate(String argument) {
        if (TODAY_OR_TOMORROW.matcher(argument).find()) {
            return true;
        } else if (DAYS_IN_FULL.matcher(argument).find()) {
            return true;
        } else if (DAYS_IN_SHORT.matcher(argument).find()) {
            return true;
        } else if (DATE_WITH_SLASH_FORMAT.matcher(argument).find()) {
            return true;
        } else if (DATE_WITH_HYPHEN_FORMAT.matcher(argument).find()) {
            return true;
        } else if (DATE_WITH_DOT_FORMAT.matcher(argument).find()) {
            return true;
        } else {
            return false;
        }
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    public boolean hasSubDate(String argument) {
        if (DATE.matcher(argument).find()) {
            return true;
        } else if (DATE_WITH_SUFFIX.matcher(argument).find()) {
            return true;
        } else if (MONTH_IN_FULL.matcher(argument).find()) {     
            return true;
        } else if (MONTH_IN_SHORT.matcher(argument).find()) {
            return true;
        } else if (YEAR.matcher(argument).find()) {
            return true;
        } else {
            return false;
        }
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    public boolean isYear(String argument) {
        if (YEAR.matcher(argument).find()) {
            return true;
        } else {
            return false;
        }
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    public boolean hasTime(String argument) {
        if (TIME_FORMAT.matcher(argument).find()) {
            return true;
        } else {
            return false;
        }
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    private boolean hasNoEndDateForRecurring() {
        return taskToAdd.getPeriod() != null && taskToAdd.getEndPeriod() == null;
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    private boolean hasNoEndTime() {
        return taskToAdd.getStartDate() != null && taskToAdd.getTaskTime() != null;
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    public String getSubDate(String argument) {
        if (DATE.matcher(argument).find()) {
            return argument + FORWARD_SLASH;
        } else if (DATE_WITH_SUFFIX.matcher(argument).find()) {
            return argument.replaceAll(DATE_SUFFIX_REGEX, EMPTY_STRING) + FORWARD_SLASH;
        } else if (MONTH_IN_FULL.matcher(argument).find()) {     
            return MONTHS_IN_FULL.get(argument) + FORWARD_SLASH;
        } else if (MONTH_IN_SHORT.matcher(argument).find()) {
            return MONTHS_IN_SHORT.get(argument) + FORWARD_SLASH;
        } else if (YEAR.matcher(argument).find()) {
            return argument;
        } else {
            return null;
        }
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    public boolean setDate(int numOfDate, String date) {
        if (numOfDate == ONE) {
            taskToAdd.setTaskDate(date);
        } else if (numOfDate == TWO) {
            taskToAdd.setStartDate(taskToAdd.getTaskDate());
            taskToAdd.setTaskDate(null);;
            taskToAdd.setEndDate(date);
        } else {
            return false;
        }
        
        return true;
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    public boolean setTime(int numOfTime, String time) {
        if (numOfTime == ONE) {
            taskToAdd.setTaskTime(time);
            if (taskToAdd.getStartDate() != null && taskToAdd.getEndDate() != null) {
                setDefaultStartTime();
            }
        } else if (numOfTime == TWO) {
            if (taskToAdd.getTaskTime() == null) {
                taskToAdd.setStartTime(taskToAdd.getEndTime());
                taskToAdd.setEndTime(time);
            } else {
                taskToAdd.setStartTime(taskToAdd.getTaskTime());             
                taskToAdd.setTaskTime(null);
                taskToAdd.setEndTime(time);
            }
        } else {
            return false;
        }
        
        return true;
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    private void setDefaultStartTime() {
        taskToAdd.setEndTime(taskToAdd.getTaskTime());
        taskToAdd.setTaskTime(null);
        taskToAdd.setStartTime(DEFAULT_START_TIME);
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    private void setDefaultEndTime() {
        taskToAdd.setStartTime(taskToAdd.getTaskTime());
        taskToAdd.setTaskTime(null);
        taskToAdd.setEndTime(DEFAULT_END_TIME);
    }
 
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    private boolean setRecurring(String period) {
        if (DAYS_IN_FULL.matcher(period).find()) {
            taskToAdd.setPeriod(period);
        } else if (DAYS_IN_FULL.matcher(period).find()) {
            taskToAdd.setPeriod(period);
        } else if (RECURRING_PERIOD.matcher(period).find()) {
            taskToAdd.setPeriod(period);
        } else {
            return false;
        }
        
        return true;
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    private void setTags(String argument) {
        String[] splitTag = argument.trim().split(DELIMITER_FORWARD_SLASH);
        tags.add(splitTag[ADD_COMMAND_TAG_INDEX]);
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     * @throws IllegalValueException 
     */
    private Command prepareAdd(String args) {
        setupAddVariables();
        String[] arguments = null;
        String[] argComponents = null;
        args = args.trim();

        // Check whether there are two quotation marks ""
        if (countOccurence(args, DELIMITER_DOUBLE_QUOTATION_MARK) != NUM_OF_QUOTATION_MARKS) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }

        arguments = args.split(DELIMITER_DOUBLE_QUOTATION_MARK);
        
        if (!isValidAddFormat(arguments)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }

        try {
            taskToAdd.setName(new Name(arguments[ADD_COMMAND_DESCRIPTION_INDEX].trim()));
            
            if (isTodoTask(arguments)) {
                return new AddCommand(taskToAdd, Collections.emptySet());
            }
            
            argComponents = arguments[arguments.length - ONE].trim().split(DELIMITER_BLANK_SPACE);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (ParseException e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }

        for (int i = 0; i < argComponents.length; i++) {
            if (!hasDate && !hasSubDate && !hasTime && !hasRecurring && !hasRecurringEndDate) {
                if (hasDate(argComponents[i].toLowerCase())) {
                    argComponents[i] = argComponents[i].toLowerCase();
                    numOfDate++;
                    if (!setDate(numOfDate, argComponents[i])) {
                        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
                    }
                } else if (hasSubDate(argComponents[i].toLowerCase())) {
                    argComponents[i] = argComponents[i].toLowerCase();
                    hasSubDate = true;
                    numOfDate++;
                    if (!setDate(numOfDate, getSubDate(argComponents[i]))) {
                        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
                    } 
                } else if (hasTime(argComponents[i].toLowerCase())) {
                    argComponents[i] = argComponents[i].toLowerCase();
                    numOfTime++;
                    if (!setTime(numOfTime, argComponents[i])) {
                        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
                    }
                } else if (hasTags(argComponents[i])) {
                    setTags(argComponents[i]);
                } else {
                    if (!hasKeyword(argComponents[i].toLowerCase())) {
                        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
                    }
                }

                continue;
            }
            
            argComponents[i] = argComponents[i].toLowerCase();

            if (hasDate) {
                if (hasRecurringEndDate && taskToAdd.getPeriod() != null) {    
                    if (hasDate(argComponents[i])) {
                        taskToAdd.setEndPeriod(argComponents[i]);
                        hasRecurringEndDate = false;
                    } else if (hasSubDate(argComponents[i])) {                     
                        taskToAdd.setEndPeriod(getSubDate(argComponents[i]));
                        hasSubDate = true;
                    } else {
                        validArgument = false;
                        hasRecurringEndDate = false;
                    }

                    hasTime = false;
                } else {
                    if (hasDate(argComponents[i])) {
                        hasTime = false;
                        numOfDate++;
                        if (!setDate(numOfDate, argComponents[i])) {
                            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
                        }
                    } else if (hasSubDate(argComponents[i])) {
                        hasSubDate = true;
                        hasTime = false;
                        numOfDate++;
                        if (!setDate(numOfDate, getSubDate(argComponents[i]))) {
                            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
                        }
                    } else if (!hasTime) {
                        validArgument = false;
                    }

                    hasRecurringEndDate = false;
                }

                hasDate = false;
                if (hasSubDate) {
                    continue;
                }              
            }

            if (hasSubDate) {
                if (hasRecurringEndDate && taskToAdd.getPeriod() != null) {  
                    if (hasSubDate(argComponents[i])) {
                        hasSubDate = true;  
                        taskToAdd.setEndPeriod(taskToAdd.getEndPeriod() + getSubDate(argComponents[i]));            
                        if (isYear(getSubDate(argComponents[i]))) {
                            hasSubDate = false;
                            hasRecurringEndDate = false;
                        }
                    } else {
                        validArgument = false;
                        hasSubDate = false;
                        hasRecurringEndDate = false;
                    }     
                } else {                   
                    if (hasSubDate(argComponents[i])) {
                        if (numOfDate == ONE) {
                            taskToAdd.setTaskDate(taskToAdd.getTaskDate() + getSubDate(argComponents[i]));
                        } else if (numOfDate == TWO) {
                            taskToAdd.setEndDate(taskToAdd.getEndDate() + getSubDate(argComponents[i]));;
                        } else {
                            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
                        }
                        
                        if (isYear(getSubDate(argComponents[i]))) {
                            hasSubDate = false;
                        }
                    } else {
                        validArgument = false;
                        hasSubDate = false;
                    }
                }
            }

            if (hasTime && !hasRecurringEndDate) {
                if (hasTime(argComponents[i])) {
                    numOfTime++;
                    if (!setTime(numOfTime, argComponents[i])) {
                        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
                    }
                } else {
                    validArgument = false;
                }

                hasTime = false;
            }

            if (hasRecurring) {
                hasRecurring = false;
                if (!setRecurring(argComponents[i])) {
                    validArgument = false;
                }
            }

            if (!validArgument) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
            }
        }

        formatDateTimeInTask();
        
        if (hasNoEndTime()) {
            setDefaultEndTime();
        }
        
        if (hasNoEndDateForRecurring()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_RECURRING_NO_END_DATE));
        }

        try {
            return new AddCommand(taskToAdd, tags);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (ParseException e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
    }

```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the update task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     * @throws ParseException
     */
    private Command prepareUpdate(String args) {
        if (args == null)
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));

        if (!UPDATE_FORMAT.matcher(args.trim().toLowerCase()).find()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }

        String[] argComponents = args.trim().split(DELIMITER_BLANK_SPACE);

        if (argComponents.length < UPDATE_COMMAND_MIN_ARGUMENTS)
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));

        String taskType = argComponents[TASK_TYPE];
        Optional<Integer> index = parseIndex(argComponents[INDEX]);
        String argType = argComponents[ARG_TYPE];
        String arg = "";

        int numOfDate = 0;
        int numOfTime = 0;

        if (argComponents.length > UPDATE_COMMAND_MIN_ARGUMENTS) {
            for (int i = ARG; i < argComponents.length; i++) {
                if (argType.toUpperCase().compareToIgnoreCase(TASK_ARG_DESCRIPTION) == 0) {
                    if (argComponents[i].toUpperCase().compareToIgnoreCase(NONE) == 0)
                        return new IncorrectCommand(MESSAGE_INVALID_COMMAND_FORMAT + UpdateCommand.MESSAGE_USAGE);

                    arg += argComponents[i] + DELIMITER_BLANK_SPACE;
                } else if (argType.toUpperCase().compareToIgnoreCase(TASK_ARG_DATE) == 0) {
                    if (DATE_WITH_SLASH_FORMAT.matcher(argComponents[i]).find()) {
                        numOfDate++;
                        if (numOfDate == ONE)
                            arg = argComponents[i];
                        else if (numOfDate == TWO)
                            arg += DELIMITER_BLANK_SPACE + argComponents[i];
                    } else if (TODAY_OR_TOMORROW.matcher(argComponents[i].toLowerCase()).find()) {
                        numOfDate++;
                        if (numOfDate == ONE)
                            arg = argComponents[i];
                        else if (numOfDate == TWO)
                            arg += DELIMITER_BLANK_SPACE + argComponents[i];
                    } else if (DATE.matcher(argComponents[i].toLowerCase()).find()) {
                        numOfDate++;
                        if (numOfDate == ONE) {
                            arg = argComponents[i].toLowerCase();
                            arg += FORWARD_SLASH;
                        } else if (numOfDate == TWO) {
                            arg += DELIMITER_BLANK_SPACE + argComponents[i].toLowerCase();
                            arg += FORWARD_SLASH;
                        }
                    } else if (DATE_WITH_SUFFIX.matcher(argComponents[i].toLowerCase()).find()) {
                        numOfDate++;
                        if (numOfDate == ONE) {
                            arg = argComponents[i].toLowerCase().replaceAll(DATE_SUFFIX_REGEX, EMPTY_STRING);
                            arg += FORWARD_SLASH;
                        } else if (numOfDate == TWO) {
                            arg = argComponents[i].toLowerCase();
                            arg += FORWARD_SLASH;
                        }
                    } else if (MONTH_IN_FULL.matcher(argComponents[i].toLowerCase()).find()) {
                        if (numOfDate == ONE) {
                            arg += MONTHS_IN_FULL.get(argComponents[i].toLowerCase());
                        } else if (numOfDate == TWO) {
                            arg += MONTHS_IN_FULL.get(argComponents[i].toLowerCase());
                        }
                    } else if (MONTH_IN_SHORT.matcher(argComponents[i].toLowerCase()).find()) {
                        if (numOfDate == ONE) {
                            arg += MONTHS_IN_SHORT.get(argComponents[i].toLowerCase());
                        } else if (numOfDate == TWO) {
                            arg += MONTHS_IN_FULL.get(argComponents[i].toLowerCase());
                        }
                    } else if (YEAR.matcher(argComponents[i].toLowerCase()).find()) {
                        if (numOfDate == ONE) {
                            arg += FORWARD_SLASH;
                            arg += argComponents[i].toLowerCase();
                        } else if (numOfDate == TWO) {
                            arg += FORWARD_SLASH;
                            arg += argComponents[i].toLowerCase();
                        }
                    } else if (argComponents[i].toUpperCase().compareToIgnoreCase(NONE) == 0) {
                        arg = null;
                    }
                } else if (argType.toUpperCase().compareToIgnoreCase(TASK_ARG_TIME) == 0) {
                    if (TIME_FORMAT.matcher(argComponents[i]).find()) {
                        numOfTime++;
                        if (numOfTime == ONE)
                            arg = argComponents[i];
                        else if (numOfTime == TWO)
                            arg += DELIMITER_BLANK_SPACE + argComponents[i];
                    } else if (argComponents[i].toUpperCase().compareToIgnoreCase(NONE) == 0)
                        arg = null;
                } else if (argType.toUpperCase().compareToIgnoreCase(TASK_ARG_TAG) == 0) {
                    if (argComponents[i].toUpperCase().compareToIgnoreCase(NONE) == 0)
                        arg = null;
                    else
                        arg += argComponents[i] + DELIMITER_BLANK_SPACE;
                }
            }

            try {
                return new UpdateCommand(taskType, index.get(), argType, arg);
            } catch (IllegalValueException ive) {
                return new IncorrectCommand(ive.getMessage());
            } catch (ParseException pe) {
                return new IncorrectCommand(pe.getMessage());
            } catch (NoSuchElementException nsee) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
            }
        }

        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }

        if (!isValidUpdateCommandFormat(taskType, index.get(), argType)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }

        try {
            return new UpdateCommand(taskType, index.get(), argType, arg);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (ParseException pe) {
            return new IncorrectCommand(pe.getMessage());
        }
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public synchronized void updateTask(ReadOnlyTask old, Task toUpdate)
            throws TaskNotFoundException, DuplicateTaskException {
        whatNow.updateTask(old, toUpdate);
        indicateUpdateTask(toUpdate);
        unblockFreeTime();
        indicateWhatNowChanged();
    }

```
###### \java\seedu\whatnow\model\ReadOnlyWhatNow.java
``` java

import java.util.List;

import seedu.whatnow.model.tag.Tag;
import seedu.whatnow.model.tag.UniqueTagList;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.UniqueTaskList;

/**
 * Unmodifiable view of WhatNow
 */
public interface ReadOnlyWhatNow {

    UniqueTagList getUniqueTagList();

    UniqueTaskList getUniqueTaskList();

    /**
     * Returns an unmodifiable view of tasks list
     */
    List<ReadOnlyTask> getTaskList();

    /**
     * Returns an unmodifiable view of tags list
     */
    List<Tag> getTagList();

}
```
###### \java\seedu\whatnow\model\task\ReadOnlyTask.java
``` java
    /**
     * Formats the task as text, showing all details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName());
        
        if (getTaskDate() != null) {
            builder.append(" on " + getTaskDate());
            if(getTaskTime() != null ){
                builder.append(" " + getTaskTime());
            } else { 
                if (getStartTime() != null) {
                    builder.append(" from " + getStartTime());
                }
                if (getEndTime() != null) {
                    builder.append(" to " + getEndTime());
                }
            }
        } else { 
            if (getStartDate() != null) {
                builder.append(" from " + getStartDate());
            } 
            if (getStartTime() != null) {
                builder.append(" " + getStartTime());
            }
            if (getEndDate() != null) {
                builder.append(" to " + getEndDate());
            }
            if (getEndTime() != null) {
                builder.append(" " + getEndTime());
            }
        }
        
        if (getPeriod() != null) {
            builder.append(" every " + getPeriod());
        }
        
        if (getEndPeriod() != null) {
            builder.append(" till " + getEndPeriod());
        }
        
        if (getTags().size() > 0) {
            builder.append(" ");
            getTags().forEach(builder::append);
        }
        
        return builder.toString();
    }

```
###### \java\seedu\whatnow\model\task\Recurrence.java
``` java
package seedu.whatnow.model.task;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;

public class Recurrence {
    private static final String DATE_WITH_SLASH_FORMAT= "dd/MM/yyyy";
    private static final String EMPTY_STRING = "";
    private static final String FORWARD_SLASH = "/";
    private static final String SINGLE_DIGIT = ("^(\\d)$");
    private static final String LEAP_YEAR_DATE = "29/02/";
    private static final String DAILY = "day";
    private static final String WEEKLY = "week";
    private static final String MONTHLY = "month";
    private static final String YEARLY = "year";
    
    private static final int ZERO = 0;
    private static final int ONE = 1;
    private static final int DATE_DAY = 0;
    private static final int DATE_MONTH = 1;
    private static final int DATE_YEAR = 2;   

    private String period = null;
    private String taskDate = null;
    private String startDate = null;
    private String endDate = null;
    private String endPeriod = null;
    
    private HashMap<Integer, Integer> daysInMonths = new HashMap<Integer, Integer>();
    
    public Recurrence(String period, String taskDate, String startDate, String endDate, String endPeriod) {
        this.period = period;
        this.taskDate = taskDate;
        this.startDate = startDate;
        this.endDate = endDate;
        this.endPeriod = endPeriod;
        daysInMonths = storeDaysInMonths(daysInMonths);
    }
    
    public String getPeriod() {
        return this.period;
    }
    
    public void setPeriod(String period) {
        this.period = period;
    }
    
    public String getTaskDate() {
        return this.taskDate;
    }
    
    public void setTaskDate(String taskDate) {
        this.taskDate = taskDate;
    }
    
    public String getStartDate() {
        return this.startDate;
    }
    
    public void setStartDate(String startDate) {
        this.startDate = startDate;
    }
    
    public String getEndDate() {
        return this.endDate;
    }
    
    public void setEndDate(String endDate) {
        this.endDate = endDate;
    }
    
    public String getEndPeriod() {
        return this.endPeriod;
    }
    
    public void setEndPeriod(String endPeriod) {
        this.endPeriod = endPeriod;
    }

    private static HashMap<Integer, Integer> storeDaysInMonths(HashMap<Integer, Integer> daysInMonths) {
        daysInMonths.put(1, 31);
        daysInMonths.put(2, 29);
        daysInMonths.put(3, 31);
        daysInMonths.put(4, 30);
        daysInMonths.put(5, 31);
        daysInMonths.put(6, 30);
        daysInMonths.put(7, 31);
        daysInMonths.put(8, 31);
        daysInMonths.put(9, 30);
        daysInMonths.put(10, 31);
        daysInMonths.put(11, 30);
        daysInMonths.put(12, 31);
        return daysInMonths;
    }
    
    public boolean hasRecurring() {
        return this.period != null;
    }
    
    public boolean hasNextTask(String date) {
        Date nextDate = null;
        try {
            DateFormat df = new SimpleDateFormat(DATE_WITH_SLASH_FORMAT);
            df.setLenient(false);
            nextDate = df.parse(date);
        } catch(ParseException ex) {
            return false;
        }
        
        Calendar d = new GregorianCalendar();
        d.setTime(nextDate);
        d.set(Calendar.HOUR_OF_DAY, 00);
        d.set(Calendar.MINUTE, 00);
        d.set(Calendar.SECOND, 00);
        nextDate = d.getTime();
        
        Date recurringEndDate = null;
        try {
            DateFormat df = new SimpleDateFormat(DATE_WITH_SLASH_FORMAT);
            df.setLenient(false);
            recurringEndDate = df.parse(endPeriod);
        } catch(ParseException ex) {
            return false;
        }
        
        //Following checks if the user input date is invalid i.e before today's date
        Calendar r = new GregorianCalendar();
        r.setTime(recurringEndDate);
        r.set(Calendar.HOUR_OF_DAY, 23);
        r.set(Calendar.MINUTE, 59);
        r.set(Calendar.SECOND, 59);
        Date recurEndDate = r.getTime();
        
        if(recurEndDate.compareTo(nextDate) < 0) {
            return false;
        }
        
        return true;
    }
    
    /**
     * Formats the input date to the DD/MM/YYYY format
     * @param date The date to be formatted in DD/MM/YYYY format but DD and MM may be single digit
     * @return the formatted date with a zero padded in front of single digits in DD and MM
     */
    private static String formatDate(String[] splitDate) {
        String date = EMPTY_STRING;
        
        for (int i = 0; i < splitDate.length; i++) {
            date += splitDate[i].replaceAll(SINGLE_DIGIT, ZERO + splitDate[i]);
            if (i < splitDate.length - ONE) {
                date += FORWARD_SLASH;
            }
        }
        
        return date;
    }
    
    public String getNextDay(String date) {
        String[] splitDate = date.split(FORWARD_SLASH);      
        int day = Integer.parseInt(splitDate[DATE_DAY]) + 1;
        int month = Integer.parseInt(splitDate[DATE_MONTH]);
        int year = Integer.parseInt(splitDate[DATE_YEAR]);
        
        while (daysInMonths.get(month) == null || day > daysInMonths.get(month)) {
            if (month > 12) {
                year++;
                month = 1;
                break;
            }
            
            if (day > daysInMonths.get(month)) {
                month++;
                day = 1;
            }  
        }

        //February
        if (month == 2 && day == 29) {
            try {
                DateFormat df = new SimpleDateFormat(DATE_WITH_SLASH_FORMAT);
                df.setLenient(false);
                df.parse(LEAP_YEAR_DATE + year);
            } catch(ParseException ex) {
                day = 1;
                month++;
            }
        }
        
        splitDate[DATE_DAY] = (day < 10) ? "0" + day : EMPTY_STRING + day;
        splitDate[DATE_MONTH] = (month < 10) ? "0" + month : EMPTY_STRING + month;
        splitDate[DATE_YEAR] = EMPTY_STRING + year;
        
        return formatDate(splitDate);
    }
    
    public String getNextWeek(String date) {
        String formattedDate;
        String[] splitDate = date.split(FORWARD_SLASH);      
        int day = Integer.parseInt(splitDate[DATE_DAY]) + 7;
        int month = Integer.parseInt(splitDate[DATE_MONTH]);
        int year = Integer.parseInt(splitDate[DATE_YEAR]);
        
        while (daysInMonths.get(month) == null || day > daysInMonths.get(month)) {
            if (month > 12) {
                year++;
                month = 1;
                break;
            }
            
            if (day > daysInMonths.get(month)) {
                day -= daysInMonths.get(month);
                month++;
            } 
        }
        
        //February
        if (month == 2 && day == 29) {
            try {
                DateFormat df = new SimpleDateFormat(DATE_WITH_SLASH_FORMAT);
                df.setLenient(false);
                df.parse(date);
            } catch(ParseException ex) {
                day = 1;
                month++;
            }
        } else if (month == 3 && day < 7) {
            try {
                DateFormat df = new SimpleDateFormat(DATE_WITH_SLASH_FORMAT);
                df.setLenient(false);
                df.parse(LEAP_YEAR_DATE + year);
            } catch(ParseException ex) {
                day++;             
            }
        }
        
        splitDate[DATE_DAY] = (day < 10) ? "0" + day : EMPTY_STRING + day;
        splitDate[DATE_MONTH] = (month < 10) ? "0" + month : EMPTY_STRING + month;
        splitDate[DATE_YEAR] = EMPTY_STRING + year;
        formattedDate = formatDate(splitDate);
        
        return formattedDate;
    }
    
    public String getNextMonth(String date) {
        String[] splitDate = date.split(FORWARD_SLASH);      
        int day = Integer.parseInt(splitDate[DATE_DAY]);
        int month = Integer.parseInt(splitDate[DATE_MONTH]) + 1;
        int year = Integer.parseInt(splitDate[DATE_YEAR]);
        
        while (daysInMonths.get(month) == null || day > daysInMonths.get(month)) {
            if (month > 12) {
                year++;
                month = 1;
                break;
            }
            
            if (day > daysInMonths.get(month)) {
                day = daysInMonths.get(month);
            }
        }
        
        //February
        if (month == 2 && day == 29) {
            try {
                DateFormat df = new SimpleDateFormat(DATE_WITH_SLASH_FORMAT);
                df.setLenient(false);
                df.parse(LEAP_YEAR_DATE + year);
            } catch(ParseException ex) {
                day = 28;
            }
        }
        
        splitDate[DATE_DAY] = (day < 10) ? "0" + day : EMPTY_STRING + day;
        splitDate[DATE_MONTH] = (month < 10) ? "0" + month : EMPTY_STRING + month;
        splitDate[DATE_YEAR] = EMPTY_STRING + year;

        return formatDate(splitDate);
    }
    
    public String getNextYear(String date) {
        String[] splitDate = date.split(FORWARD_SLASH);      
        int day = Integer.parseInt(splitDate[DATE_DAY]);
        int month = Integer.parseInt(splitDate[DATE_MONTH]);
        int year = Integer.parseInt(splitDate[DATE_YEAR]) + 1;
        
        //February
        if (month == 2 && day == 29) {
            try {
                DateFormat df = new SimpleDateFormat(DATE_WITH_SLASH_FORMAT);
                df.setLenient(false);
                df.parse(LEAP_YEAR_DATE + year);
            } catch(ParseException ex) {
                day = 28;
            }
        }
        
        splitDate[DATE_DAY] = (day < 10) ? "0" + day : EMPTY_STRING + day;
        splitDate[DATE_MONTH] = (month < 10) ? "0" + month : EMPTY_STRING + month;
        splitDate[DATE_YEAR] = EMPTY_STRING + year;
        
        return formatDate(splitDate);
    }
    
    public Task getNextTask(Task currentTask) {
        if (this.period.equals(DAILY)) {
            if (this.taskDate != null) {
                this.taskDate = getNextDay(this.taskDate);
            }
        } else if (this.period.equals(WEEKLY)) {
            if (this.taskDate != null) {
                this.taskDate = getNextWeek(this.taskDate);
            }
        } else if (this.period.equals(MONTHLY)) {
            if (this.taskDate != null) {
                this.taskDate = getNextMonth(this.taskDate);
            } else if (this.startDate != null) {
                this.startDate = getNextMonth(this.startDate);
                this.endDate = getNextMonth(this.endDate);
            }
        } else if (this.period.equals(YEARLY)) {
            if (this.taskDate != null) {
                this.taskDate = getNextYear(this.taskDate);
            } else if (this.startDate != null) {
                this.startDate = getNextYear(this.startDate);
                this.endDate = getNextYear(this.endDate);
            }
        }
        
        return new Task(currentTask.getName(), this.taskDate, this.startDate, this.endDate, currentTask.getTaskTime(), currentTask.getStartTime(), currentTask.getEndTime(), currentTask.getPeriod(), currentTask.getEndPeriod(), currentTask.getTags(), currentTask.getStatus(), currentTask.getTaskType());
    }
    
	@Override
	public String toString() {
	    String str = EMPTY_STRING;
	    if (this.taskDate != null) {
	        str = this.taskDate;
	    }
	    
	    if (this.startDate != null) {
	        str = this.startDate;
	    }
	    
	    if (this.endDate != null) {
	        str += " to " + this.endDate;
	    }
	    
	    if (this.period != null) {
	        str += " every " + this.period;
	    }
	    
	    if (this.endPeriod != null) {
	        str += " till " + endPeriod;
	    }
	    
	    return str;
	}
	
	@Override
	public boolean equals(Object other) {
	    return true;
	}
}
```
###### \java\seedu\whatnow\model\task\Task.java
``` java
    /**
     * Every field must be present and not null.
     */
    public Task(Name name, String taskDate, String startDate, String endDate, String taskTime, String startTime, String endTime, String period, String endPeriod, UniqueTagList tags, String status, String taskType) {
        assert !CollectionUtil.isAnyNull(name, tags);
        this.name = name;
        this.period = period;
        this.endPeriod = endPeriod;
        this.tags = new UniqueTagList(tags);
        this.status = status;
        this.taskType = FLOATING;
        if (taskDate != null) {
            this.taskDate = taskDate;
            this.taskType = NOT_FLOATING;
        }

        if (startDate != null) {
            this.startDate = startDate;
            this.taskType = NOT_FLOATING;
        }

        if (endDate != null) {
            this.endDate = endDate;
            this.taskType = NOT_FLOATING;
        }

        if (taskTime != null) {
            this.taskTime = taskTime;
            this.taskType = NOT_FLOATING;
        }

        if (startTime != null) {
            this.startTime = startTime;
            this.taskType = NOT_FLOATING;
        }

        if (endTime != null) {
            this.endTime = endTime;
            this.taskType = NOT_FLOATING;
        }
        
        if (taskType != null) {
            this.taskType = taskType;
        }
    }

    /**
     * Copy constructor.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getTaskDate(), source.getStartDate(), source.getEndDate(), source.getTaskTime(), source.getStartTime(), source.getEndTime(), source.getPeriod(), source.getEndPeriod(), source.getTags(), source.getStatus(), source.getTaskType());
    }

    @Override
    public Name getName() {
        return name;
    }

    @Override
    public String getTaskDate() {
        return taskDate;
    }

    @Override
    public String getStartDate() {
        return startDate;
    }

    @Override
    public String getEndDate() {
        return endDate;
    }

    @Override
    public String getTaskTime() {
        return taskTime;
    }

    @Override
    public String getStartTime() {
        return startTime;
    }

    @Override
    public String getEndTime() {
        return endTime;
    }
    
    @Override
    public String getPeriod() {
        return period;
    }
    
    @Override
    public String getEndPeriod() {
        return endPeriod;
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }

    @Override
    public String getStatus() {
        return status;
    }

    @Override
    public String getTaskType() {
        return taskType;
    }

    public void setName(Name name) {
        this.name = name;
    }

    public void setTaskDate(String date) {
        this.taskDate = date;
    }

    public void setStartDate(String startDate) {
        this.startDate = startDate;
    }

    public void setEndDate(String endDate) {
        this.endDate = endDate;
    }

    public void setTaskTime(String time) {
        this.taskTime = time;
    }

    public void setStartTime(String startTime) {
        this.startTime = startTime;
    }

    public void setEndTime(String endTime) {
        this.endTime = endTime;
    }
    
    public void setPeriod(String period) {
        this.period = period;
    }
    
    public void setEndPeriod(String endPeriod) {
        this.endPeriod = endPeriod;
    }
    
    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public void setTaskType(String taskType) {
        this.taskType = taskType;
    }

```
###### \java\seedu\whatnow\model\task\UniqueTaskList.java
``` java
    /**
     * Updates the equivalent task from the list.
     *
     * @throws TaskNotFoundException
     *             if no such task could be found in the list.
     */
    public boolean update(ReadOnlyTask old, Task toUpdate) throws TaskNotFoundException, DuplicateTaskException {
        assert old != null;
        final boolean taskFoundAndUpdated = internalList.contains(old);
        if (!taskFoundAndUpdated) {
            throw new TaskNotFoundException();
        }
        if (internalList.contains(toUpdate)) {
            throw new DuplicateTaskException();
        }
        internalList.set(internalList.indexOf(old), toUpdate);
        return taskFoundAndUpdated;
    }

```
###### \java\seedu\whatnow\storage\XmlAdaptedTask.java
``` java
package seedu.whatnow.storage;

import javax.xml.bind.annotation.XmlElement;

import seedu.whatnow.commons.exceptions.IllegalValueException;
import seedu.whatnow.model.tag.Tag;
import seedu.whatnow.model.tag.UniqueTagList;
import seedu.whatnow.model.task.*;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;

/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    @XmlElement(required = true)
    private String name;

    @XmlElement(required = true)
    private String taskDate;

    @XmlElement
    private String startDate;

    @XmlElement
    private String endDate;

    @XmlElement
    private String taskTime;

    @XmlElement
    private String startTime;

    @XmlElement
    private String endTime;

    @XmlElement
    private String period;
    
    @XmlElement
    private String endPeriod;
    
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    @XmlElement
    private String status;

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTask() {
    }

    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source
     *            future changes to this will not affect the created
     *            XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName().fullName;
        tagged = new ArrayList<>();
        if(source.getTaskDate() != null) {
        	taskDate = source.getTaskDate();
        }
        if (source.getStartDate() != null) {
            startDate = source.getStartDate();
        }
        if (source.getEndDate() != null) {
            endDate = source.getEndDate();
        }
        if (source.getTaskTime() != null) {
            taskTime = source.getTaskTime();
        }
        if (source.getStartTime() != null) {
            startTime = source.getStartTime();
        }
        if (source.getEndTime() != null) {
            endTime = source.getEndTime();
        }
        if (source.getPeriod() != null) {
            period = source.getPeriod();
        }
        if (source.getEndPeriod() != null) {
            endPeriod = source.getEndPeriod();
        }
        status = source.getStatus();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task
     * object.
     *
     * @throws IllegalValueException
     *             if there were any data constraints violated in the adapted
     *             task
     * @throws ParseException
     */
    public Task toModelType() throws IllegalValueException, ParseException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        final Name name = new Name(this.name);
        final UniqueTagList tags = new UniqueTagList(taskTags);
        return new Task(name, taskDate, startDate, endDate, taskTime, startTime, endTime, period, endPeriod, tags, status, null);
    }
}
```
###### \java\seedu\whatnow\storage\XmlWhatNowStorage.java
``` java
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Optional;
import java.util.logging.Logger;
import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.exceptions.DataConversionException;
import seedu.whatnow.commons.util.FileUtil;
import seedu.whatnow.model.ReadOnlyWhatNow;

/**
 * A class to access WhatNow data stored as an xml file on the hard disk.
 */
public class XmlWhatNowStorage implements WhatNowStorage {

    private static final Logger logger = LogsCenter.getLogger(XmlWhatNowStorage.class);

    private String filePath;

    public XmlWhatNowStorage(String filePath) {
        this.filePath = filePath;
    }

    public String getWhatNowFilePath() {
        return filePath;
    }

    /**
     * Sets the file path of the WhatNow data
     * 
     * @param filePath
     *            new location of the WhatNow data file.
     */
    public void setWhatNowFilePath(String filePath) {
        this.filePath = filePath;
    }

    /**
     * Similar to {@link #readWhatNow()}
     * 
     * @param filePath
     *            location of the data. Cannot be null
     * @throws DataConversionException
     *             if the file is not in the correct format.
     */
    public Optional<ReadOnlyWhatNow> readWhatNow(String filePath)
            throws DataConversionException, FileNotFoundException {
        assert filePath != null;

        File whatNowFile = new File(filePath);

        if (!whatNowFile.exists()) {
            logger.info("WhatNow file " + whatNowFile + " not found");
            return Optional.empty();
        }

        ReadOnlyWhatNow whatNowOptional = XmlFileStorage.loadDataFromSaveFile(new File(filePath));

        return Optional.of(whatNowOptional);
    }

    /**
     * Similar to {@link #saveWhatNow(ReadOnlyWhatNow)}
     * 
     * @param filePath
     *            location of the data. Cannot be null
     */
    public void saveWhatNow(ReadOnlyWhatNow whatNow, String filePath) throws IOException {
        assert whatNow != null;
        assert filePath != null;

        File file = new File(filePath);
        FileUtil.createIfMissing(file);
        XmlFileStorage.saveDataToFile(file, new XmlSerializableWhatNow(whatNow));
    }

    @Override
    public Optional<ReadOnlyWhatNow> readWhatNow() throws DataConversionException, IOException {
        return readWhatNow(filePath);
    }

    @Override
    public void saveWhatNow(ReadOnlyWhatNow whatNow) throws IOException {
        saveWhatNow(whatNow, filePath);
    }
}
```
