# A0126240W
###### \java\seedu\whatnow\logic\commands\AddCommand.java
``` java
	public AddCommand(String name, String date, String startDate, String endDate, String time, String startTime, String endTime, Set<String> tags) throws IllegalValueException, ParseException {
	    TaskTime validateTime = null;
	    TaskDate validateDate = null;
	    
	    if (time != null || startTime != null || endTime != null) {
	        validateTime = new TaskTime(time, startTime, endTime, date, startDate, endDate);
	        if (date == null && startDate == null && endDate == null)
	            date = validateTime.getDate();
	    }
	    
	    if (date != null || startDate != null || endDate != null) {
	        validateDate = new TaskDate(date, startDate, endDate);
	        if (date != null) {
	            date = validateDate.getDate();
	        } else if (startDate != null) {
	            startDate = validateDate.getStartDate();
	            endDate = validateDate.getEndDate();
	        }
	    }
	    
	    final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }    
        
        this.toAdd = new Task(new Name(name), date, startDate, endDate, time, startTime, endTime, new UniqueTagList(tagSet), STATUS_INCOMPLETE, null);
	}

```
###### \java\seedu\whatnow\logic\commands\UpdateCommand.java
``` java
package seedu.whatnow.logic.commands;

import java.text.ParseException;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import seedu.whatnow.commons.core.Messages;
import seedu.whatnow.commons.core.UnmodifiableObservableList;
import seedu.whatnow.commons.exceptions.IllegalValueException;
import seedu.whatnow.model.tag.Tag;
import seedu.whatnow.model.tag.UniqueTagList;
import seedu.whatnow.model.task.Name;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.Task;
import seedu.whatnow.model.task.TaskDate;
import seedu.whatnow.model.task.TaskTime;
import seedu.whatnow.model.task.UniqueTaskList;
import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Update a task with new description/date/time/tag using it's last displayed index from WhatNow.
 */
public class UpdateCommand extends UndoAndRedo {
    
    public static final String COMMAND_WORD = "update";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD 
            + ": Updates the description/date/time/tag of the task identified by the index number used in the last task listing.\n"
            + "Parameters: todo/schedule INDEX (must be a positive integer) description/date/time/tag DESCRIPTION/DATE/TIME/TAG\n"
            + "Example: " + COMMAND_WORD + " todo 1 tag priority low";
    
    public static final String MESSAGE_UPDATE_TASK_SUCCESS = "Updated Task: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in WhatNow";
    
    private static final String ARG_TYPE_DESCRIPTION = "description";
    private static final String ARG_TYPE_DATE = "date";
    private static final String ARG_TYPE_TIME = "time";
    private static final String ARG_TYPE_TAG = "tag";
    private static final String DELIMITER_BLANK_SPACE = " ";
    private static final String TASK_TYPE_TODO = "todo";
    private static final String TASK_TYPE_FLOATING = "floating";
    private static final String TASK_TYPE_NOT_FLOATING = "not_floating";
    private static final String DEFAULT = "default";
    
    private static final int ZERO = 0;
    private static final int ONE = 1;
    private static final int TWO = 2;
    
    public final int targetIndex;
    public final String taskType;
    public final String arg_type;
    public final String arg;
    private Task toUpdate;
    
    public UpdateCommand(String taskType, int targetIndex, String arg_type, String arg) throws IllegalValueException, ParseException {
        this.taskType = taskType;
        this.targetIndex = targetIndex;
        this.arg_type = arg_type;
        this.arg = arg;
        processArg();
    }
    
    /**
     * Processes the arguments in the update command
     *
     * @throws IllegalValueException if any of the raw values are invalid
     * @throws ParseException 
     */
    private void processArg() throws IllegalValueException, ParseException {
        String newName = DEFAULT;
        String date = null;
        String startDate = null;
        String endDate = null;
        String time = null;
        String startTime = null;
        String endTime = null;
        final Set<Tag> tagSet = new HashSet<>();
        
        if (arg_type.toUpperCase().compareToIgnoreCase(ARG_TYPE_DESCRIPTION) == ZERO) {
            newName = arg;
        }
        
        if (arg_type.toUpperCase().compareToIgnoreCase(ARG_TYPE_DATE) == ZERO) {
            if (arg != null) {
                String[] argComponents = arg.trim().split(DELIMITER_BLANK_SPACE);

                if (argComponents.length == ONE) {
                    date = argComponents[ZERO];  
                } else if (argComponents.length == TWO) {
                    startDate = argComponents[ZERO];
                    endDate = argComponents[ONE];
                }
            } 
        }
        
        if (arg_type.toUpperCase().compareToIgnoreCase(ARG_TYPE_TIME) == ZERO) {
            if (arg != null) {
                String[] argComponents = arg.trim().split(DELIMITER_BLANK_SPACE);
                if (argComponents.length == ONE) {
                    time = argComponents[ZERO];
                } else if (argComponents.length == TWO) {
                    startTime = argComponents[ZERO];
                    endTime = argComponents[ONE];
                }
            } 
        }
        
        if (arg_type.toUpperCase().compareToIgnoreCase(ARG_TYPE_TAG) == ZERO) {
            if (arg != null) {
                Set<String> tags = processTag();
                for (String tagName : tags) {
                    tagSet.add(new Tag(tagName));
                }
            }   
        }
        
        TaskTime validateTime = null;
        TaskDate validateDate = null;
        
        if (time != null || startTime != null || endTime != null) {
            validateTime = new TaskTime(time, startTime, endTime, date, startDate, endDate);
            if (date == null && startDate == null && endDate == null) {
                date = validateTime.getDate();
            }
        }
        
        if (date != null || startDate != null || endDate != null) {
            validateDate = new TaskDate(date, startDate, endDate);
            if (date != null) {
                date = validateDate.getDate();
            } else if (startDate != null) {
                startDate = validateDate.getStartDate();
                endDate = validateDate.getEndDate();
            }
        }
        
        toUpdate = new Task(new Name(newName), date, startDate, endDate, time, startTime, endTime, new UniqueTagList(tagSet), null, null);
    }
    
    /**
     * Processes the tags in the update command
     */
    private Set<String> processTag() {
        if (arg.isEmpty()) {
            return Collections.emptySet();
        }
        final Collection<String> tagStrings = Arrays.asList(arg.split(DELIMITER_BLANK_SPACE));
        return new HashSet<>(tagStrings);
    }
    
    private void updateTheCorrectField(ReadOnlyTask taskToUpdate) {
        if (arg_type.toUpperCase().compareToIgnoreCase(ARG_TYPE_DESCRIPTION) == ZERO) {
            toUpdate.setTags(taskToUpdate.getTags());
            toUpdate.setTaskDate(taskToUpdate.getTaskDate());
            toUpdate.setStartDate(taskToUpdate.getStartDate());
            toUpdate.setEndDate(taskToUpdate.getEndDate());
            toUpdate.setTaskTime(taskToUpdate.getTaskTime());
            toUpdate.setStartTime(taskToUpdate.getStartTime());
            toUpdate.setEndTime(taskToUpdate.getEndTime());
            toUpdate.setStatus(taskToUpdate.getStatus());
            toUpdate.setTaskType(taskToUpdate.getTaskType());
        }
        if (arg_type.toUpperCase().compareToIgnoreCase(ARG_TYPE_DATE) == ZERO) {
            toUpdate.setName(taskToUpdate.getName());
            if (arg != null) {
                toUpdate.setTaskTime(taskToUpdate.getTaskTime());
                toUpdate.setStartTime(taskToUpdate.getStartTime());
                toUpdate.setEndTime(taskToUpdate.getEndTime());
            }
            toUpdate.setTags(taskToUpdate.getTags());
            toUpdate.setStatus(taskToUpdate.getStatus());            
        }
        if (arg_type.toUpperCase().compareToIgnoreCase(ARG_TYPE_TIME) == ZERO) {
            toUpdate.setName(taskToUpdate.getName());
            if (taskToUpdate.getTaskDate() != null) {
                toUpdate.setTaskDate(taskToUpdate.getTaskDate());
            }
            
            if (taskToUpdate.getStartDate() != null) {
                toUpdate.setStartDate(taskToUpdate.getStartDate());
            }
            
            if (taskToUpdate.getEndDate() != null) {
                toUpdate.setEndDate(taskToUpdate.getEndDate());
            }
            
            toUpdate.setTags(taskToUpdate.getTags());
            toUpdate.setStatus(taskToUpdate.getStatus());
        }
        if (arg_type.toUpperCase().compareToIgnoreCase(ARG_TYPE_TAG) == ZERO) {
            toUpdate.setName(taskToUpdate.getName());
            toUpdate.setTaskDate(taskToUpdate.getTaskDate());
            toUpdate.setStartDate(taskToUpdate.getStartDate());
            toUpdate.setEndDate(taskToUpdate.getEndDate());
            toUpdate.setTaskTime(taskToUpdate.getTaskTime());
            toUpdate.setStartTime(taskToUpdate.getStartTime());
            toUpdate.setEndTime(taskToUpdate.getEndTime());
            toUpdate.setStatus(taskToUpdate.getStatus());
            toUpdate.setTaskType(taskToUpdate.getTaskType());
        }
        
        if (toUpdate.getTaskDate() == null && toUpdate.getStartDate() == null && toUpdate.getEndDate() == null && toUpdate.getTaskTime() == null && toUpdate.getStartTime() == null && toUpdate.getEndTime() == null) {
            toUpdate.setTaskType(TASK_TYPE_FLOATING);
        }
        else {
            toUpdate.setTaskType(TASK_TYPE_NOT_FLOATING);
        }
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
package seedu.whatnow.logic.parser;

import static seedu.whatnow.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.whatnow.commons.core.Messages.MESSAGE_UNKNOWN_COMMAND;

import java.text.ParseException;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.whatnow.commons.exceptions.IllegalValueException;
import seedu.whatnow.commons.util.StringUtil;
import seedu.whatnow.logic.commands.*;
import seedu.whatnow.model.tag.Tag;

/**
 * Parses user input.
 */
public class Parser {
    /**
     * Used for initial separation of command word and args.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    private static final Pattern TASK_INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>.+)");

    /**
     * One or more keywords separated by whitespace
     */
    private static final Pattern KEYWORDS_ARGS_FORMAT = Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)");

    /**
     * Forward slashes are reserved for delimiter prefixes
     * variable number of tags
     */
    private static final Pattern TASK_DATA_ARGS_FORMAT = Pattern.compile("(?<name>[^/]+)" + "(?<tagArguments>(?: t/[^/]+)*)"); 

    /**
     * This arguments is for e.g. add task on today, add task on 18/10/2016
     */
    private static final Pattern TASK_MODIFIED_WITH_DATE_ARGS_FORMAT = Pattern.compile("(?<name>[^/]+)\\s" + "(.*?\\bon|by\\b.*?\\s)??" +
            "(?<dateArguments>([0-3]??[0-9][//][0-1]??[0-9][//][0-9]{4})??)" + "(?<tagArguments>(?: t/[^/]+)*)");	

    /**
     * Regular Expressions
     */
	private static final Pattern UPDATE_FORMAT = Pattern.compile("^((todo|schedule)\\s(\\d+)\\s(description|date|time|start|end|tag)($|\\s))");

    private static final Pattern DATE_SUFFIX = Pattern.compile("(st|nd|rd|th)$");
    private static final Pattern DATE = Pattern.compile("^(([3][0-1])|([1-2][0-9])|([0]??[1-9]))$");
    private static final Pattern DATE_WITH_SUFFIX = Pattern.compile("^((([3][0-1])|([1-2][0-9])|([0]??[1-9]))(st|nd|rd|th))$");
    private static final Pattern MONTH_IN_FULL = Pattern.compile("^(january|february|march|april|may|june|july|august|september|october|november|december)$");
    private static final Pattern MONTH_IN_SHORT = Pattern.compile("^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)$");
    private static final Pattern YEAR = Pattern.compile("^([0-9]{4})$");
    
    private static final Pattern DATE_WITH_SLASH_FORMAT = Pattern.compile("^(([3][0-1])|([1-2][0-9])|([0]??[1-9]))[/](([1][0-2])|([0]??[1-9]))[/]([0-9]{4})$");
    private static final Pattern TIME_FORMAT = Pattern.compile("^(([1][0-2])|([0-9]))((:|\\.)([0-5][0-9]))??((am)|(pm))$");
    private static final Pattern TAG_FORMAT = Pattern.compile("^(t/)");

    private static final Pattern TODAY_OR_TOMORROW = Pattern.compile("^(today|tomorrow)$");
    private static final Pattern DAYS_IN_FULL = Pattern.compile("^(monday|tuesday|wednesday|thursday|friday|saturday|sunday)$");
    private static final Pattern DAYS_IN_SHORT = Pattern.compile("^(mon|tue|tues|wed|thu|thur|fri|sat|sun)$");

    private static final Pattern KEYWORD_FOR_DATE = Pattern.compile("^((on)|(by)|(from)|(to))$");
    private static final Pattern KEYWORD_FOR_TIME = Pattern.compile("^((at)|(by)|(from)|(to)|(till))$");
    
    /**
     * Integer Constants
     */
    private static final int ONE = 1;
    private static final int TWO = 2;

    private static final int TASK_TYPE = 0;
    private static final int INDEX = 1;
    private static final int ARG_TYPE = 2;
    private static final int ARG = 3;

    private static final int TIME_WITHOUT_PERIOD = 0;
    private static final int TIME_HOUR = 0;
    private static final int TIME_MINUTES = 1;
    
    private static final int ADD_COMMAND_DESCRIPTION_INDEX = 1;
    private static final int ADD_COMMAND_TAG_INDEX = 1;
    private static final int ADD_COMMAND_MIN_ARGUMENTS = 2;
    private static final int NUM_OF_QUOTATION_MARKS = 2;
    
    private static final int UPDATE_COMMAND_MIN_ARGUMENTS = 3;

    private static final int LIST_ARG = 0;

    private static final int CHANGE_LOCATION = 0;
    private static final int CHANGE_LOCATION_TO = 1;
    private static final int CHANGE_LOCATION_TO_PATH = 2;

    /**
     * String Constants
     */
    private static final String NONE = "none";
    private static final String DESCRIPTION = "description";

    private static final String DELIMITER_BLANK_SPACE = " ";
    private static final String DELIMITER_DOUBLE_QUOTATION_MARK = "\"";
    private static final String DELIMITER_FORWARD_SLASH = "/";

    private static final String BACK_SLASH = "\\";
    private static final String FORWARD_SLASH = "/";
    private static final String EMPTY_STRING = "";
    
    private static final String DATE_SUFFIX_STRING = "(st|nd|rd|th)$";

    private static final String TIME_COLON = ":";
    private static final String TIME_DOT = ".";
    private static final String TIME_AM = "am";
    private static final String TIME_PM = "pm";
    private static final String TIME_DEFAULT_MINUTES = "00";
    private static final String DEFAULT_START_TIME = "12:00am";
    private static final String DEFAULT_END_TIME = "11:59pm";

    private static final String TASK_TYPE_FLOATING = "todo";
    private static final String TASK_TYPE_NON_FLOATING = "schedule";

    private static final String LIST_COMMAND_ARG_COMPLETED = "done";
    private static final String LIST_COMMAND_ARG_NOT_SPECIFIED = "";
    private static final String LIST_COMMAND_ARG_ALL_TASKS = "all";

    private static final String TASK_ARG_DESCRIPTION = "description";
    private static final String TASK_ARG_TAG = "tag";
    private static final String TASK_ARG_DATE = "date";
    private static final String TASK_ARG_TIME = "time";

    public Parser() {}

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     * @throws ParseException 
     */
    public Command parseCommand(String userInput) throws ParseException {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }
        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");

        switch (commandWord) {
        case AddCommand.COMMAND_WORD:
            return prepareAdd(arguments);

        case SelectCommand.COMMAND_WORD:
            return prepareSelect(arguments);

        case DeleteCommand.COMMAND_WORD:
            return prepareDelete(arguments);

        case ClearCommand.COMMAND_WORD:
            return new ClearCommand();

        case FindCommand.COMMAND_WORD:
            return prepareFind(arguments);

        case ListCommand.COMMAND_WORD:
            return prepareList(arguments);

        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD:
            return new HelpCommand();

        case UpdateCommand.COMMAND_WORD:
            return prepareUpdate(arguments);

        case ChangeCommand.COMMAND_WORD:
            return prepareChange(arguments);

        case MarkDoneCommand.COMMAND_WORD:
            return prepareMarkDone(arguments);

        case MarkUndoneCommand.COMMAND_WORD:
            return prepareMarkUndone(arguments);

        case UndoCommand.COMMAND_WORD:
            return new UndoCommand();

        case RedoCommand.COMMAND_WORD:
            return new RedoCommand();

        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }

    /**
     * Counts the number of occurrence of a substring in a string
     * @param str The given string
     * @param findStr The substring to look for in a given string
     * @return the number of occurrence
     */
    public static int countOccurence(String str, String findStr) {
        int lastIndex = 0;
        int count = 0;

        while(lastIndex != -1) {
            lastIndex = str.indexOf(findStr,lastIndex);

            if(lastIndex != -1){
                count++;
                lastIndex += findStr.length();
            }
        }

        return count;
    }

    /**
     * Formats the time to the colon format E.g. 12:30am, 4:20pm etc
     * @param time The time to be formatted
     * @param period The time period
     * @return the formatted time
     */
    public static String formatTime(String time, String period) {
        String[] splitTimePeriod = null;
        String[] splitTime = null;

        splitTimePeriod = time.toLowerCase().split(period);
        if (splitTimePeriod[TIME_WITHOUT_PERIOD].contains(TIME_COLON)) {
            splitTime = splitTimePeriod[TIME_WITHOUT_PERIOD].split(TIME_COLON);
        }

        if (splitTimePeriod[TIME_WITHOUT_PERIOD].contains(TIME_DOT)) {
            splitTime = splitTimePeriod[TIME_WITHOUT_PERIOD].split(BACK_SLASH + TIME_DOT);
        }

        time = (splitTime != null) ? splitTime[TIME_HOUR] : splitTimePeriod[TIME_WITHOUT_PERIOD];
        time += TIME_COLON;
        time += (splitTime != null) ? splitTime[TIME_MINUTES] : TIME_DEFAULT_MINUTES;
        time += period;

        return time;
    }

    /**
     * Calls the formatTime method to format the time
     * @param time The time to be formatted
     * @return the formatted time
     */
    public static String formatTime(String time) {
        if (time.contains(TIME_AM)) {
            time = formatTime(time, TIME_AM);
        } else {
            time = formatTime(time, TIME_PM);
        }

        return time;
    }
    
    public static HashMap<String, Integer> storeFullMonths(HashMap<String, Integer> months) {
        months.put("january", 1);
        months.put("february", 2);
        months.put("march", 3);
        months.put("april", 4);
        months.put("may", 5);
        months.put("june", 6);
        months.put("july", 7);
        months.put("august", 8);
        months.put("september", 9);
        months.put("october", 10);
        months.put("november", 11);
        months.put("december", 12);
        return months;
    }
    
    public static HashMap<String, Integer> storeShortMonths(HashMap<String, Integer> months) {
        months.put("jan", 1);
        months.put("feb", 2);
        months.put("mar", 3);
        months.put("apr", 4);
        months.put("may", 5);
        months.put("jun", 6);
        months.put("jul", 7);
        months.put("aug", 8);
        months.put("sep", 9);
        months.put("oct", 10);
        months.put("nov", 11);
        months.put("dec", 12);
        return months;
    }

    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args){
        boolean validArgument = true;
        boolean hasDate = false;
        boolean hasTime = false;
        int numOfDate = 0;
        int numOfTime = 0;
        String name = null;
        String date = null;
        String startDate = null;
        String endDate = null;
        String time = null;
        String startTime = null;
        String endTime = null;
        Set<String> tags = new HashSet<String>();
        String[] additionalArgs = null;
        HashMap<String, Integer> fullMonths = new HashMap<String, Integer>();
        HashMap<String, Integer> shortMonths = new HashMap<String, Integer>();
        
        fullMonths = storeFullMonths(fullMonths);
        shortMonths = storeShortMonths(shortMonths);    

        args = args.trim();
        
        //final Matcher matcher = TASK_MODIFIED_WITH_DATE_ARGS_FORMAT.matcher(args.trim());
        // Validate the format of the arguments
        /*if (!TASK_DATA_ARGS_FORMAT.matcher(args).find() && !TASK_MODIFIED_WITH_DATE_ARGS_FORMAT.matcher(args).find()){
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		}*/

        // Check whether there are two quotation marks ""
        if (countOccurence(args, DELIMITER_DOUBLE_QUOTATION_MARK) != NUM_OF_QUOTATION_MARKS) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }

        String[] arguments = args.split(DELIMITER_DOUBLE_QUOTATION_MARK);

        if (arguments.length < ADD_COMMAND_MIN_ARGUMENTS) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }

        // E.g. add "Without date and time"
        if (arguments.length == ADD_COMMAND_MIN_ARGUMENTS) {
            name = arguments[ADD_COMMAND_DESCRIPTION_INDEX].trim();

            try {
                return new AddCommand(name, date, startDate, endDate, time, startTime, endTime, Collections.emptySet());
            } catch (IllegalValueException ive) {
                return new IncorrectCommand(ive.getMessage());
            } catch (ParseException e) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
            }
        }

        name = arguments[ADD_COMMAND_DESCRIPTION_INDEX].trim();

        if (arguments.length > ADD_COMMAND_MIN_ARGUMENTS) {
            additionalArgs = arguments[arguments.length - 1].trim().split(DELIMITER_BLANK_SPACE);
        }

        for (int i = 0; i < additionalArgs.length; i++) {
            if (KEYWORD_FOR_DATE.matcher(additionalArgs[i].toLowerCase()).find()) {
                hasDate = true;
                continue;
            }	        
            else if (KEYWORD_FOR_TIME.matcher(additionalArgs[i].toLowerCase()).find()) {
                hasTime = true;
                continue;
            }
            else if (TAG_FORMAT.matcher(additionalArgs[i]).find()) {
                String[] splitTag = additionalArgs[i].trim().split(DELIMITER_FORWARD_SLASH);
                tags.add(splitTag[ADD_COMMAND_TAG_INDEX]);
                continue;
            } else if (!hasDate && TODAY_OR_TOMORROW.matcher(additionalArgs[i].toLowerCase()).find()) {
                numOfDate++;
                if (numOfDate == ONE) {
                    date = additionalArgs[i].toLowerCase();
                } else if (numOfDate == TWO) {
                    startDate = date;
                    date = null;
                    endDate = additionalArgs[i].toLowerCase();
                }
                continue;
            } else if (!hasTime && TIME_FORMAT.matcher(additionalArgs[i].toLowerCase()).find()) {
                numOfTime++;
                if (numOfTime == ONE) {
                    time = additionalArgs[i].toLowerCase();
                    if (startDate != null & endDate != null) {
                        endTime = time;
                        time = null;
                        startTime = DEFAULT_START_TIME;
                    }
                } else if (numOfTime == TWO) {       
                    startTime = time;      
                    time = null;
                    endTime = additionalArgs[i].toLowerCase();
                }
                continue;
            } else if (!hasDate && !hasTime) {
                validArgument = false;
            }

            if (hasDate) {
                if (DATE_WITH_SLASH_FORMAT.matcher(additionalArgs[i]).find()) {
                    numOfDate++;
                    if (numOfDate == ONE) {
                        date = additionalArgs[i];
                    } else if (numOfDate == TWO) {
                        startDate = date;
                        date = null;
                        endDate = additionalArgs[i];
                    }
                    hasDate = false;
                } else if (TODAY_OR_TOMORROW.matcher(additionalArgs[i].toLowerCase()).find()) {
                    numOfDate++;
                    if (numOfDate == ONE) {
                        date = additionalArgs[i].toLowerCase();
                    } else if (numOfDate == TWO) {
                        startDate = date;
                        date = null;
                        endDate = additionalArgs[i].toLowerCase();
                    }
                    hasDate = false;
                } else if (TIME_FORMAT.matcher(additionalArgs[i].toLowerCase()).find()) {
                    numOfTime++;
                    if (numOfTime == ONE) {
                        time = additionalArgs[i].toLowerCase();
                        if (startDate != null & endDate != null) {
                            endTime = time;
                            time = null;
                            startTime = DEFAULT_START_TIME;
                        }
                    } else if (numOfTime == TWO) {
                        startTime = time;                    
                        time = null;
                        endTime = additionalArgs[i].toLowerCase();       
                    }
                    hasDate = false;
                } else if (DATE.matcher(additionalArgs[i].toLowerCase()).find()) {
                    numOfDate++;
                    if (numOfDate == ONE) {
                        date = additionalArgs[i].toLowerCase();
                        date += FORWARD_SLASH;
                    } else if (numOfDate == TWO) {
                        startDate = date;
                        date = null;
                        endDate = additionalArgs[i].toLowerCase();
                        endDate += FORWARD_SLASH;
                    } 
                } else if (DATE_WITH_SUFFIX.matcher(additionalArgs[i].toLowerCase()).find()) {
                    numOfDate++;
                    if (numOfDate == ONE) {
                        date = additionalArgs[i].toLowerCase().replaceAll(DATE_SUFFIX_STRING, EMPTY_STRING);
                        date += FORWARD_SLASH;
                    } else if (numOfDate == TWO) {
                        startDate = date;
                        date = null;
                        endDate = additionalArgs[i].toLowerCase();
                        endDate += FORWARD_SLASH;
                    } 
                } else if (MONTH_IN_FULL.matcher(additionalArgs[i].toLowerCase()).find()) {     
                    if (numOfDate == ONE) {
                        date += fullMonths.get(additionalArgs[i].toLowerCase());
                    } else if (numOfDate == TWO) {
                        endDate += fullMonths.get(additionalArgs[i].toLowerCase());
                    }
                } else if (MONTH_IN_SHORT.matcher(additionalArgs[i].toLowerCase()).find()) {
                    if (numOfDate == ONE) {
                        date += shortMonths.get(additionalArgs[i].toLowerCase());               
                    } else if (numOfDate == TWO) {
                        endDate += shortMonths.get(additionalArgs[i].toLowerCase());     
                    } 
                } else if (YEAR.matcher(additionalArgs[i].toLowerCase()).find()) {
                    if (numOfDate == ONE) {
                        date += FORWARD_SLASH;
                        date += additionalArgs[i].toLowerCase();
                    } else if (numOfDate == TWO) {
                        endDate += FORWARD_SLASH;
                        endDate += additionalArgs[i].toLowerCase();
                    } 
                    hasDate = false;
                } else {
                    hasDate = false;
                    return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
                }
            }

            if (hasTime) {
                if (TIME_FORMAT.matcher(additionalArgs[i].toLowerCase()).find()) {
                    numOfTime++;
                    if (numOfTime == ONE) {
                        time = additionalArgs[i].toLowerCase();
                        if (startDate != null & endDate != null) {
                            endTime = time;
                            time = null;
                            startTime = DEFAULT_START_TIME;
                        }
                    } else if (numOfTime == TWO) {
                        startTime = time;             
                        time = null;
                        endTime = additionalArgs[i].toLowerCase();
                    }
                } else {
                    return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
                }

                hasTime = false;
            }

            if (!validArgument) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
            }
        }

        if (time != null) {
            time = formatTime(time);
        } else if (startTime != null) {
            startTime = formatTime(startTime);
            endTime = formatTime(endTime);
        }

        if (startDate != null) {
            if (time != null) {
                startTime = time;
                time = null;
                endTime = DEFAULT_END_TIME;
            }
        }

        try {
            return new AddCommand(name, date, startDate, endDate, time, startTime, endTime, tags);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (ParseException e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
    }

    /**
     * Extracts the new task's tags from the add command's tag arguments string.
     * Merges duplicate tag strings.
     */
    private static Set<String> getTagsFromArgs(String tagArguments) throws IllegalValueException {
        // no tags
        if (tagArguments.isEmpty()) {
            return Collections.emptySet();
        }
        // replace first delimiter prefix, then split
        final Collection<String> tagStrings = Arrays.asList(tagArguments.replaceFirst(" t/", "").split(" t/"));
        return new HashSet<>(tagStrings);
    }

    /**
     * Parses arguments in the context of the change data file location command.
     * 
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareChange(String args) {
        String[] argComponents= args.trim().split(" ");
        if(argComponents[CHANGE_LOCATION].equals("location") && argComponents[CHANGE_LOCATION_TO].equals("to")){
            return new ChangeCommand(argComponents[CHANGE_LOCATION_TO_PATH]);
        }
        else{
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ChangeCommand.MESSAGE_USAGE));
        }
    }

    private Command prepareList(String args) {
        String[] argComponents= args.trim().split(DELIMITER_BLANK_SPACE);
        String listArg = argComponents[LIST_ARG];
        if (!isListCommandValid(listArg)) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
        }
        return new ListCommand(listArg);
    }

    private boolean isListCommandValid(String listArg) {
        return listArg.equals(LIST_COMMAND_ARG_COMPLETED) || listArg.equals(LIST_COMMAND_ARG_NOT_SPECIFIED) 
                || listArg.equals(LIST_COMMAND_ARG_ALL_TASKS);
    }

    /**
     * Parses arguments in the context of the delete task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {
        String[] argComponents = args.trim().split(DELIMITER_BLANK_SPACE);
        if (argComponents.length < 2) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        Optional<Integer> index = parseIndex(argComponents[INDEX]);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        return new DeleteCommand(argComponents[TASK_TYPE], index.get());
    }

    /**
     * Parses arguments in the context of the update task command.
     *
     * @param args full command args string
     * @return the prepared command
     * @throws ParseException 
     */
    private Command prepareUpdate(String args) {
        if (args.equals(null))
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));

        String[] argComponents = args.trim().split(DELIMITER_BLANK_SPACE);

        if (argComponents.length < UPDATE_COMMAND_MIN_ARGUMENTS)
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        
        String taskType = argComponents[TASK_TYPE];
        Optional<Integer> index = parseIndex(argComponents[INDEX]);
        String argType = argComponents[ARG_TYPE];
        String arg = "";
        
        int numOfDate = 0;
        int numOfTime = 0;
           
        if (argComponents.length > UPDATE_COMMAND_MIN_ARGUMENTS) {
            for (int i = ARG; i < argComponents.length; i++) {            
                if (argType.toUpperCase().compareToIgnoreCase(TASK_ARG_DESCRIPTION) == 0) {
                    if (argComponents[i].toUpperCase().compareToIgnoreCase(NONE) == 0)
                        return new IncorrectCommand(MESSAGE_INVALID_COMMAND_FORMAT + UpdateCommand.MESSAGE_USAGE); 
                    
                    arg += argComponents[i] + DELIMITER_BLANK_SPACE;
                } else if (argType.toUpperCase().compareToIgnoreCase(TASK_ARG_DATE) == 0) {
                    if (DATE_WITH_SLASH_FORMAT.matcher(argComponents[i]).find()) {
                        numOfDate++;
                        if (numOfDate == ONE)
                            arg = argComponents[i];
                        else if (numOfDate == TWO)
                            arg += DELIMITER_BLANK_SPACE + argComponents[i];
                    } else if (TODAY_OR_TOMORROW.matcher(argComponents[i].toLowerCase()).find()) {
                        numOfDate++;
                        if (numOfDate == ONE)
                            arg = argComponents[i];
                        else if (numOfDate == TWO)
                            arg += DELIMITER_BLANK_SPACE + argComponents[i];
                    } else if (argComponents[i].toUpperCase().compareToIgnoreCase(NONE) == 0)
                        arg = null;
                } else if (argType.toUpperCase().compareToIgnoreCase(TASK_ARG_TIME) == 0) {
                    if (TIME_FORMAT.matcher(argComponents[i]).find()) {
                        numOfTime++;
                        if (numOfTime == ONE)
                            arg = argComponents[i];
                        else if (numOfTime == TWO)
                            arg += DELIMITER_BLANK_SPACE + argComponents[i];
                    } else if (argComponents[i].toUpperCase().compareToIgnoreCase(NONE) == 0)
                        arg = null;
                } else if (argType.toUpperCase().compareToIgnoreCase(TASK_ARG_TAG) == 0) {
                    if (argComponents[i].toUpperCase().compareToIgnoreCase(NONE) == 0)
                        arg = null;
                    else
                        arg += argComponents[i] + DELIMITER_BLANK_SPACE;
                }
            }
            
            try {
                return new UpdateCommand(taskType, index.get(), argType, arg);
            } catch (IllegalValueException ive) {
                return new IncorrectCommand(ive.getMessage());
            } catch (ParseException pe) {
                return new IncorrectCommand(pe.getMessage());
            } catch (NoSuchElementException nsee) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
            }
        }
        
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }
        
        if (!isValidUpdateCommandFormat(taskType, index.get(), argType)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }

        try {
            return new UpdateCommand(taskType, index.get(), argType, arg);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (ParseException pe) {
            return new IncorrectCommand(pe.getMessage());
        }
    }

    /**
     * Parses arguments in the context of the markDone task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareMarkDone(String args) {
        String[] argComponents = args.trim().split(" ");
        Optional<Integer> index = parseIndex(argComponents[INDEX]);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_USAGE));
        }
        return new MarkDoneCommand(argComponents[TASK_TYPE], index.get());
    }

    /**
     * Parses arguments in the context of the markUndone task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareMarkUndone(String args) {
        String[] argComponents = args.trim().split(DELIMITER_BLANK_SPACE);
        Optional<Integer> index = parseIndex(argComponents[INDEX]);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkUndoneCommand.MESSAGE_USAGE));
        }
        return new MarkUndoneCommand(argComponents[TASK_TYPE], index.get());
    }

    /**
     * Checks that the command format is valid
     * @param type is todo/schedule, index is the index of item on the list, argType is description/tag/date/time
     */
    private boolean isValidUpdateCommandFormat(String type, int index, String argType) {
        if (!(type.compareToIgnoreCase(TASK_TYPE_FLOATING) == 0 || type.compareToIgnoreCase(TASK_TYPE_NON_FLOATING) == 0)) {
            return false;
        }
        if (index < 0) {
            return false;
        }
        if (!(argType.compareToIgnoreCase(TASK_ARG_DESCRIPTION) == 0 || argType.compareToIgnoreCase(TASK_ARG_TAG) == 0 
                || argType.compareToIgnoreCase(TASK_ARG_DATE) == 0 || argType.compareToIgnoreCase(TASK_ARG_TIME) == 0)) {
            return false;
        }
        return true;
    }

    /**
     * Parses arguments in the context of the select task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareSelect(String args) {
        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
        }

        return new SelectCommand(index.get());
    }

    /**
     * Returns the specified index in the {@code command} IF a positive unsigned integer is given as the index.
     *   Returns an {@code Optional.empty()} otherwise.
     */
    private Optional<Integer> parseIndex(String command) {
        final Matcher matcher = TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if(!StringUtil.isUnsignedInteger(index)){
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }

    /**
     * Parses arguments in the context of the find task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareFind(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }
}
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public synchronized void updateTask(ReadOnlyTask old, Task toUpdate) throws TaskNotFoundException, DuplicateTaskException {
        whatNow.updateTask(old, toUpdate);
        indicateUpdateTask(toUpdate);
        indicateWhatNowChanged();
    }
```
###### \java\seedu\whatnow\model\ReadOnlyWhatNow.java
``` java

import java.util.List;

import seedu.whatnow.model.tag.Tag;
import seedu.whatnow.model.tag.UniqueTagList;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.UniqueTaskList;

/**
 * Unmodifiable view of WhatNow
 */
public interface ReadOnlyWhatNow {

    UniqueTagList getUniqueTagList();

    UniqueTaskList getUniqueTaskList();

    /**
     * Returns an unmodifiable view of tasks list
     */
    List<ReadOnlyTask> getTaskList();

    /**
     * Returns an unmodifiable view of tags list
     */
    List<Tag> getTagList();

}
```
###### \java\seedu\whatnow\model\task\ReadOnlyTask.java
``` java
    /**
     * Formats the task as text, showing all details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName());
        if (getTaskDate() != null)
            builder.append(" " + getTaskDate());
        		
        if (getStartDate() != null)
            builder.append(" " + getStartDate());
        
        if (getEndDate() != null)
            builder.append(" " + getEndDate());
        
        if (getTaskTime() != null)
            builder.append(" " + getTaskTime());
        
        if (getStartTime() != null)
            builder.append(" " + getStartTime());
        
        if (getEndTime() != null)
            builder.append(" " + getEndTime());
        
        if (getStatus() != null)
            builder.append(" " + getStatus());
        
        builder.append(" Tags: ");
        getTags().forEach(builder::append);
        return builder.toString();
    }

```
###### \java\seedu\whatnow\model\task\Task.java
``` java
    /**
     * Every field must be present and not null.
     */
    public Task(Name name, String taskDate, String startDate, String endDate, String taskTime, String startTime, String endTime, UniqueTagList tags, String status, String taskType) {
        assert !CollectionUtil.isAnyNull(name, tags);
        this.name = name;
        this.tags = new UniqueTagList(tags);
        this.status = status;
        this.taskType = FLOATING;
             
        if (taskDate != null) {
            this.taskDate = taskDate;
            this.taskType = NOT_FLOATING;
        }
        
        if (startDate != null) {
            this.startDate = startDate;
            this.taskType = NOT_FLOATING;
        }
            
        if (endDate != null) {
            this.endDate = endDate;
            this.taskType = NOT_FLOATING;
        }
            
        if (taskTime != null) {
            this.taskTime = taskTime;
            this.taskType = NOT_FLOATING;
        }
            
        if (startTime != null) {
            this.startTime = startTime;
            this.taskType = NOT_FLOATING;
        }
            
        if (endTime != null) {
            this.endTime = endTime;
            this.taskType = NOT_FLOATING;
        }
        
        if (taskType != null) {
            this.taskType = taskType;
        }
    }
    
    /**
     * Copy constructor.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getTaskDate(), source.getStartDate(), source.getEndDate(), source.getTaskTime(), source.getStartTime(), source.getEndTime(), source.getTags(), source.getStatus(), source.getTaskType());
    }
   
    @Override
    public Name getName() {
        return name;
    }

    @Override
    public String getTaskDate() {
        return taskDate;
    }
    
    @Override
    public String getStartDate() {
        return startDate;
    }
    
    @Override
    public String getEndDate() {
        return endDate;
    }
    
    @Override
    public String getTaskTime() {
        return taskTime;
    }

    @Override
    public String getStartTime() {
        return startTime;
    }

    @Override
    public String getEndTime() {
        return endTime;
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }
    
    @Override
    public String getStatus() {
        return status;
    }
    
    @Override
    public String getTaskType() {
        return taskType;
    }
    
    public void setName(Name name) {
        this.name = name;
    }
    
    public void setTaskDate(String date) {
        this.taskDate = date;
    }
    
    public void setStartDate(String startDate) {
        this.startDate = startDate;
    }
    
    public void setEndDate(String endDate) {
        this.endDate = endDate;
    }
    
    public void setTaskTime(String time) {
        this.taskTime = time;
    }

    public void setStartTime(String startTime) {
        this.startTime = startTime;
    }

    public void setEndTime(String endTime) {
        this.endTime = endTime;
    }
    
    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }
    
    public void setStatus(String status) {
        this.status = status;
    }
    
    public void setTaskType(String taskType) {
        this.taskType = taskType;
    }

```
###### \java\seedu\whatnow\model\task\UniqueTaskList.java
``` java
    /**
     * Updates the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean update(ReadOnlyTask old, Task toUpdate) throws TaskNotFoundException, DuplicateTaskException {
        assert old != null;
        final boolean taskFoundAndUpdated = internalList.contains(old);
        if (!taskFoundAndUpdated) {
            throw new TaskNotFoundException();
        }
        if (internalList.contains(toUpdate)) {
            throw new DuplicateTaskException();
        }
        internalList.set(internalList.indexOf(old), toUpdate);
        return taskFoundAndUpdated;
    }
    
```
###### \java\seedu\whatnow\storage\XmlAdaptedTask.java
``` java
import javax.xml.bind.annotation.XmlElement;

import seedu.whatnow.commons.exceptions.IllegalValueException;
import seedu.whatnow.model.tag.Tag;
import seedu.whatnow.model.tag.UniqueTagList;
import seedu.whatnow.model.task.*;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;

/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    @XmlElement(required = true)
    private String name;
    
    @XmlElement(required = true)
    private String taskDate;
    
    @XmlElement
    private String startDate;
    
    @XmlElement
    private String endDate;
    
    @XmlElement
    private String taskTime;
    
    @XmlElement
    private String startTime;
    
    @XmlElement
    private String endTime;
    
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();
    
    @XmlElement
    private String status;
    
    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName().fullName;
        tagged = new ArrayList<>();
        if(source.getTaskDate() != null)
        	taskDate = source.getTaskDate();
        if (source.getStartDate() != null)
            startDate = source.getStartDate();
        if (source.getEndDate() != null)
            endDate = source.getEndDate();
        if (source.getTaskTime() != null)
            taskTime = source.getTaskTime();
        if (source.getStartTime() != null)
            startTime = source.getStartTime();
        if (source.getEndTime() != null)
            endTime = source.getEndTime();
        status = source.getStatus();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     * @throws ParseException 
     */
    public Task toModelType() throws IllegalValueException, ParseException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        final Name name = new Name(this.name);
        final UniqueTagList tags = new UniqueTagList(taskTags);
        return new Task(name, taskDate, startDate, endDate, taskTime, startTime, endTime, tags, status, null);
    }
}
```
###### \java\seedu\whatnow\storage\XmlWhatNowStorage.java
``` java
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Optional;
import java.util.logging.Logger;

import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.exceptions.DataConversionException;
import seedu.whatnow.commons.util.FileUtil;
import seedu.whatnow.model.ReadOnlyWhatNow;

/**
 * A class to access WhatNow data stored as an xml file on the hard disk.
 */
public class XmlWhatNowStorage implements WhatNowStorage {

    private static final Logger logger = LogsCenter.getLogger(XmlWhatNowStorage.class);

    private String filePath;

    public XmlWhatNowStorage(String filePath){
        this.filePath = filePath;
    }

    public String getWhatNowFilePath(){
        return filePath;
    }
    
    /**
     * Sets the file path of the WhatNow data
     * @param filePath new location of the WhatNow data file.
     */
    public void setWhatNowFilePath(String filePath){
        this.filePath = filePath;
    }
    
    /**
     * Similar to {@link #readWhatNow()}
     * @param filePath location of the data. Cannot be null
     * @throws DataConversionException if the file is not in the correct format.
     */
    public Optional<ReadOnlyWhatNow> readWhatNow(String filePath) throws DataConversionException, FileNotFoundException {
        assert filePath != null;

        File whatNowFile = new File(filePath);

        if (!whatNowFile.exists()) {
            logger.info("WhatNow file "  + whatNowFile + " not found");
            return Optional.empty();
        }

        ReadOnlyWhatNow whatNowOptional = XmlFileStorage.loadDataFromSaveFile(new File(filePath));

        return Optional.of(whatNowOptional);
    }

    /**
     * Similar to {@link #saveWhatNow(ReadOnlyWhatNow)}
     * @param filePath location of the data. Cannot be null
     */
    public void saveWhatNow(ReadOnlyWhatNow whatNow, String filePath) throws IOException {
        assert whatNow != null;
        assert filePath != null;

        File file = new File(filePath);
        FileUtil.createIfMissing(file);
        XmlFileStorage.saveDataToFile(file, new XmlSerializableWhatNow(whatNow));
    }

    @Override
    public Optional<ReadOnlyWhatNow> readWhatNow() throws DataConversionException, IOException {
        return readWhatNow(filePath);
    }

    @Override
    public void saveWhatNow(ReadOnlyWhatNow whatNow) throws IOException {
        saveWhatNow(whatNow, filePath);
    }
}
```
