# A0139772U
###### \java\seedu\whatnow\commons\core\LogsCenter.java
``` java
import java.io.IOException;
import java.util.logging.*;

import seedu.whatnow.commons.events.BaseEvent;

/**
 * Configures and manages loggers and handlers, including their logging level
 * Named {@link Logger}s can be obtained from this class<br>
 * These loggers have been configured to output messages to the console and a
 * {@code .log} file by default, at the {@code INFO} level. A new {@code .log}
 * file with a new numbering will be created after the log file reaches 5MB big,
 * up to a maximum of 5 files.<br>
 */
public class LogsCenter {
    private static final int MAX_FILE_COUNT = 5;
    private static final int MAX_FILE_SIZE_IN_BYTES = (int) (Math.pow(2, 20) * 5); // 5MB
    private static final String LOG_FILE = "whatnow.log";
    private static Level currentLogLevel = Level.INFO;
    private static final Logger logger = LogsCenter.getLogger(LogsCenter.class);
    private static FileHandler fileHandler;
    private static ConsoleHandler consoleHandler;

    /**
     * Initializes with a custom log level (specified in the {@code config}
     * object) Loggers obtained *AFTER* this initialization will have their
     * logging level changed<br>
     * Logging levels for existing loggers will only be updated if the logger
     * with the same name is requested again from the LogsCenter.
     */
    public static void init(Config config) {
        currentLogLevel = config.getLogLevel();
        logger.info("currentLogLevel: " + currentLogLevel);
    }

    /**
     * Creates a logger with the given name the given name.
     */
    public static Logger getLogger(String name) {
        Logger logger = Logger.getLogger(name);
        logger.setUseParentHandlers(false);

        removeHandlers(logger);
        addConsoleHandler(logger);
        addFileHandler(logger);

        return Logger.getLogger(name);
    }

    private static void addConsoleHandler(Logger logger) {
        if (consoleHandler == null)
            consoleHandler = createConsoleHandler();
        logger.addHandler(consoleHandler);
    }

    private static void removeHandlers(Logger logger) {
        Handler[] handlers = logger.getHandlers();
        for (Handler handler : handlers) {
            logger.removeHandler(handler);
        }
    }

    private static void addFileHandler(Logger logger) {
        try {
            if (fileHandler == null)
                fileHandler = createFileHandler();
            logger.addHandler(fileHandler);
        } catch (IOException e) {
            logger.warning("Error adding file handler for logger.");
        }
    }

    private static FileHandler createFileHandler() throws IOException {
        FileHandler fileHandler = new FileHandler(LOG_FILE, MAX_FILE_SIZE_IN_BYTES, MAX_FILE_COUNT, true);
        fileHandler.setFormatter(new SimpleFormatter());
        fileHandler.setLevel(currentLogLevel);
        return fileHandler;
    }

    private static ConsoleHandler createConsoleHandler() {
        ConsoleHandler consoleHandler = new ConsoleHandler();
        consoleHandler.setLevel(currentLogLevel);
        return consoleHandler;
    }

    /**
     * Creates a Logger for the given class name.
     */
    public static <T> Logger getLogger(Class<T> clazz) {
        if (clazz == null)
            return Logger.getLogger("");
        return getLogger(clazz.getSimpleName());
    }

    /**
     * Decorates the given string to create a log message suitable for logging
     * event handling methods.
     */
    public static String getEventHandlingLogMessage(BaseEvent e, String message) {
        return "---[Event handled][" + e + "]" + message;
    }

    /**
     * @see #getEventHandlingLogMessage(BaseEvent, String)
     */
    public static String getEventHandlingLogMessage(BaseEvent e) {
        return getEventHandlingLogMessage(e, "");
    }
}
```
###### \java\seedu\whatnow\commons\core\UnmodifiableObservableList.java
``` java
package seedu.whatnow.commons.core;

import javafx.beans.InvalidationListener;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.transformation.FilteredList;
import javafx.collections.transformation.SortedList;

import java.text.Collator;
import java.util.*;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;

/**
 * Unmodifiable view of an observable list
 */
public class UnmodifiableObservableList<E> implements ObservableList<E> {

    public static final String MUTATION_OP_EXCEPTION_MESSAGE = "Attempted to modify an unmodifiable view";

    private final ObservableList<? extends E> backingList;

    public UnmodifiableObservableList(ObservableList<? extends E> backingList) {
        if (backingList == null) {
            throw new NullPointerException();
        }
        this.backingList = backingList;
    }

    @Override
    public final void addListener(ListChangeListener<? super E> listener) {
        backingList.addListener(listener);
    }

    @Override
    public final void removeListener(ListChangeListener<? super E> listener) {
        backingList.removeListener(listener);
    }

    @Override
    public final void addListener(InvalidationListener listener) {
        backingList.addListener(listener);
    }

    @Override
    public final void removeListener(InvalidationListener listener) {
        backingList.removeListener(listener);
    }

    @Override
    public final boolean addAll(Object... elements) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final boolean setAll(Object... elements) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final boolean setAll(Collection<? extends E> col) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final boolean removeAll(Object... elements) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final boolean retainAll(Object... elements) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final void remove(int from, int to) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final FilteredList<E> filtered(Predicate<E> predicate) {
        return new FilteredList<>(this, predicate);
    }

    @Override
    public final SortedList<E> sorted(Comparator<E> comparator) {
        return new SortedList<>(this, comparator);
    }

    @SuppressWarnings("unchecked")
    @Override
    public final SortedList<E> sorted() {
        return sorted(Comparator.nullsFirst((o1, o2) -> {
            if (o1 instanceof Comparable) {
                return ((Comparable) o1).compareTo(o2);
            }
            return Collator.getInstance().compare(o1.toString(), o2.toString());
        }));
    }

    @Override
    public final int size() {
        return backingList.size();
    }

    @Override
    public final boolean isEmpty() {
        return backingList.isEmpty();
    }

    @Override
    public final boolean contains(Object o) {
        return backingList.contains(o);
    }

    @Override
    public final Iterator<E> iterator() {
        return new Iterator<E>() {
            private final Iterator<? extends E> i = backingList.iterator();

            public final boolean hasNext() {
                return i.hasNext();
            }

            public final E next() {
                return i.next();
            }

            public final void remove() {
                throw new UnsupportedOperationException();
            }

            @Override
            public final void forEachRemaining(Consumer<? super E> action) {
                // Use backing collection version
                i.forEachRemaining(action);
            }
        };
    }

    @Override
    public final Object[] toArray() {
        return backingList.toArray();
    }

    @Override
    public final <T> T[] toArray(T[] a) {
        return backingList.toArray(a);
    }

    @Override
    public final boolean add(E o) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final boolean remove(Object o) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final boolean containsAll(Collection<?> c) {
        return backingList.containsAll(c);
    }

    @Override
    public final boolean addAll(Collection<? extends E> c) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final boolean addAll(int index, Collection<? extends E> c) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final boolean removeAll(Collection<?> c) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final boolean retainAll(Collection<?> c) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final void replaceAll(UnaryOperator<E> operator) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final void sort(Comparator<? super E> c) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final void clear() {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final boolean equals(Object o) {
        return o == this || backingList.equals(o);
    }

    @Override
    public final int hashCode() {
        return backingList.hashCode();
    }

    @Override
    public final E get(int index) {
        return backingList.get(index);
    }

    @SuppressWarnings("unchecked")
    @Override
    public final Object set(int index, Object element) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final void add(int index, Object element) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final E remove(int index) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final int indexOf(Object o) {
        return backingList.indexOf(o);
    }

    @Override
    public final int lastIndexOf(Object o) {
        return backingList.lastIndexOf(o);
    }

    @Override
    public final ListIterator<E> listIterator() {
        return listIterator(0);
    }

    @Override
    public final ListIterator<E> listIterator(int index) {
        return new ListIterator<E>() {
            private final ListIterator<? extends E> i = backingList.listIterator(index);

            public final boolean hasNext() {
                return i.hasNext();
            }

            public final E next() {
                return i.next();
            }

            public final boolean hasPrevious() {
                return i.hasPrevious();
            }

            public final E previous() {
                return i.previous();
            }

            public final int nextIndex() {
                return i.nextIndex();
            }

            public final int previousIndex() {
                return i.previousIndex();
            }

            public final void remove() {
                throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
            }

            public final void set(E e) {
                throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
            }

            public final void add(E e) {
                throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
            }

            @Override
            public final void forEachRemaining(Consumer<? super E> action) {
                i.forEachRemaining(action);
            }
        };
    }

    @Override
    public final List<E> subList(int fromIndex, int toIndex) {
        return Collections.unmodifiableList(backingList.subList(fromIndex, toIndex));
    }

    @Override
    public final boolean removeIf(Predicate<? super E> filter) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @SuppressWarnings("unchecked")
    @Override
    public final Stream<E> stream() {
        return (Stream<E>) backingList.stream();
    }

    @Override
    public final void forEach(Consumer<? super E> action) {
        backingList.forEach(action);
    }

}
```
###### \java\seedu\whatnow\commons\util\FxViewUtil.java
``` java
package seedu.whatnow.commons.util;

import javafx.scene.Node;
import javafx.scene.layout.AnchorPane;

/**
 * Contains utility methods for JavaFX views
 */
public class FxViewUtil {

    public static void applyAnchorBoundaryParameters(Node node, double left, double right, double top, double bottom) {
        AnchorPane.setBottomAnchor(node, bottom);
        AnchorPane.setLeftAnchor(node, left);
        AnchorPane.setRightAnchor(node, right);
        AnchorPane.setTopAnchor(node, top);
    }
}
```
###### \java\seedu\whatnow\logic\commands\AddCommand.java
``` java
package seedu.whatnow.logic.commands;

import java.text.ParseException;
import java.util.HashSet;
import java.util.Set;

import seedu.whatnow.commons.exceptions.IllegalValueException;
import seedu.whatnow.model.tag.Tag;
import seedu.whatnow.model.tag.UniqueTagList;
import seedu.whatnow.model.task.*;
import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;

/**
 * Adds a task to WhatNow.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

	public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to WhatNow. \n"
			+ "Parameters: \"TASK_NAME\" [t/TAG]...\n"
	        + "Parameters: \"TASK_NAME\" [on/by/from] [today/tomorrow/DATE] [to] [today/tomorrow/DATE] [every] [day/week/month/year] [till/until] [DATE] [t/TAG]...\n"
			+ "Parameters: \"TASK_NAME\" [by/at/from] [TIME] [till/to] [TIME] [t/TAG]...\n"
			+ "Example: \n"
			+ COMMAND_WORD + " \"Buy groceries\" on 23rd Feb 2017 t/highPriority\n"
			+ COMMAND_WORD + " \"Buy dinner\" at 6pm t/highPriority\n"
			+ COMMAND_WORD + " \"Lesson\" on 24/2/2017 from 8.30am to 4:30pm every week till 25/4/2017 t/lowPriority\n"
			+ COMMAND_WORD + " \"Submit homework\" by tomorrow 12pm t/lowPriority\n";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in WhatNow.";
    public static final String MESSAGE_RECURRING_NO_END_DATE = "Please specify an end date for the recurring task.";
    private static final String STATUS_INCOMPLETE = "incomplete";
    
	private Task toAdd;
	
```
###### \java\seedu\whatnow\logic\commands\DeleteCommand.java
``` java
package seedu.whatnow.logic.commands;

import java.util.logging.Logger;
import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.core.Messages;
import seedu.whatnow.commons.core.UnmodifiableObservableList;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Deletes a task identified using it's last displayed index from WhatNow.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "delete";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n" + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %1$s";

    private static final String TASK_TYPE_FLOATING = "todo";
    private static final Logger logger = LogsCenter.getLogger(DeleteCommand.class);

    private final int targetIndex;
    private final String taskType;

    public DeleteCommand(String taskType, int targetIndex) {
        this.targetIndex = targetIndex;
        this.taskType = taskType;
    }

    /**
     * Execute DeleteCommand to delete a task at targetIndex
     */
    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList;

        if (taskType.equals(TASK_TYPE_FLOATING)) {
            lastShownList = model.getCurrentFilteredTaskList();
        } else {
            lastShownList = model.getCurrentFilteredScheduleList();
        }
        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);

        assert model != null;
        try {
            int indexRemoved = model.deleteTask(taskToDelete);
            model.getUndoStack().push(COMMAND_WORD);
            model.getDeletedStackOfTasks().push(taskToDelete);
            model.getDeletedStackOfTasksIndex().push(indexRemoved);
            model.clearRedoAll();
        } catch (TaskNotFoundException tnfe) {
            logger.warning("Task not found: " + taskToDelete + "\n" + tnfe.getMessage());
        }
        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));
    }
}
```
###### \java\seedu\whatnow\logic\commands\FindCommand.java
``` java
package seedu.whatnow.logic.commands;

import java.util.Set;

/**
 * Finds and lists all tasks in WhatNow whose name contains any of the argument
 * keywords. Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks with"
            + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n" + "Example: " + COMMAND_WORD + " Online quiz";

    private final Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    /**
     * Executes the FindCommand to get task that matches the keywords
     */
    @Override
    public CommandResult execute() {
        model.clearRedoAll();
        return new CommandResult(getMessageForTaskListShownSummary(
                model.getFilteredTaskList(keywords).size() + model.getFilteredScheduleList(keywords).size()));
    }
}
```
###### \java\seedu\whatnow\logic\commands\FreeTimeCommand.java
``` java
package seedu.whatnow.logic.commands;

import java.util.ArrayList;
import seedu.whatnow.model.freetime.Period;

/**
 * Fetch and display the free periods of a date
 */
public class FreeTimeCommand extends Command {

    public static final String COMMAND_WORD = "freetime";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds the freetime of a particular date\n"
            + "Parameters: date\n" + "Example: [" + COMMAND_WORD + " 12/12/2016] or [" + COMMAND_WORD + " today or ["
            + COMMAND_WORD + " tuesday]\n";

    public static final String MESSAGE_SUCCESS = "Freetime found for: ";

    public static final String MESSAGE_NO_FREE_TIME_FOUND = "No freetime was found for: ";

    public final String date;

    public FreeTimeCommand(String date) {
        this.date = date;
    }
    
    /**
     * Execute the FreeTimeCommand to display the period of free time of a date
     */
    @Override
    public CommandResult execute() {

        ArrayList<Period> freePeriods = model.getFreeTime(date.trim()).getList();
        if (freePeriods.size() == 0) {
            String dateWithoutTrail = date.trim();
            return new CommandResult(MESSAGE_NO_FREE_TIME_FOUND + dateWithoutTrail);
        }
        return new CommandResult(MESSAGE_SUCCESS + date.trim() + "\n" + freePeriods.toString());
    }

}
```
###### \java\seedu\whatnow\logic\commands\ListCommand.java
``` java
package seedu.whatnow.logic.commands;

/**
 * Lists all tasks in WhatNow to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_SUCCESS = "Listed all tasks";
    
    public static final String COMPLETE_MESSAGE_SUCCESS = "Listed all completed tasks";

    public static final String INCOMPLETE_MESSAGE_SUCCESS = "Listed all incomplete tasks";
    
    public static final String TASK_STATUS_DONE = "done";

    public static final String TASK_STATUS_COMPLETED = "completed";

    public static final String TASK_STATUS_ALL = "all";

    public static final String TASK_STATUS_INCOMPLETE = "incomplete";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": the task specified\n" + "Parameters: done\n"
            + "Examples: " + COMMAND_WORD + " done or " + COMMAND_WORD + " all or " + COMMAND_WORD;

    public String type;

    public ListCommand(String type) {
        this.type = type;
    }

    private void mapInputToCorrectArgumentForExecution() {
        if (type.equals(TASK_STATUS_DONE)) {
            type = TASK_STATUS_COMPLETED;
        } else if (type.equals(TASK_STATUS_ALL)) {
            type = TASK_STATUS_ALL;
        } else {
            type = TASK_STATUS_INCOMPLETE;
        }
    }

    /**
     * Executes the ListCommand to display task based on task status(incomplete or complete or both) 
     */
    @Override
    public CommandResult execute() {
        mapInputToCorrectArgumentForExecution();
        model.updateFilteredScheduleListToShowAllOverdue();
        if (type.equals(TASK_STATUS_ALL)) {
            model.updateFilteredListToShowAll();
            model.updateFilteredScheduleListToShowAll();
            model.getUndoStack().push(COMMAND_WORD);
            model.getStackOfListTypes().push(TASK_STATUS_ALL);
            return new CommandResult(MESSAGE_SUCCESS);
        } else if (type.equals(TASK_STATUS_INCOMPLETE)) {
            model.updateFilteredListToShowAllIncomplete();
            model.updateFilteredScheduleListToShowAllIncomplete();
            model.getUndoStack().push(COMMAND_WORD);
            model.getStackOfListTypes().push(TASK_STATUS_INCOMPLETE);
            return new CommandResult(INCOMPLETE_MESSAGE_SUCCESS);
        } else {
            model.updateFilteredListToShowAllCompleted();
            model.updateFilteredScheduleListToShowAllCompleted();
            model.getUndoStack().push(COMMAND_WORD);
            model.getStackOfListTypes().push(TASK_STATUS_COMPLETED);
            return new CommandResult(COMPLETE_MESSAGE_SUCCESS);
        }
    }
}
```
###### \java\seedu\whatnow\logic\commands\MarkDoneCommand.java
``` java
package seedu.whatnow.logic.commands;

import static seedu.whatnow.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import seedu.whatnow.commons.core.Messages;
import seedu.whatnow.commons.core.UnmodifiableObservableList;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Marks a task identified using it's last displayed index from WhatNow as
 * completed.
 */
public class MarkDoneCommand extends Command {

    public static final String COMMAND_WORD = "done";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Mark the task identified by the index number used in the last task listing as completed.\n"
            + "Parameters: TODO/SCHEDULE INDEX (must be a positive integer)\n" + "Example: " + COMMAND_WORD
            + " todo 1\n" + "Example: " + COMMAND_WORD + " schedule 1";

    public static final String MESSAGE_MARK_TASK_SUCCESS = "Task marked as completed: %1$s";
    public static final String MESSAGE_MARK_TASK_FAIL = "Unable to mark task as complete";
    public static final String MESSAGE_MARK_INVALID_FORMAT = "Invalid format for done command";
    private static final String TASK_TYPE_FLOATING = "todo";
    private static final String TASK_TYPE_SCHEDULE = "schedule";
    public static final String MESSAGE_MISSING_INDEX = "Please specify index";
    public static final String MESSAGE_MISSING_TASKTYPE_AND_INDEX = "Please specify taskType and index";
    public final String taskType;
    public final int targetIndex;

    public MarkDoneCommand(String taskType, int targetIndex) {
        this.taskType = taskType;
        this.targetIndex = targetIndex;
    }

    /**
     * Executes the MarkDoneCommand to mark a task at targetIndex as completed
     */
    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList;
        if (taskType.equals(TASK_TYPE_FLOATING)) {
            model.updateFilteredListToShowAllIncomplete();
            lastShownList = model.getCurrentFilteredTaskList();
        } else if (taskType.equals(TASK_TYPE_SCHEDULE)) {
            model.updateFilteredScheduleListToShowAllIncomplete();
            lastShownList = model.getCurrentFilteredScheduleList();
        } else {
            return new CommandResult(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_USAGE));
        }
        if (lastShownList.size() < targetIndex || targetIndex <0 ) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToMark = lastShownList.get(targetIndex - 1);

        try {
            model.markTask(taskToMark);
            model.getUndoStack().push(COMMAND_WORD);
            model.getStackOfMarkDoneTask().push(taskToMark);
            model.clearRedoAll();
        } catch (TaskNotFoundException tnfe) {
            return new CommandResult(String.format(MESSAGE_MARK_TASK_FAIL));
        }

        return new CommandResult(String.format(MESSAGE_MARK_TASK_SUCCESS, taskToMark));
    }
}
```
###### \java\seedu\whatnow\logic\commands\UpdateCommand.java
``` java
    /**
     * Executes the UpdateCommand to replace the task at targetIndex with updated information
     */
    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList;

        if (taskType.equals(TASK_TYPE_TODO) || taskType.equalsIgnoreCase(TASK_TYPE_FLOATING)) {
            lastShownList = model.getCurrentFilteredTaskList();
        } else {
            lastShownList = model.getCurrentFilteredScheduleList();
        }

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToUpdate = lastShownList.get(targetIndex - ONE);
        updateTheCorrectField(taskToUpdate);

        try {
            model.updateTask(taskToUpdate, toUpdate);
            model.getOldTask().push(taskToUpdate);
            model.getCurrentTask().push(toUpdate);
            model.getUndoStack().push(COMMAND_WORD);
            model.clearRedoAll();
        } catch (TaskNotFoundException tnfe) {
            logger.warning("TaskNotFoundException at UpdateCommand: \n" + tnfe.getMessage());
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }
        return new CommandResult(
                String.format(MESSAGE_UPDATE_TASK_SUCCESS, "\nFrom: " + taskToUpdate + " \nTo: " + toUpdate));
    }
}
```
###### \java\seedu\whatnow\logic\Logic.java
``` java
package seedu.whatnow.logic;

import java.text.ParseException;

import javafx.collections.ObservableList;
import seedu.whatnow.logic.commands.CommandResult;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * API of the Logic component
 */
public interface Logic {
    /**
     * Executes the command and returns the result.
     * 
     * @param commandText
     *            The command as entered by the user.
     * @return the result of the command execution.
     * @throws ParseException
     * @throws TaskNotFoundException
     * @throws DuplicateTaskException
     */
    CommandResult execute(String commandText) throws ParseException, DuplicateTaskException, TaskNotFoundException;

    /** Returns the filtered list of tasks */
    ObservableList<ReadOnlyTask> getFilteredTaskList();

    /** Returns the filtered list of schedule */
    ObservableList<ReadOnlyTask> getFilteredScheduleList();
    
    ObservableList<ReadOnlyTask> getOverdueScheduleList();

    ObservableList<ReadOnlyTask> getPinnedItems(String type, String keyword);

}
```
###### \java\seedu\whatnow\logic\LogicManager.java
``` java
package seedu.whatnow.logic;

import javafx.collections.ObservableList;
import seedu.whatnow.commons.core.ComponentManager;
import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.logic.commands.Command;
import seedu.whatnow.logic.commands.CommandResult;
import seedu.whatnow.logic.parser.Parser;
import seedu.whatnow.model.Model;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;
import seedu.whatnow.storage.Storage;

import java.text.ParseException;
import java.util.logging.Logger;

/**
 * The main LogicManager of the app.
 */
public class LogicManager extends ComponentManager implements Logic {
    private final Logger logger = LogsCenter.getLogger(LogicManager.class);

    private final Model model;
    private final Parser parser;

    public LogicManager(Model model, Storage storage) {
        this.model = model;
        this.parser = new Parser();
    }

    @Override
    public CommandResult execute(String commandText)
            throws ParseException, DuplicateTaskException, TaskNotFoundException {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        Command command = parser.parseCommand(commandText);
        command.setData(model);
        return command.execute();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return model.getFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredScheduleList() {
        return model.getFilteredScheduleList();
    }
    
    @Override
    public ObservableList<ReadOnlyTask> getOverdueScheduleList() {
        return model.getOverdueScheduleList();
    }
 
    @Override
    public ObservableList<ReadOnlyTask> getPinnedItems(String type, String keyword) {
        return model.getPinnedItems(type, keyword);
    }
}
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
package seedu.whatnow.logic.parser;

import static seedu.whatnow.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.whatnow.commons.core.Messages.MESSAGE_UNKNOWN_COMMAND;
import java.text.ParseException;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import seedu.whatnow.commons.exceptions.IllegalValueException;
import seedu.whatnow.commons.util.StringUtil;
import seedu.whatnow.logic.commands.*;
import seedu.whatnow.model.task.Name;
import seedu.whatnow.model.task.Task;
import seedu.whatnow.model.task.TaskDate;

/**
 * Parses user input.
 */
public class Parser {
    /**
     * Used for initial separation of command word and args.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    private static final Pattern TASK_INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>.+)");

    /**
     * One or more keywords separated by whitespace
     */
    private static final Pattern KEYWORDS_ARGS_FORMAT = Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)");

```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    /**
     * Parses user input into command for execution.
     *
     * @param userInput
     *            full user input string
     * @return the command based on the user input
     * @throws ParseException
     * @throws IllegalValueException 
     */
    public Command parseCommand(String userInput) throws ParseException {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }
        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");

        switch (commandWord) {
        case AddCommand.COMMAND_WORD:
            return prepareAdd(arguments);

        case DeleteCommand.COMMAND_WORD:
            return prepareDelete(arguments);

        case ClearCommand.COMMAND_WORD:
            return new ClearCommand();

        case FindCommand.COMMAND_WORD:
            return prepareFind(arguments);

        case ListCommand.COMMAND_WORD:
            return prepareList(arguments);

        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD:
            return new HelpCommand();

        case UpdateCommand.COMMAND_WORD:
            return prepareUpdate(arguments);

        case ChangeCommand.COMMAND_WORD:
            return prepareChange(arguments);

        case MarkDoneCommand.COMMAND_WORD:
            return prepareMarkDone(arguments);

        case MarkUndoneCommand.COMMAND_WORD:
            return prepareMarkUndone(arguments);

        case UndoCommand.COMMAND_WORD:
            return new UndoCommand();

        case RedoCommand.COMMAND_WORD:
            return new RedoCommand();

        case FreeTimeCommand.COMMAND_WORD:
            return prepareFreeTime(arguments);

        case PinCommand.COMMAND_WORD:
            return preparePin(arguments);

        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }
    
```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    private Command prepareList(String args) {
        String[] argComponents = args.trim().split(DELIMITER_BLANK_SPACE);
        String listArg = argComponents[LIST_ARG];
        if (!isListCommandValid(listArg)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
        }
        return new ListCommand(listArg);
    }

    private boolean isListCommandValid(String listArg) {
        return listArg.equals(LIST_COMMAND_ARG_COMPLETED) || listArg.equals(LIST_COMMAND_ARG_NOT_SPECIFIED)
                || listArg.equals(LIST_COMMAND_ARG_ALL_TASKS);
    }

    /**
     * Parses arguments in the context of the delete task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {
        String[] argComponents = args.trim().split(DELIMITER_BLANK_SPACE);
        if (argComponents.length < 2) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        Optional<Integer> index = parseIndex(argComponents[INDEX]);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        return new DeleteCommand(argComponents[TASK_TYPE], index.get());
    }

```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the markDone task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareMarkDone(String args) {
        String[] argComponents = args.trim().split(" ");
        if(argComponents.length > 1) {
            Optional<Integer> index = parseIndex(argComponents[INDEX]);
            if (!index.isPresent()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_USAGE));
            }
            return new MarkDoneCommand(argComponents[TASK_TYPE], index.get());
        } else {
            if(argComponents.length == 1 && !argComponents[0].equals("")) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_MISSING_INDEX));
            } else {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_MISSING_TASKTYPE_AND_INDEX));
            }
        }
    }

```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    /**
     * Checks that the command format is valid
     * 
     * @param type is todo/schedule, index is the index of item on the list,
     * argType is description/tag/date/time
     */
    private boolean isValidUpdateCommandFormat(String type, int index, String argType) {
        if (!(type.compareToIgnoreCase(TASK_TYPE_FLOATING) == 0
                || type.compareToIgnoreCase(TASK_TYPE_NON_FLOATING) == 0)) {
            return false;
        }
        if (index < 0) {
            return false;
        }
        if (!(argType.compareToIgnoreCase(TASK_ARG_DESCRIPTION) == 0 || argType.compareToIgnoreCase(TASK_ARG_TAG) == 0
                || argType.compareToIgnoreCase(TASK_ARG_DATE) == 0
                || argType.compareToIgnoreCase(TASK_ARG_TIME) == 0)) {
            return false;
        }
        return true;
    }

```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    /**
     * Returns the specified index in the {@code command} IF a positive unsigned
     * integer is given as the index. Returns an {@code Optional.empty()}
     * otherwise.
     */
    private Optional<Integer> parseIndex(String command) {
        final Matcher matcher = TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if (!StringUtil.isUnsignedInteger(index)) {
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }

    /**
     * Parses arguments in the context of the find task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareFind(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

```
###### \java\seedu\whatnow\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the free time command.
     * 
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareFreeTime(String args) {
        if (args == null) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FreeTimeCommand.MESSAGE_USAGE));
        }

        String date = args.trim();
        try {
            if (TODAY_OR_TOMORROW.matcher(date).find() || DAYS_IN_FULL.matcher(date).find() || DAYS_IN_SHORT.matcher(date).find()) {
                date = TaskDate.formatDayToDate(date);
            } else if (!date.equals(EMPTY_STRING)){
                date = TaskDate.formatDateToStandardDate(date);
            } else {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FreeTimeCommand.MESSAGE_USAGE));
            }
            return new FreeTimeCommand(date);
        } catch (ParseException e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FreeTimeCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ie) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FreeTimeCommand.MESSAGE_USAGE));
        }
    }

    private Command preparePin(String args) {
        if (args == null) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, PinCommand.MESSAGE_MISSING_DATE));
        }

        String[] argComponents = args.trim().split(DELIMITER_BLANK_SPACE);
        if(argComponents.length == 1) {
            if(argComponents[ZERO].equals(TASK_ARG_DATE)) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, PinCommand.MESSAGE_MISSING_DATE));
            } else if(argComponents[ZERO].equals(TASK_ARG_TAG)) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, PinCommand.MESSAGE_MISSING_TAG));
            } else {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, PinCommand.MESSAGE_USAGE));
            }
        } else if(argComponents.length <= 0) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, PinCommand.MESSAGE_USAGE));
        } else {
            String type = argComponents[ZERO];
            String keyword = argComponents[ONE];
            return new PinCommand(type, keyword);
        }
    }
}
```
###### \java\seedu\whatnow\model\freetime\FreePeriod.java
``` java
package seedu.whatnow.model.freetime;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Objects;
import java.util.logging.Logger;
import seedu.whatnow.commons.core.LogsCenter;

/**
 * Stores the freeslots(time period with no time-based tasks) of a given date.
 */
public class FreePeriod {
    
    private static final Logger logger = LogsCenter.getLogger(FreePeriod.class);
    
    private ArrayList<Period> freePeriod;

    private static final String TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT = "h:mma";

    public FreePeriod() {
        freePeriod = new ArrayList<Period>();
        freePeriod.add(new Period("12:00am", "11:59pm"));
    }

    public ArrayList<Period> getList() {
        return freePeriod;
    }

    public void block(String start, String end) {
        DateFormat df = new SimpleDateFormat(TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT);
        df.setLenient(false);
        try {
            Date reqStartTime = df.parse(start);
            Date reqEndTime = df.parse(end);
            Date freeSlotStartTime;
            Date freeSlotEndTime;
            for (int i = freePeriod.size()-1; i >= 0; i--) {
                Period curr = freePeriod.get(i);
                freeSlotStartTime = df.parse(curr.getStart());
                freeSlotEndTime = df.parse(curr.getEnd());
                if (isWithinThisPeriod(reqStartTime, reqEndTime, freeSlotStartTime, freeSlotEndTime)) {
                    freePeriod.remove(i);
                    freePeriod.add(new Period(curr.getStart(), start));
                    freePeriod.add(new Period(end, curr.getEnd()));
                } else if (isExactlyThisPeriod(reqStartTime, reqEndTime, freeSlotStartTime, freeSlotEndTime)) {
                    freePeriod.remove(i);
                } else if (isHeadOfThisPeriod(reqStartTime, reqEndTime, freeSlotStartTime, freeSlotEndTime)) {
                    curr.setStart(df.format(reqEndTime));
                } else if (isTailOfThisPeriod(reqStartTime, reqEndTime, freeSlotStartTime, freeSlotEndTime)) {
                    curr.setEnd(df.format(reqStartTime));
                } else if (isPartlyBeforeThisPeriod(reqStartTime, reqEndTime, freeSlotStartTime, freeSlotEndTime)) {
                    curr.setStart(df.format(reqEndTime));
                } else if (isPartlyAfterThisPeriod(reqStartTime, reqEndTime, freeSlotStartTime, freeSlotEndTime)) {
                    curr.setEnd(df.format(reqStartTime));
                } else if (isBiggerThanThisPeriod(reqStartTime, reqEndTime, freeSlotStartTime, freeSlotEndTime)) {
                    freePeriod.remove(i);
                } else {
                    logger.warning("FreePeriod.java: block method, entered else statement!\n" 
                + "Input Arg(start): " + start + "\n" + "Input Arg(end): " + end + "\n"
                + "curr block: " + freePeriod.get(i) + "\n");
                }
            }
        } catch (ParseException e) {
            logger.warning("ParseException at FreePeriod: \n" + e.getMessage());
        }
    }

    /**
     * 
     * @param reqStartTime: The start time of the task
     * @param reqEndTime: The end time of the task
     * @param freeSlotStartTime: The start time of a free time block
     * @param freeSlotEndTime: The end time of a free time block
     * @return true if time period of task is within the time period of a free block
     */
    private boolean isWithinThisPeriod(Date reqStartTime, Date reqEndTime, Date freeSlotStartTime,
            Date freeSlotEndTime) {
        return reqStartTime.compareTo(freeSlotStartTime) > 0 && reqEndTime.compareTo(freeSlotEndTime) < 0;
    }

    /**
     * 
     * @param reqStartTime: The start time of the task
     * @param reqEndTime: The end time of the task
     * @param freeSlotStartTime: The start time of a free time block
     * @param freeSlotEndTime: The end time of a free time block
     * @return true if time period of task coincides with the start of the free time block
     */
    private boolean isHeadOfThisPeriod(Date reqStartTime, Date reqEndTime, Date freeSlotStartTime,
            Date freeSlotEndTime) {
        return reqStartTime.compareTo(freeSlotStartTime) == 0 && reqEndTime.compareTo(freeSlotEndTime) < 0;
    }

    /**
     * 
     * @param reqStartTime: The start time of the task
     * @param reqEndTime: The end time of the task
     * @param freeSlotStartTime: The start time of a free time block
     * @param freeSlotEndTime: The end time of a free time block
     * @return true if time period of task coincides with the end of the free time block
     */
    private boolean isTailOfThisPeriod(Date reqStartTime, Date reqEndTime, Date freeSlotStartTime,
            Date freeSlotEndTime) {
        return reqStartTime.compareTo(freeSlotStartTime) > 0 && reqEndTime.compareTo(freeSlotEndTime) == 0;
    }

    /**
     * 
     * @param reqStartTime: The start time of the task
     * @param reqEndTime: The end time of the task
     * @param freeSlotStartTime: The start time of a free time block
     * @param freeSlotEndTime: The end time of a free time block
     * @return true if time period of task overlaps with the free time block and earlier
     */
    private boolean isPartlyBeforeThisPeriod(Date reqStartTime, Date reqEndTime, Date freeSlotStartTime,
            Date freeSlotEndTime) {
        return reqStartTime.compareTo(freeSlotStartTime) < 0 && reqEndTime.compareTo(freeSlotStartTime) > 0
                && reqEndTime.compareTo(freeSlotEndTime) < 0;
    }

    /**
     * 
     * @param reqStartTime: The start time of the task
     * @param reqEndTime: The end time of the task
     * @param freeSlotStartTime: The start time of a free time block
     * @param freeSlotEndTime: The end time of a free time block
     * @return true if time period of task overlaps with the free tiem block and later
     */
    private boolean isPartlyAfterThisPeriod(Date reqStartTime, Date reqEndTime, Date freeSlotStartTime,
            Date freeSlotEndTime) {
        return reqStartTime.compareTo(freeSlotStartTime) > 0 && reqStartTime.compareTo(freeSlotEndTime) < 0
                && reqEndTime.compareTo(freeSlotEndTime) > 0;
    }

    /**
     * 
     * @param reqStartTime: The start time of the task
     * @param reqEndTime: The end time of the task
     * @param freeSlotStartTime: The start time of a free time block
     * @param freeSlotEndTime: The end time of a free time block
     * @return true if time period of task is within the time period of a free block
     */
    private boolean isBiggerThanThisPeriod(Date reqStartTime, Date reqEndTime, Date freeSlotStartTime,
            Date freeSlotEndTime) {
        return (reqStartTime.compareTo(freeSlotStartTime) < 0 && reqEndTime.compareTo(freeSlotEndTime) >= 0)
                || (reqStartTime.compareTo(freeSlotStartTime) <= 0 && reqEndTime.compareTo(freeSlotEndTime) >= 0);
    }

    /**
     * 
     * @param reqStartTime: The start time of the task
     * @param reqEndTime: The end time of the task
     * @param freeSlotStartTime: The start time of a free time block
     * @param freeSlotEndTime: The end time of a free time block
     * @return true if time period of task is exactly the time period of a free block
     */
    private boolean isExactlyThisPeriod(Date reqStartTime, Date reqEndTime, Date freeSlotStartTime,
            Date freeSlotEndTime) {
        return reqStartTime.compareTo(freeSlotStartTime) == 0 && reqEndTime.compareTo(freeSlotEndTime) == 0;
    }

    @Override
    public String toString() {
        return freePeriod.toString();
    }

    @Override
    public int hashCode() {
        return Objects.hash(freePeriod);
    }
}
```
###### \java\seedu\whatnow\model\freetime\Period.java
``` java
package seedu.whatnow.model.freetime;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Comparator;
import java.util.Date;
import java.util.logging.Logger;
import seedu.whatnow.commons.core.LogsCenter;

/**
 * A time period with start and end time
 */
public class Period implements Comparator {

    private static final Logger logger = LogsCenter.getLogger(Period.class);
    
    public String start;
    public String end;

    private static final int SMALLER = -1;
    private static final int EQUAL = 0;
    private static final int BIGGER = 1;
    private static final String TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT = "h:mma";

    public Period() {

    }

    public Period(String start, String end) {
        this.start = start;
        this.end = end;
    }

    public void setStart(String start) {
        this.start = start;
    }

    public void setEnd(String end) {
        this.end = end;
    }

    public String getStart() {
        return this.start;
    }

    public String getEnd() {
        return this.end;
    }

    @Override
    public String toString() {
        return "[" + start + ", " + end + "]";
    }

    @Override
    public int compare(Object o1, Object o2) {
        if (o1 instanceof Period && o2 instanceof Period) {
            Period period1 = (Period) o1;
            Period period2 = (Period) o2;
            DateFormat df = new SimpleDateFormat(TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT);
            df.setLenient(false);
            try {
                Date p1start = df.parse(period1.getStart());
                Date p1end = df.parse(period1.getEnd());
                Date p2start = df.parse(period2.getStart());
                Date p2end = df.parse(period2.getEnd());

                if (p1start.compareTo(p2start) < 0 && p1end.compareTo(p2start) <= 0) {
                    return SMALLER;
                } else if (p1start.compareTo(p2start) == 0 && p1end.compareTo(p2end) == 0) {
                    return EQUAL;
                } else {
                    return BIGGER;
                }
            } catch (ParseException e) {
                logger.warning("ParseException at Period: \n" + e.getMessage());
                return EQUAL;
            }

        }
        return 0;
    }

}
```
###### \java\seedu\whatnow\model\Model.java
``` java
package seedu.whatnow.model;

import java.nio.file.Path;
import java.util.Set;
import java.util.Stack;

import seedu.whatnow.commons.core.Config;
import seedu.whatnow.commons.core.UnmodifiableObservableList;
import seedu.whatnow.commons.exceptions.DataConversionException;
import seedu.whatnow.model.freetime.FreePeriod;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.Task;
import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * The API of the Model component.
 */
public interface Model {

```
###### \java\seedu\whatnow\model\Model.java
``` java
    /**
     * Returns the filtered task list as an
     * {@code UnmodifiableObservableList<ReadOnlyTask>}
     */
    UnmodifiableObservableList<ReadOnlyTask> getCurrentFilteredTaskList();

    /**
     * Returns the filtered task list as an
     * {@code UnmodifiableObservableList<ReadOnlyTask>}
     */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList();

    /**
     * Returns the filtered task list with filter keyword as an
     * {@code UnmodifiableObservableList<ReadOnlyTask>}
     */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList(Set<String> key);

    /** Updates the filter of the filtered task list to show all tasks */
    void updateFilteredListToShowAll();

    /**
     * Updates the filter of the filtered task list to show all ongoing tasks
     */
    void updateFilteredListToShowAllIncomplete();

    /**
     * Updates the filter of the filtered task list to show all completed tasks
     */
    void updateFilteredListToShowAllCompleted();

    /**
     * Updates the filter of the filtered task list to filter by the given
     * keywords
     */
    void updateFilteredTaskList(Set<String> keywords);

    /** Update the given task */
    void updateTask(ReadOnlyTask old, Task toUpdate) throws TaskNotFoundException, DuplicateTaskException;

    /** Mark the given task as completed */
    void markTask(ReadOnlyTask target) throws TaskNotFoundException;

    /** Mark the given task as incomplete */
    void unMarkTask(ReadOnlyTask target) throws TaskNotFoundException;

    FreePeriod getFreeTime(String date);

```
###### \java\seedu\whatnow\model\Model.java
``` java
    // =========== Methods for Schedule List
    // ===============================================================
    
    /**
     * Returns the filtered task list as an
     * {@code UnmodifiableObservableList<ReadOnlyTask>}
     */
    UnmodifiableObservableList<ReadOnlyTask> getCurrentFilteredScheduleList();

    /**
     * Returns the filtered task list as an
     * {@code UnmodifiableObservableList<ReadOnlyTask>}
     */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredScheduleList();

    /**
     * Returns the filtered task list with filter keyword as an
     * {@code UnmodifiableObservableList<ReadOnlyTask>}
     */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredScheduleList(Set<String> key);

    /** Updates the filter of the filtered task list to show all tasks */
    void updateFilteredScheduleListToShowAll();

    /**
     * Updates the filter of the filtered task list to show all ongoing tasks
     */
    void updateFilteredScheduleListToShowAllIncomplete();

    /**
     * Updates the filter of the filtered task list to show all completed tasks
     */
    void updateFilteredScheduleListToShowAllCompleted();

    /**
     * Updates the filter of the filtered task list to filter by the given
     * keywords
     */
    void updateFilteredScheduleList(Set<String> keywords);

    /**
     * Returns the full filtered task list (all complete, incomplete and overdue tasks)
     */
    UnmodifiableObservableList<ReadOnlyTask> getAllTaskTypeList();
    
    /**
     * Updates the filter of the filtered task list to display all overdue tasks
     */
    void updateFilteredScheduleListToShowAllOverdue();
    
    /**
     * Returns the overdue task list
     */
    UnmodifiableObservableList<ReadOnlyTask> getOverdueScheduleList();
    
    /**
     * Returns the pinned item list based on keyword and pin item match type
     */
    UnmodifiableObservableList<ReadOnlyTask> getPinnedItems(String type, String keyword);
    
    /**
     * Updates the pinnedItems to display all tasks with keyword of type
     */
    void updatePinnedItemsToShowMatchKeywords(String type, String keyword);

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
package seedu.whatnow.model;

import javafx.collections.FXCollections;
import javafx.collections.transformation.FilteredList;
import seedu.whatnow.commons.core.ComponentManager;
import seedu.whatnow.commons.core.Config;
import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.core.UnmodifiableObservableList;
import seedu.whatnow.commons.events.model.AddTaskEvent;
import seedu.whatnow.commons.events.model.ConfigChangedEvent;
import seedu.whatnow.commons.events.model.PinnedItemChangedEvent;
import seedu.whatnow.commons.events.model.UpdateTaskEvent;
import seedu.whatnow.commons.events.model.WhatNowChangedEvent;
import seedu.whatnow.commons.exceptions.DataConversionException;
import seedu.whatnow.commons.exceptions.IllegalValueException;
import seedu.whatnow.commons.util.ConfigUtil;
import seedu.whatnow.commons.util.StringUtil;
import seedu.whatnow.model.freetime.FreePeriod;
import seedu.whatnow.model.freetime.Period;
import seedu.whatnow.model.tag.Tag;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.Task;
import seedu.whatnow.model.task.UniqueTaskList;
import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;
import java.nio.file.Path;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.Stack;
import java.util.logging.Logger;

/**
 * Represents the in-memory model of the WhatNow data. All changes to any model
 * should be synchronized.
 */
public class ModelManager extends ComponentManager implements Model {

    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);
    private static final String TASK_TYPE_FLOATING = "floating";
    private static final String TASK_TYPE_NOT_FLOATING = "not_floating";
    private static final String TASK_STATUS_COMPLETED = "completed";
    private static final String TASK_STATUS_INCOMPLETE = "incomplete";
    private static final String DEFAULT_START_TIME = "12:00am";
    private static final String DEFAULT_END_TIME = "11:59pm";
    private static final String TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT = "h:mma";
    private static final String DATE_NUM_SLASH_WITH_YEAR_FORMAT = "dd/MM/yyyy";
    private static final String DEFAULT_DATE = "01/01/2001";
    private static final String DEFAULT_TIME = "12:00am";
    
    private final WhatNow whatNow;
    private final FilteredList<Task> filteredTasks;
    private FilteredList<Task> filteredSchedules;
    private final FilteredList<Task> filteredOverdue;
    private final FilteredList<Task> pinnedItems;
    private final Stack<String> stackOfUndo;
    private final Stack<String> stackOfRedo;
    private final Stack<ReadOnlyTask> stackOfOldTask;
    private final Stack<ReadOnlyTask> stackOfCurrentTask;
    private final Stack<ReadOnlyTask> stackOfOldNextTask;
    private final Stack<ReadOnlyTask> stackOfNewNextTask;
    private final Stack<ReadOnlyWhatNow> stackOfWhatNow;
    private final Stack<ReadOnlyTask> stackOfDeletedTasks;
    private final Stack<Integer> stackOfDeletedTaskIndex;
    private final Stack<ReadOnlyTask> stackOfDeletedTasksRedo;
    private final Stack<Integer> stackOfDeletedTaskIndexRedo;
    private final Stack<ReadOnlyTask> stackOfDeletedTasksAdd;
    private final Stack<ReadOnlyTask> stackOfDeletedTasksAddRedo;
    private final Stack<ReadOnlyTask> stackOfMarkDone;
    private final Stack<ReadOnlyTask> stackOfMarkDoneRedo;
    private final Stack<ReadOnlyTask> stackOfMarkUndone;
    private final Stack<ReadOnlyTask> stackOfMarkUndoneRedo;
    private final Stack<String> stackOfListTypes;
    private final Stack<String> stackOfListTypesRedo;
    private final Stack<String> stackOfChangeFileLocationOld;
    private final Stack<String> stackOfChangeFileLocationNew;
    private final HashMap<String, FreePeriod> freeTimes;

  
    /**
     * Initializes a ModelManager with the given WhatNow WhatNow and its
     * variables should not be null
     */
    public ModelManager(WhatNow src, UserPrefs userPrefs) {
        super();
        assert src != null;
        assert userPrefs != null;

        logger.fine("Initializing with WhatNow: " + src + " and user prefs " + userPrefs);

        whatNow = new WhatNow(src);
        new Config();
        filteredTasks = new FilteredList<>(whatNow.getTasks());
        filteredSchedules = new FilteredList<>(whatNow.getTasks());
        filteredOverdue = new FilteredList<>(whatNow.getTasks());
        pinnedItems = new FilteredList<>(whatNow.getTasks());
        stackOfUndo = new Stack<>();
        stackOfRedo = new Stack<>();
        stackOfOldTask = new Stack<>();
        stackOfCurrentTask = new Stack<>();
        stackOfOldNextTask = new Stack<>();
        stackOfNewNextTask = new Stack<>();
        stackOfWhatNow = new Stack<>();
        stackOfDeletedTasks = new Stack<>();
        stackOfDeletedTaskIndex = new Stack<>();
        stackOfDeletedTasksRedo = new Stack<>();
        stackOfDeletedTaskIndexRedo = new Stack<>();
        stackOfDeletedTasksAdd = new Stack<>();
        stackOfDeletedTasksAddRedo = new Stack<>();
        stackOfMarkDone = new Stack<>();
        stackOfMarkDoneRedo = new Stack<>();
        stackOfMarkUndone = new Stack<>();
        stackOfMarkUndoneRedo = new Stack<>();
        stackOfListTypes = new Stack<>();
        stackOfListTypesRedo = new Stack<>();
        stackOfChangeFileLocationOld = new Stack<>();
        stackOfChangeFileLocationNew = new Stack<>();
        freeTimes = new HashMap<String, FreePeriod>();
        initialiseFreeTime();
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    private void initialiseFreeTime() {
        freeTimes.clear();
        for (int i = 0; i < filteredSchedules.size(); i++) {
            blockFreeTime(filteredSchedules.get(i));
        }
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public synchronized void markTask(ReadOnlyTask target) throws TaskNotFoundException {
        whatNow.markTask(target);
        indicateWhatNowChanged();
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getAllTaskTypeList() {
        filteredTasks.setPredicate(null);
        return new UnmodifiableObservableList<>(filteredTasks);
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public FreePeriod getFreeTime(String date) {
        if (freeTimes.get(date) == null) {
            freeTimes.put(date, new FreePeriod());
        }
        freeTimes.get(date).getList().sort(new Period());
        return freeTimes.get(date);
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    /**
     * Remove from the freetime block the period that coincides with the task
     * duration
     */
    private void blockFreeTime(Task task) {
        String date = task.getTaskDate();
        String startDate = task.getStartDate();
        String endDate = task.getEndDate();
        String startTime = task.getStartTime();
        String endTime = task.getEndTime();
        if (date != null && startTime != null && endTime != null) {
            blockTaskWithOneDateTwoTime(date, startTime, endTime);
        } else if (date == null && startTime != null && endTime != null) {
            blockTaskWithTwoDateTwoTime(startDate, endDate, startTime, endTime);
        }
    }

    /**
     * Remove from the freetime block the period that coincides with the task
     * duration, for task with one date and two time
     */
    private void blockTaskWithOneDateTwoTime(String date, String startTime, String endTime) {
        if (freeTimes.get(date) == null) {
            FreePeriod newFreePeriod = new FreePeriod();
            newFreePeriod.block(startTime, endTime);
            freeTimes.put(date, newFreePeriod);
        } else {
            freeTimes.get(date).block(startTime, endTime);
        }
    }

    /**
     * Remove from the freetime block the period that coincides with the task
     * duration, for task with two date and two time
     */
    private void blockTaskWithTwoDateTwoTime(String startDate, String endDate, String startTime, String endTime) {
        if (freeTimes.get(startDate) == null) {
            FreePeriod newFreePeriod = new FreePeriod();
            newFreePeriod.block(startTime, DEFAULT_END_TIME);
            freeTimes.put(startDate, newFreePeriod);
        } else {
            freeTimes.get(startDate).block(startTime, DEFAULT_END_TIME);
            freeTimes.put(startDate, freeTimes.get(startDate));
        }
        if (freeTimes.get(endDate) == null) {
            FreePeriod newFreePeriod = new FreePeriod();
            newFreePeriod.block(DEFAULT_START_TIME, endTime);
            freeTimes.put(endDate, newFreePeriod);
        } else {
            freeTimes.get(endDate).block(DEFAULT_START_TIME, endTime);
            freeTimes.put(endDate, freeTimes.get(endDate));
        }
        blockDatesInBetween(startDate, endDate);
    }

    /**
     * Remove from the freetime block the period that coincides with the task
     * duration, between startdate and end date
     */
    private void blockDatesInBetween(String start, String end) {
        Calendar cal = Calendar.getInstance();
        DateFormat df = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);

        try {
            Date startDate = df.parse(start);
            Date endDate = df.parse(end);
            cal.setTime(startDate);
            while (cal.getTime().before(endDate)) {
                cal.add(Calendar.DATE, 1);
                if (cal.getTime().equals(endDate)) {
                    break;
                }
                if (freeTimes.get(cal.getTime()) == null) {
                    FreePeriod newFreePeriod = new FreePeriod();
                    newFreePeriod.getList().clear();
                    freeTimes.put(df.format(cal.getTime()), newFreePeriod);
                } else {
                    freeTimes.get(cal.getTime()).getList().clear();
                }
            }
        } catch (ParseException e) {
            logger.warning("ModelManager.java, blockDatesInBetween\n" + e.getMessage());
        }
    }

    private void unblockFreeTime() {
        freeTimes.clear();
        initialiseFreeTime();
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    //=========== Filtered Task List Accessors ===============

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        updateFilteredListToShowAllIncomplete();
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getCurrentFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList(Set<String> keyword) {
        updateFilteredTaskList(keyword);
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    @Override
    public void updateFilteredListToShowAll() {
        String[] taskType = { TASK_TYPE_FLOATING };
        Set<String> keyword = new HashSet<>(Arrays.asList(taskType));
        FXCollections.sort(filteredTasks.getSource());
        updateFilteredTaskList(new PredicateExpression(new TaskTypeQualifier(keyword)));
    }

    @Override
    public void updateFilteredListToShowAllIncomplete() {
        FXCollections.sort(filteredTasks.getSource());
        filteredTasks.setPredicate(p -> {
            if ((p.getTaskType().equals((TASK_TYPE_FLOATING)) && (p.getStatus().equals(TASK_STATUS_INCOMPLETE)))) {
                return true;
            } else {
                return false;
            }
        });
    }

    @Override
    public void updateFilteredListToShowAllCompleted() {
        FXCollections.sort(filteredTasks.getSource());
        filteredTasks.setPredicate(p -> {
            if ((p.getTaskType().equals((TASK_TYPE_FLOATING)) && (p.getStatus().equals(TASK_STATUS_COMPLETED)))) {
                return true;
            } else {
                return false;
            }
        });
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        filteredTasks.setPredicate(p -> {
            if ((keywords.stream().filter(key -> StringUtil.containsIgnoreCase(p.getName().fullName, key)).findAny()
                    .isPresent()) && p.getTaskType().equals(TASK_TYPE_FLOATING)) {
                return true;
            } else {
                return false;
            }
        });
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    //=========== Filtered Schedule List Accessors =====================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredScheduleList() {
        updateFilteredScheduleListToShowAllIncomplete();
        return new UnmodifiableObservableList<>(filteredSchedules);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getCurrentFilteredScheduleList() {
        return new UnmodifiableObservableList<>(filteredSchedules);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredScheduleList(Set<String> keyword) {
        updateFilteredScheduleList(keyword);
        return new UnmodifiableObservableList<>(filteredSchedules);
    }
    
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getOverdueScheduleList() {
        updateFilteredScheduleListToShowAllOverdue();
        return new UnmodifiableObservableList<>(filteredOverdue);
    }

    @Override
    public void updateFilteredScheduleListToShowAll() {
        String[] taskType = { TASK_TYPE_NOT_FLOATING };
        Set<String> keyword = new HashSet<>(Arrays.asList(taskType));
        FXCollections.sort(filteredSchedules.getSource());
        updateFilteredScheduleList(new PredicateExpression(new TaskTypeQualifier(keyword)));
    }

    @Override
    public void updateFilteredScheduleListToShowAllIncomplete() {
        FXCollections.sort(filteredSchedules.getSource());
        filteredSchedules.setPredicate(p -> {
            if ((p.getTaskType().equals((TASK_TYPE_NOT_FLOATING)) && (p.getStatus().equals(TASK_STATUS_INCOMPLETE)))) {
                return true;
            } else {
                return false;
            }
        });
    }

    @Override
    public void updateFilteredScheduleListToShowAllCompleted() {
        FXCollections.sort(filteredSchedules.getSource());
        filteredSchedules.setPredicate(p -> {
            if ((p.getTaskType().equals((TASK_TYPE_NOT_FLOATING)) && (p.getStatus().equals(TASK_STATUS_COMPLETED)))) {
                return true;
            } else {
                return false;
            }
        });
    }

    @Override
    public void updateFilteredScheduleList(Set<String> keywords) {
        filteredSchedules.setPredicate(p -> {
            if ((keywords.stream().filter(key -> StringUtil.containsIgnoreCase(p.getName().fullName, key)).findAny()
                    .isPresent()) && p.getTaskType().equals(TASK_TYPE_NOT_FLOATING)) {
                return true;
            } else {
                return false;
            }
        });
    }
    
    @Override
    public void updateFilteredScheduleListToShowAllOverdue() {
        DateFormat df = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
        DateFormat tf = new SimpleDateFormat(TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT);
        Calendar cal = Calendar.getInstance();


        FXCollections.sort(filteredOverdue.getSource());
        filteredOverdue.setPredicate(p -> {
            try {
                Date today = df.parse(df.format(cal.getTime()));
                Date currentTime = tf.parse(tf.format(cal.getTime()));
                String dateString = getDate(p);
                String timeString = getTime(p);
                Date date = df.parse(dateString);
                Date time = tf.parse(timeString);
                if ((p.getTaskType().equals((TASK_TYPE_NOT_FLOATING)) && (p.getStatus().equals(TASK_STATUS_INCOMPLETE)
                        && date.before(today)
                        ||(date.equals(today) && time.before(currentTime))))) {
                    return true;
                } else {
                    return false;
                }
            } catch (ParseException e) {
                logger.warning("ParseException at ModelManager's updateFilteredScheduleListToShowAllOverdue method: \n" 
                        + e.getMessage());
                return false;
            }
        });

    }
    
    private String getDate(Task task) {
        String newDate = task.getTaskDate();
        if (newDate == null) {
            newDate = task.getEndDate();
        }
        if (newDate == null) {
            newDate = DEFAULT_DATE;
        }
        return newDate;
    }
    
    private String getTime(Task task) {
        String newTime = task.getTaskTime();
        if (newTime == null) {
            newTime = task.getEndTime();
        }
        if (newTime == null) {
            newTime = DEFAULT_TIME;
        }
        return newTime;
    }

    private void updateFilteredScheduleList(Expression expression) {
        filteredSchedules.setPredicate(expression::satisfies);
    }
    
    //=========== Pinned Items Accessors =====================
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getPinnedItems(String type, String keyword) {
        updatePinnedItemsToShowMatchKeywords(type, keyword);
        return new UnmodifiableObservableList<>(pinnedItems);
    }
    
    @Override
    public void updatePinnedItemsToShowMatchKeywords(String type, String keyword) {
        indicatePinnedItemsChanged(type, keyword);
        Calendar cal = Calendar.getInstance();
        DateFormat df = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);

        pinnedItems.setPredicate(p -> {
            try {
                String newKeyword = keyword;
                if (("today").equals(newKeyword)) {
                    newKeyword = df.format(cal.getTime());
                }
                if ((("tag").equals(type) && p.getTags().contains(new Tag(newKeyword))) 
                        || (("date").equals(type) && (newKeyword.equals(p.getTaskDate()) 
                                || (newKeyword.equals(p.getStartDate()))))) {
                    return true;
                } else {
                    return false;
                }
            } catch (IllegalValueException e) {
                logger.warning("IllegalValueException at updatePinnedItemsToShowMatchKeywords method of ModelManager\n"
                        + e.getMessage());
                return false;
            }
        });
    }
    

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    private class TaskTypeQualifier implements Qualifier {
        private Set<String> taskType;

        TaskTypeQualifier(Set<String> taskType) {
            this.taskType = taskType;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return taskType.stream().filter(keyword -> StringUtil.containsIgnoreCase(task.getTaskType(), keyword))
                    .findAny().isPresent();
        }

        @Override
        public String toString() {
            return "TaskType=" + String.join(", ", taskType);
        }
    }
}
```
###### \java\seedu\whatnow\model\task\ReadOnlyTask.java
``` java
package seedu.whatnow.model.task;

import seedu.whatnow.model.tag.UniqueTagList;

/**
 * A read-only immutable interface for a Task in the whatnow. Implementations
 * should guarantee: details are present and not null, field values are
 * validated.
 */
public interface ReadOnlyTask {

    Name getName();

    String getTaskDate();

    String getStartDate();

    String getEndDate();

    String getTaskTime();

    String getStartTime();

    String getEndTime();

    String getPeriod();

    String getEndPeriod();

    /**
     * The returned TagList is a deep copy of the internal TagList, changes on
     * the returned list will not affect the task's internal tags.
     */
    UniqueTagList getTags();

    /**
     * Return the status of the task.
     * @return
     */
    String getStatus();

    /**
     * Return the task type of the task.
     * @return
     */
    String getTaskType();

    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        if (isBothNoDateNoTime(other)) {
            return other == this // short circuit if same object
                    || (other != null // this is first to avoid NPE below
                    && other.getName().equals(this.getName()) && other.getTags().equals(this.getTags()));
        } else if (isBothOneDateNoTime(other)) {
            return other == this // short circuit if same object
                    || (other != null // this is first to avoid NPE below
                    && other.getName().equals(this.getName()) && other.getTags().equals(this.getTags()))
                    && other.getTaskDate().equals(this.getTaskDate());
        } else if (isBothOneDateOneTime(other)) {
            return other == this // short circuit if same object
                    || (other != null // this is first to avoid NPE below
                    && other.getName().equals(this.getName()) && other.getTags().equals(this.getTags()))
                    && other.getTaskDate().equals(this.getTaskDate())
                    && other.getTaskTime().equals(this.getTaskTime());
        } else if (isBothOneDateTwoTime(other)) {
            return other == this // short circuit if same object
                    || (other != null // this is first to avoid NPE below
                    && other.getName().equals(this.getName()) && other.getTags().equals(this.getTags()))
                    && other.getTaskDate().equals(this.getTaskDate())
                    && other.getStartTime().equals(this.getStartTime())
                    && other.getEndTime().equals(this.getEndTime());
        } else if (isBothTwoDateNoTime(other)) {
            return other == this // short circuit if same object
                    || (other != null // this is first to avoid NPE below
                    && other.getName().equals(this.getName()) && other.getTags().equals(this.getTags()))
                    && other.getStartDate().equals(this.getStartDate())
                    && other.getEndDate().equals(this.getEndDate());
        } else if (isBothTwoDateTwoTime(other)) {
            return other == this // short circuit if same object
                    || (other != null // this is first to avoid NPE below
                    && other.getName().equals(this.getName()) && other.getTags().equals(this.getTags()))
                    && other.getStartDate().equals(this.getStartDate())
                    && other.getEndDate().equals(this.getEndDate())
                    && other.getStartTime().equals(this.getStartTime())
                    && other.getEndTime().equals(this.getEndTime());
        } else {
            return false;
        }
    }

    default boolean isBothNoDateNoTime(ReadOnlyTask task) {
        return this.getTaskDate() == null && task.getTaskDate() == null && this.getStartDate() == null
                && task.getStartDate() == null && this.getEndDate() == null && task.getEndDate() == null
                && this.getStartTime() == null && task.getStartTime() == null && this.getEndDate() == null
                && task.getEndTime() == null;
    }

    default boolean isBothOneDateNoTime(ReadOnlyTask task) {
        return this.getTaskDate() != null && task.getTaskDate() != null && this.getTaskTime() == null
                && task.getTaskTime() == null && this.getStartTime() == null && task.getStartTime() == null;
    }

    default boolean isBothOneDateOneTime(ReadOnlyTask task) {
        return this.getTaskDate() != null && task.getTaskDate() != null && this.getTaskTime() != null
                && task.getTaskTime() != null;
    }

    default boolean isBothOneDateTwoTime(ReadOnlyTask task) {
        return this.getTaskDate() != null && task.getTaskDate() != null && this.getStartTime() != null
                && task.getStartTime() != null;
    }

    default boolean isBothTwoDateNoTime(ReadOnlyTask task) {
        return this.getStartDate() != null && task.getStartDate() != null && this.getStartTime() == null
                && task.getStartTime() == null;
    }

    default boolean isBothTwoDateTwoTime(ReadOnlyTask task) {
        return this.getStartDate() != null && task.getStartDate() != null && this.getStartTime() != null
                && task.getStartDate() != null;
    }

```
###### \java\seedu\whatnow\model\task\ReadOnlyTask.java
``` java
    /**
     * Returns a string representation of this Task's tags
     */
    default String tagsString() {
        final StringBuffer buffer = new StringBuffer();
        final String separator = ", ";
        getTags().forEach(tag -> buffer.append(tag).append(separator));
        if (buffer.length() == 0) {
            return "";
        } else {
            return buffer.substring(0, buffer.length() - separator.length());
        }
    }
}
```
###### \java\seedu\whatnow\model\task\Task.java
``` java
package seedu.whatnow.model.task;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Objects;
import java.util.logging.Logger;

import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.util.CollectionUtil;
import seedu.whatnow.model.tag.UniqueTagList;

/**
 * Represents a Task in WhatNow. Guarantees: details are present and not null,
 * field values are validated.
 */
public class Task implements ReadOnlyTask, Comparable<Task> {
    private static final Logger logger = LogsCenter.getLogger(Task.class);

    private Name name;
    private String taskDate;
    private String startDate;
    private String endDate;
    private String taskTime;
    private String startTime;
    private String endTime;
    private String period;
    private String endPeriod;
    private UniqueTagList tags;
    private String status;
    private String taskType;

    private static final String FLOATING = "floating";
    private static final String NOT_FLOATING = "not_floating";
    private static final int COMPARE_TO_IS_EQUAL = 0;
    private static final int COMPARE_TO_SMALLER = -1;
    private static final int COMPARE_TO_BIGGER = 1;
    private static final String DEFAULT_DATE = "01/01/2001";
    private static final String DEFAULT_START_TIME = "12:00am";
    private static final String DEFAULT_END_TIME = "11:59pm";
    public static final String TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT = "h:mma";
    private static final String DATE_NUM_SLASH_WITH_YEAR_FORMAT = "dd/MM/yyyy";

    public Task() {

    }

```
###### \java\seedu\whatnow\model\task\Task.java
``` java
    public int compareTo(Task task) {
        int compareToResult = 0;
        DateFormat df = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
        DateFormat tf = new SimpleDateFormat(TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT);
        try {
            Date thisStartDate = df.parse(getStartingDate());
            Date otherStartDate = df.parse(getStartingDate(task));
            Date thisEndDate = df.parse(getEndingDate());
            Date otherEndDate = df.parse(getEndingDate(task));
            Date thisStartTime = tf.parse(getStartingTime());
            Date otherStartTime = tf.parse(getStartingTime(task));
            Date thisEndTime = tf.parse(getEndingTime());
            Date otherEndTime = tf.parse(getEndingTime(task));

            if (thisStartDate.compareTo(otherStartDate) < 0) {
                compareToResult = COMPARE_TO_SMALLER;
            } else if (thisStartDate.compareTo(otherStartDate) > 0) {
                compareToResult = COMPARE_TO_BIGGER;
            } else if (thisEndDate.compareTo(otherEndDate) < 0) {
                compareToResult = COMPARE_TO_SMALLER;
            } else if (thisEndDate.compareTo(otherEndDate) > 0) {
                compareToResult = COMPARE_TO_BIGGER;
            } else if (thisStartTime.compareTo(otherStartTime) < 0) {
                compareToResult = COMPARE_TO_SMALLER;
            } else if (thisStartTime.compareTo(otherStartTime) > 0) {
                compareToResult = COMPARE_TO_BIGGER;
            } else if (thisEndTime.compareTo(otherEndTime) < 0) {
                compareToResult = COMPARE_TO_SMALLER;
            } else if (thisEndTime.compareTo(otherEndTime) > 0) {
                compareToResult = COMPARE_TO_BIGGER;
            } else {
                compareToResult = COMPARE_TO_IS_EQUAL;
            }
        } catch (ParseException e) {
            logger.warning("ParseException at Task: \n" + e.getMessage());
        }
        return compareToResult;
    }

    private String getStartingDate() {
        String thisStartingDate;

        if (this.getTaskDate() == null) {
            thisStartingDate = this.getStartDate();
        } else {
            thisStartingDate = this.getTaskDate();
        }

        if (thisStartingDate == null) {
            thisStartingDate = DEFAULT_DATE;
        }

        return thisStartingDate;
    }

    private String getStartingDate(Task task) {
        String otherStartingDate;

        if (task.getTaskDate() == null) {
            otherStartingDate = task.getStartDate();
        } else {
            otherStartingDate = task.getTaskDate();
        }

        if (otherStartingDate == null) {
            otherStartingDate = DEFAULT_DATE;
        }

        return otherStartingDate;
    }

    private String getEndingDate() {
        String thisEndingDate = this.getEndDate();

        if (thisEndingDate == null) {
            thisEndingDate = DEFAULT_DATE;
        }

        return thisEndingDate;
    }

    private String getEndingDate(Task task) {
        String otherEndingDate = task.getEndDate();

        if (otherEndingDate == null) {
            otherEndingDate = DEFAULT_DATE;
        }

        return otherEndingDate;
    }

    private String getStartingTime() {
        String thisStartingTime;

        if (this.getTaskTime() == null) {
            thisStartingTime = this.getStartTime();
        } else {
            thisStartingTime = this.getTaskTime();
        }

        if (thisStartingTime == null) {
            thisStartingTime = DEFAULT_START_TIME;
        }

        return thisStartingTime;
    }

    private String getStartingTime(Task task) {
        String otherStartingTime;

        if (task.getTaskTime() == null) {
            otherStartingTime = task.getStartTime();
        } else {
            otherStartingTime = task.getTaskTime();
        }

        if (otherStartingTime == null) {
            otherStartingTime = DEFAULT_START_TIME;
        }

        return otherStartingTime;

    }

    private String getEndingTime() {
        String thisEndingTime = this.getEndTime();

        if (thisEndingTime == null) {
            thisEndingTime = DEFAULT_END_TIME;
        }

        return thisEndingTime;
    }

    private String getEndingTime(Task task) {
        String otherEndingTime = task.getEndTime();

        if (otherEndingTime == null) {
            otherEndingTime = DEFAULT_END_TIME;
        }

        return otherEndingTime;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                        && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing
        // your own
        return Objects.hash(name, taskDate, startDate, endDate, taskTime, startTime, endTime, tags, status, taskType);
    }

    @Override
    public String toString() {
        return getAsText();
    }
}
```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    private static final int DATE_COMPONENT_DAY = 0;
    private static final int DATE_COMPONENT_MONTH = 1;
    private static final int DATE_COMPONENT_YEAR = 2;
    private static final int INCREASE_DATE_BY_ONE_DAY = 1;
    private static final int INCREASE_DATE_BY_SEVEN_DAYS = 7;

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    public static String formatDateToStandardDate(String date) throws IllegalValueException, ParseException {
        Calendar today = Calendar.getInstance();
        DateFormat yearFormat = new SimpleDateFormat("yyyy");
        String year = yearFormat.format(today.getTime());
        String[] dateComponent = new String[3];
        if (date.length() == 0) {
            throw new IllegalValueException(INVALID_TASK_DATE_NO_DATE);
        } else if (date.length() < 4) {
            throw new IllegalValueException(INVALID_TASK_DATE);
        } else if (date.contains("/")) {
            dateComponent = date.split("/");
        } else if (date.contains("-")) {
            dateComponent = date.split("-");
        } else if (date.contains(" ")) {
            dateComponent = date.split(" ");
        } else if (date.contains(".")) {
            dateComponent = date.split("\\.");
        } else {
            dateComponent[DATE_COMPONENT_DAY] = date.substring(0, 2);
            dateComponent[DATE_COMPONENT_MONTH] = date.substring(2, 4);
            dateComponent[DATE_COMPONENT_YEAR] = date.substring(4);
        }

        if (dateComponent[DATE_COMPONENT_DAY].length() < 2) {
            dateComponent[DATE_COMPONENT_DAY] = 0 + dateComponent[DATE_COMPONENT_DAY];
        }
        if (dateComponent[DATE_COMPONENT_MONTH].length() < 2) {
            dateComponent[DATE_COMPONENT_MONTH] = 0 + dateComponent[DATE_COMPONENT_MONTH];
        }
        if (dateComponent[DATE_COMPONENT_YEAR].length() < 4) {
            dateComponent[DATE_COMPONENT_YEAR].replace(dateComponent[DATE_COMPONENT_YEAR], year);
        }
        String formattedDate = dateComponent[DATE_COMPONENT_DAY] + "/" + dateComponent[DATE_COMPONENT_MONTH] + "/"
                + dateComponent[DATE_COMPONENT_YEAR];
        return formattedDate;
    }

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    public static String formatDayToDate(String date) {
        assert (DAYS_IN_FULL.matcher(date).find() || DAYS_IN_SHORT.matcher(date).find()
                || TODAY.matcher(date).find() || TOMORROW.matcher(date).find());
        DateFormat df = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
        Calendar cal = Calendar.getInstance();
        Calendar today = Calendar.getInstance();
        if (TODAY.matcher(date).find()) {
            return df.format(cal.getTime());
        } else if (TOMORROW.matcher(date).find()) {
            cal.add(Calendar.DATE, INCREASE_DATE_BY_ONE_DAY);
        } else if (DAYS_MONDAY.matcher(date).find()) {
            cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
        } else if (DAYS_TUESDAY.matcher(date).find()) {
            cal.set(Calendar.DAY_OF_WEEK, Calendar.TUESDAY);
        } else if (DAYS_WEDNESDAY.matcher(date).find()) {
            cal.set(Calendar.DAY_OF_WEEK, Calendar.WEDNESDAY);
        } else if (DAYS_THURSDAY.matcher(date).find()) {
            cal.set(Calendar.DAY_OF_WEEK, Calendar.THURSDAY);
        } else if (DAYS_FRIDAY.matcher(date).find()) {
            cal.set(Calendar.DAY_OF_WEEK, Calendar.FRIDAY);
        } else if (DAYS_SATURDAY.matcher(date).find()) {
            cal.set(Calendar.DAY_OF_WEEK, Calendar.SATURDAY);
        } else {
            cal.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);
        }
        if (cal.getTime().before(today.getTime())) {
            cal.add(Calendar.DATE, INCREASE_DATE_BY_SEVEN_DAYS);
        }
        return df.format(cal.getTime());
    }

```
###### \java\seedu\whatnow\model\task\UniqueTaskList.java
``` java
package seedu.whatnow.model.task;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import seedu.whatnow.commons.exceptions.DuplicateDataException;
import seedu.whatnow.commons.util.CollectionUtil;

import java.util.*;

/**
 * A list of tasks that enforces uniqueness between its elements and does not
 * allow nulls.
 *
 * Supports a minimal set of list operations.
 *
 * @see Task#equals(Object)
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueTaskList implements Iterable<Task> {
    
    private ObservableList<Task> internalList = FXCollections.observableArrayList();

    /**
     * Signals that an operation would have violated the 'no duplicates'
     * property of the list.
     */
    public static class DuplicateTaskException extends DuplicateDataException {
        protected DuplicateTaskException() {
            super("Operation would result in duplicate tasks");
        }
    }

    /**
     * Signals that an operation targeting a specified task in the list would
     * fail because there is no such matching task in the list.
     */
    public static class TaskNotFoundException extends Exception {
    }

    public static class NoPrevCommandException extends Exception {
        public NoPrevCommandException() {
            super("No previous Command was found");
        }
    }

    // private Stack<Task[]> reqStack = new Stack<>();

    // private Task[] array = new Task[];
    /**
     * Constructs empty TaskList.
     */
    public UniqueTaskList() {
    }

    /**
     * Returns true if the list contains an equivalent task as the given
     * argument.
     */
    public boolean contains(ReadOnlyTask toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Adds a task to the list.
     *
     * @throws DuplicateTaskException
     *             if the task to add is a duplicate of an existing task in the
     *             list.
     */
    public void add(Task toAdd) throws DuplicateTaskException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTaskException();
        }

        internalList.add(toAdd);
    }

    public void addSpecific(Task toAddSpecific, int idx) throws DuplicateTaskException {
        assert toAddSpecific != null;
        if (contains(toAddSpecific)) {
            throw new DuplicateTaskException();
        }

        internalList.add(idx, toAddSpecific);
    }

    /**
     * Removes the equivalent task from the list.
     *
     * @throws TaskNotFoundException
     *             if no such task could be found in the list.
     */
    public boolean remove(ReadOnlyTask toRemove) throws TaskNotFoundException {
        assert toRemove != null;
        final boolean taskFoundAndDeleted = internalList.remove(toRemove);
        if (!taskFoundAndDeleted) {
            throw new TaskNotFoundException();
        }
        return taskFoundAndDeleted;
    }

```
###### \java\seedu\whatnow\model\task\UniqueTaskList.java
``` java
    /**
     * Mark the equivalent task from the list as completed.
     */
    public boolean mark(ReadOnlyTask target) throws TaskNotFoundException {
        assert target != null;
        final boolean taskFoundAndMarked = internalList.contains(target);
        if (!taskFoundAndMarked) {
            throw new TaskNotFoundException();
        }
        internalList.get(internalList.indexOf(target)).setStatus("completed");
        internalList.set(internalList.indexOf(target), internalList.get(internalList.indexOf(target)));
        return taskFoundAndMarked;
    }

```
###### \java\seedu\whatnow\storage\JsonUserPrefsStorage.java
``` java
import java.io.File;
import java.io.IOException;
import java.util.Optional;
import java.util.logging.Logger;

import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.exceptions.DataConversionException;
import seedu.whatnow.commons.util.FileUtil;
import seedu.whatnow.model.UserPrefs;

/**
 * A class to access UserPrefs stored in the hard disk as a json file
 */
public class JsonUserPrefsStorage implements UserPrefsStorage {

    private static final Logger logger = LogsCenter.getLogger(JsonUserPrefsStorage.class);

    private String filePath;

    public JsonUserPrefsStorage(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public Optional<UserPrefs> readUserPrefs() throws DataConversionException, IOException {
        return readUserPrefs(filePath);
    }

    @Override
    public void saveUserPrefs(UserPrefs userPrefs) throws IOException {
        saveUserPrefs(userPrefs, filePath);
    }

    /**
     * Similar to {@link #readUserPrefs()}
     * 
     * @param prefsFilePath
     *            location of the data. Cannot be null.
     * @throws DataConversionException
     *             if the file format is not as expected.
     */
    public Optional<UserPrefs> readUserPrefs(String prefsFilePath) throws DataConversionException {
        assert prefsFilePath != null;

        File prefsFile = new File(prefsFilePath);

        if (!prefsFile.exists()) {
            logger.info("Prefs file " + prefsFile + " not found");
            return Optional.empty();
        }

        UserPrefs prefs;

        try {
            prefs = FileUtil.deserializeObjectFromJsonFile(prefsFile, UserPrefs.class);
        } catch (IOException e) {
            logger.warning("Error reading from prefs file " + prefsFile + ": " + e);
            throw new DataConversionException(e);
        }

        return Optional.of(prefs);
    }

    /**
     * Similar to {@link #saveUserPrefs(UserPrefs)}
     * 
     * @param prefsFilePath
     *            location of the data. Cannot be null.
     */
    public void saveUserPrefs(UserPrefs userPrefs, String prefsFilePath) throws IOException {
        assert userPrefs != null;
        assert prefsFilePath != null;

        FileUtil.serializeObjectToJsonFile(new File(prefsFilePath), userPrefs);
    }
}
```
###### \java\seedu\whatnow\ui\CommandBox.java
``` java
import com.google.common.eventbus.Subscribe;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.SplitPane;
import javafx.scene.control.TextField;
import javafx.scene.layout.AnchorPane;
import javafx.stage.Stage;
import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.events.ui.IncorrectCommandAttemptedEvent;
import seedu.whatnow.commons.util.FxViewUtil;
import seedu.whatnow.logic.Logic;
import seedu.whatnow.logic.commands.*;
import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

import java.text.ParseException;
import java.util.logging.Logger;

public class CommandBox extends UiPart {
    private final Logger logger = LogsCenter.getLogger(CommandBox.class);
    private static final String FXML = "CommandBox.fxml";

    private AnchorPane placeHolderPane;
    private AnchorPane commandPane;
    private ResultDisplay resultDisplay;
    private String previousCommandTest;

    private Logic logic;

    @FXML
    private TextField commandTextField;
    private CommandResult mostRecentResult;

    public static CommandBox load(Stage primaryStage, AnchorPane commandBoxPlaceholder, ResultDisplay resultDisplay,
            Logic logic) {
        CommandBox commandBox = UiPartLoader.loadUiPart(primaryStage, commandBoxPlaceholder, new CommandBox());
        commandBox.configure(resultDisplay, logic);
        commandBox.addToPlaceholder();
        return commandBox;
    }

    public void configure(ResultDisplay resultDisplay, Logic logic) {
        this.resultDisplay = resultDisplay;
        this.logic = logic;
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(commandTextField);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandTextField, 0.0, 0.0, 0.0, 0.0);
        commandTextField.requestFocus();
    }

    @Override
    public void setNode(Node node) {
        commandPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    @FXML
    private void handleCommandInputChanged() throws ParseException, DuplicateTaskException, TaskNotFoundException {
        // Take a copy of the command text
        previousCommandTest = commandTextField.getText();

        /*
         * We assume the command is correct. If it is incorrect, the command box
         * will be changed accordingly in the event handling code {@link
         * #handleIncorrectCommandAttempted}
         */
        setStyleToIndicateCorrectCommand();
        mostRecentResult = logic.execute(previousCommandTest);
        resultDisplay.postMessage(mostRecentResult.feedbackToUser);

        logger.info("Result: " + mostRecentResult.feedbackToUser);
    }

    /**
     * Sets the command box style to indicate a correct command.
     */
    private void setStyleToIndicateCorrectCommand() {
        commandTextField.getStyleClass().remove("error");
        commandTextField.setText("");
    }

    @Subscribe
    private void handleIncorrectCommandAttempted(IncorrectCommandAttemptedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Invalid command: " + previousCommandTest));
        setStyleToIndicateIncorrectCommand();
        restoreCommandText();
    }

    /**
     * Restores the command box text to the previously entered command
     */
    private void restoreCommandText() {
        commandTextField.setText(previousCommandTest);
    }

    /**
     * Sets the command box style to indicate an error
     */
    private void setStyleToIndicateIncorrectCommand() {
        commandTextField.getStyleClass().add("error");
    }

}
```
###### \java\seedu\whatnow\ui\MainWindow.java
``` java
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.MenuItem;
import javafx.scene.input.KeyCombination;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import seedu.whatnow.commons.core.Config;
import seedu.whatnow.commons.core.GuiSettings;
import seedu.whatnow.commons.events.ui.ExitAppRequestEvent;
import seedu.whatnow.logic.Logic;
import seedu.whatnow.model.UserPrefs;

/**
 * The Main Window. Provides the basic application layout containing a menu bar
 * and space where other JavaFX elements can be placed.
 */
public class MainWindow extends UiPart {

    private static final String ICON = "/images/WhatNowWhiteOnBlue.png";
    private static final String FXML = "MainWindow.fxml";
    public static final int MIN_HEIGHT = 600;
    public static final int MIN_WIDTH = 1200;

    private Logic logic;

    // Independent Ui parts residing in this Ui container
    private ScheduleListPanel scheduleListPanel;
    private TaskListPanel taskListPanel;
    private ResultDisplay resultDisplay;
    private StatusBarFooter statusBarFooter;
    private CommandBox commandBox;
    private Config config;
    private UserPrefs userPrefs;
    private StatusPanel statusPanel;
    private PinnedItemPanel pinnedItemPanel;

    // Handles to elements of this Ui container
    private VBox rootLayout;
    private Scene scene;

    @FXML
    private AnchorPane scheduleListPlaceholder;

    @FXML
    private AnchorPane commandBoxPlaceholder;

    @FXML
    private MenuItem helpMenuItem;

    @FXML
    private AnchorPane taskListPanelPlaceholder;

    @FXML
    private AnchorPane resultDisplayPlaceholder;

    @FXML
    private AnchorPane statusbarPlaceholder;
    
    @FXML
    private AnchorPane statusPanelPlaceholder;
    
    @FXML
    private AnchorPane pinnedItemPlaceholder;
    
    @FXML
    private GridPane gridPane;

    public MainWindow() {
        super();
    }

    @Override
    public void setNode(Node node) {
        rootLayout = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    public static MainWindow load(Stage primaryStage, Config config, UserPrefs prefs, Logic logic) {

        MainWindow mainWindow = UiPartLoader.loadUiPart(primaryStage, new MainWindow());
        mainWindow.configure(config.getAppTitle(), config.getWhatNowName(), config, prefs, logic);
        return mainWindow;
    }

    private void configure(String appTitle, String whatNowName, Config config, UserPrefs prefs, Logic logic) {

        // Set dependencies
        this.logic = logic;
        this.config = config;
        this.userPrefs = prefs;
        // Configure the UI
        setTitle(appTitle);
        setIcon(ICON);
        setWindowMinSize();
        setWindowDefaultSize(prefs);
        
        
        scene = new Scene(rootLayout);
        primaryStage.setScene(scene);
        setAccelerators();
        
    }

    private void setAccelerators() {
        helpMenuItem.setAccelerator(KeyCombination.valueOf("F1"));
    }

    void fillInnerParts() {
        pinnedItemPanel = PinnedItemPanel.load(primaryStage, 
                getPinnedListPlaceholder(), 
                logic.getPinnedItems(config.getPinnedItemType(), config.getPinnedItemKeyword()));
        statusPanel = StatusPanel.load(primaryStage, getStatusPanelPlaceholder(), getGridPane());
        statusPanel.postMessage("Number of ongoing tasks in schedule: " + String.valueOf(logic.getFilteredScheduleList().size()
                + "\n"
                + "Number of overdue tasks in schedule: " + String.valueOf(logic.getOverdueScheduleList().size())));
        scheduleListPanel = ScheduleListPanel.load(primaryStage, getScheduleListPlaceholder(),
                logic.getFilteredScheduleList());
        taskListPanel = TaskListPanel.load(primaryStage, getTaskListPlaceholder(), logic.getFilteredTaskList());
        resultDisplay = ResultDisplay.load(primaryStage, getResultDisplayPlaceholder());
        statusBarFooter = StatusBarFooter.load(primaryStage, getStatusbarPlaceholder(), config.getWhatNowFilePath());
        commandBox = CommandBox.load(primaryStage, getCommandBoxPlaceholder(), resultDisplay, logic);
    }

    private AnchorPane getCommandBoxPlaceholder() {
        return commandBoxPlaceholder;
    }

    private AnchorPane getStatusbarPlaceholder() {
        return statusbarPlaceholder;
    }

    private AnchorPane getResultDisplayPlaceholder() {
        return resultDisplayPlaceholder;
    }

    public AnchorPane getTaskListPlaceholder() {
        return taskListPanelPlaceholder;
    }

    private AnchorPane getScheduleListPlaceholder() {
        return scheduleListPlaceholder;
    }
    
    private AnchorPane getStatusPanelPlaceholder() {
        return statusPanelPlaceholder;
    }
    
    private AnchorPane getPinnedListPlaceholder() {
        return pinnedItemPlaceholder;
    }
    
    private GridPane getGridPane() {
        return gridPane;
    }

    public void hide() {
        primaryStage.hide();
    }

    private void setTitle(String appTitle) {
        primaryStage.setTitle(appTitle);
    }

    /**
     * Sets the default size based on user preferences.
     */
    protected void setWindowDefaultSize(UserPrefs prefs) {
        primaryStage.setHeight(prefs.getGuiSettings().getWindowHeight());
        primaryStage.setWidth(prefs.getGuiSettings().getWindowWidth());
        if (prefs.getGuiSettings().getWindowCoordinates() != null) {
            primaryStage.setX(prefs.getGuiSettings().getWindowCoordinates().getX());
            primaryStage.setY(prefs.getGuiSettings().getWindowCoordinates().getY());
        }
    }

    private void setWindowMinSize() {
        primaryStage.setMinHeight(MIN_HEIGHT);
        primaryStage.setMinWidth(MIN_WIDTH);
    }

    /**
     * Returns the current size and the position of the main Window.
     */
    public GuiSettings getCurrentGuiSetting() {
        return new GuiSettings(primaryStage.getWidth(), primaryStage.getHeight(), (int) primaryStage.getX(),
                (int) primaryStage.getY());
    }

    @FXML
    public void handleHelp() {
        HelpWindow helpWindow = HelpWindow.load(primaryStage);
        helpWindow.show();
    }

    public void show() {
        primaryStage.show();
    }

    /**
     * Closes the application.
     */
    @FXML
    private void handleExit() {
        raise(new ExitAppRequestEvent());
    }

    public TaskListPanel getTaskListPanel() {
        return this.taskListPanel;
    }

    public ScheduleListPanel getScheduleListPanel() {
        return this.scheduleListPanel;
    }
    
    public StatusPanel getStatusPanel() {
        return this.statusPanel;
    }
    
    public PinnedItemPanel getPinnedItemPanel() {
        return this.pinnedItemPanel;
    }
}

```
###### \java\seedu\whatnow\ui\ResultDisplay.java
``` java
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.scene.Node;
import javafx.scene.control.TextArea;
import javafx.scene.layout.AnchorPane;
import javafx.stage.Stage;
import seedu.whatnow.commons.util.FxViewUtil;

/**
 * A ui for the status bar that is displayed at the header of the application.
 */
public class ResultDisplay extends UiPart {
    public static final String RESULT_DISPLAY_ID = "resultDisplay";
    private static final String STATUS_BAR_STYLE_SHEET = "result-display";
    private final StringProperty displayed = new SimpleStringProperty("");

    private static final String FXML = "ResultDisplay.fxml";

    private AnchorPane placeHolder;

    private AnchorPane mainPane;

    public static ResultDisplay load(Stage primaryStage, AnchorPane placeHolder) {
        ResultDisplay statusBar = UiPartLoader.loadUiPart(primaryStage, placeHolder, new ResultDisplay());
        statusBar.configure();
        return statusBar;
    }

    public void configure() {
        TextArea resultDisplayArea = new TextArea();
        resultDisplayArea.setEditable(false);
        resultDisplayArea.setId(RESULT_DISPLAY_ID);
        resultDisplayArea.getStyleClass().removeAll();
        resultDisplayArea.getStyleClass().add(STATUS_BAR_STYLE_SHEET);
        resultDisplayArea.setText("");
        resultDisplayArea.textProperty().bind(displayed);
        FxViewUtil.applyAnchorBoundaryParameters(resultDisplayArea, 0.0, 0.0, 0.0, 0.0);
        mainPane.getChildren().add(resultDisplayArea);
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);
    }

    @Override
    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    public void postMessage(String message) {
        displayed.setValue(message);
    }

}
```
###### \java\seedu\whatnow\ui\ScheduleListPanel.java
``` java
import javafx.application.Platform;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.SplitPane;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.events.ui.TaskPanelSelectionChangedEvent;
import seedu.whatnow.model.task.ReadOnlyTask;

import java.util.logging.Logger;

/**
 * Panel containing the list of tasks.
 */
public class ScheduleListPanel extends UiPart {
    private final Logger logger = LogsCenter.getLogger(TaskListPanel.class);
    private static final String FXML = "ScheduleListPanel.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;

    @FXML
    private ListView<ReadOnlyTask> scheduleListView;

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static ScheduleListPanel load(Stage primaryStage, AnchorPane scheduleListPlaceholder,
            ObservableList<ReadOnlyTask> taskList) {
        ScheduleListPanel scheduleListPanel = UiPartLoader.loadUiPart(primaryStage, scheduleListPlaceholder,
                new ScheduleListPanel());
        scheduleListPanel.configure(taskList);
        return scheduleListPanel;
    }

    private void configure(ObservableList<ReadOnlyTask> scheduleList) {
        setConnections(scheduleList);
        addToPlaceholder();
    }

    private void setConnections(ObservableList<ReadOnlyTask> scheduleList) {
        scheduleListView.setItems(scheduleList);
        scheduleListView.setCellFactory(listView -> new ScheduleListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    private void setEventHandlerForSelectionChangeEvent() {
        scheduleListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in task list panel changed to : '" + newValue + "'");
                raise(new TaskPanelSelectionChangedEvent(newValue));
            }
        });
    }

    /** Clears the schedule list view of any selection */
    public void clear() {
        scheduleListView.getSelectionModel().clearSelection();
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            scheduleListView.scrollTo(index);
            scheduleListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class ScheduleListViewCell extends ListCell<ReadOnlyTask> {

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(TaskCard.load(task, getIndex() + 1).getLayout());
            }
        }
    }

}
```
###### \java\seedu\whatnow\ui\StatusPanel.java
``` java
package seedu.whatnow.ui;

import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.TextArea;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Border;
import javafx.scene.layout.GridPane;
import javafx.scene.paint.Paint;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.stage.Stage;

/**
 * A ui for the status bar that is displayed at the header of the application.
 */
public class StatusPanel extends UiPart {
    public static final String STATUS_DISPLAY_ID = "statusPanel";
    private TextArea statusDisplayArea;
    private final StringProperty displayed = new SimpleStringProperty("");

    private static final String FXML = "StatusPanel.fxml";

    private AnchorPane placeHolder;

    private AnchorPane mainPane;
    
    private GridPane gridPane;

    public static StatusPanel load(Stage primaryStage, AnchorPane placeHolder, GridPane gridPane) {
        StatusPanel statusBar = UiPartLoader.loadUiPart(primaryStage, placeHolder, new StatusPanel());
        statusBar.configure(gridPane);
        return statusBar;
    }

    public void configure(GridPane gridPane) {
        this.gridPane = gridPane;
        Image image = new Image("/images/WhatNowWhiteOnBlue.png");
        ImageView iv1 = new ImageView();
        iv1.setImage(image);
        iv1.setFitWidth(350);
        iv1.setFitHeight(178);
        
        TextArea statusDisplayArea = new TextArea();
        statusDisplayArea.setEditable(false);
        statusDisplayArea.setId(STATUS_DISPLAY_ID);
        statusDisplayArea.textProperty().bind(displayed);
        statusDisplayArea.setMaxWidth(350);
        statusDisplayArea.setMinHeight(60);
        statusDisplayArea.setMaxHeight(60);
        statusDisplayArea.setPadding(Insets.EMPTY);
        statusDisplayArea.setFont(Font.font(15));
        statusDisplayArea.setBorder(Border.EMPTY);
        
        Text pinHeader = new Text();
        pinHeader.setText("Pinned Items");
        pinHeader.setFont(Font.font(20));
        pinHeader.setFill(Paint.valueOf("white"));
        
        gridPane.add(iv1, 0, 0, 1, 1);
        gridPane.add(statusDisplayArea, 0, 1, 1, 1);
        gridPane.add(pinHeader, 0, 2, 1, 1);
        GridPane.setHalignment(gridPane.getChildren().get(4), HPos.CENTER);
    }

    @Override
    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    public void postMessage(String message) {
        displayed.setValue(message);
    }

}
```
###### \java\seedu\whatnow\ui\TaskCard.java
``` java
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import seedu.whatnow.model.task.ReadOnlyTask;

public class TaskCard extends UiPart {

    private static final String FXML = "TaskListCard.fxml";
    private static final String INCOMPLETE = "";

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label taskDate;
    @FXML
    private Label startDate;
    @FXML
    private Label endDate;
    @FXML
    private Label taskTime;
    @FXML
    private Label startTime;
    @FXML
    private Label endTime;
    @FXML
    private Label id;
    @FXML
    private Label tags;
    @FXML
    private Label status;

    private ReadOnlyTask task;
    private int displayedIndex;
    
    public static TaskCard load(ReadOnlyTask task, int displayedIndex) {
        TaskCard card = new TaskCard();
        card.task = task;
        card.displayedIndex = displayedIndex;
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        name.setText(task.getName().fullName);
        id.setText(displayedIndex + ". ");

        if (task.getTaskDate() != null) {
            taskDate.setText(task.getTaskDate());
        } else if (task.getTaskDate() == null) {
            taskDate.setText("");
        }

        if (task.getStartDate() != null) {
            startDate.setText(task.getStartDate());
        } else if (task.getStartDate() == null) {
            startDate.setText("");
        }

        if (task.getEndDate() != null) {
            endDate.setText("to " + task.getEndDate());
        } else if (task.getEndDate() == null) {
            endDate.setText("");
        }

        if (task.getTaskTime() != null) {
            taskTime.setText(task.getTaskTime());
        } else if (task.getTaskTime() == null) {
            taskTime.setText("");
        }

        if (task.getStartTime() != null) {
            startTime.setText(task.getStartTime());
        } else if (task.getStartTime() == null) {
            startTime.setText("");
        }

        if (task.getEndTime() != null) {
            if (task.getEndDate() == null)
                endTime.setText("to " + task.getEndTime());
            else if (task.getEndDate() != null)
                endTime.setText(task.getEndTime());
        } else if (task.getEndTime() == null) {
            endTime.setText("");
        }

        tags.setText(task.tagsString());
        if (task.getStatus().equals("incomplete")) {
            status.setText(INCOMPLETE);
        } else {
            status.setText(task.getStatus());
        }
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \java\seedu\whatnow\ui\TaskListPanel.java
``` java
import javafx.application.Platform;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.SplitPane;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.events.ui.TaskPanelSelectionChangedEvent;
import seedu.whatnow.model.task.ReadOnlyTask;

import java.util.logging.Logger;

/**
 * Panel containing the list of tasks.
 */
public class TaskListPanel extends UiPart {
    private final Logger logger = LogsCenter.getLogger(TaskListPanel.class);
    private static final String FXML = "TaskListPanel.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;

    @FXML
    private ListView<ReadOnlyTask> taskListView;

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static TaskListPanel load(Stage primaryStage, AnchorPane taskListPlaceholder,
            ObservableList<ReadOnlyTask> taskList) {
        TaskListPanel taskListPanel = UiPartLoader.loadUiPart(primaryStage, taskListPlaceholder, new TaskListPanel());
        taskListPanel.configure(taskList);
        return taskListPanel;
    }

    private void configure(ObservableList<ReadOnlyTask> taskList) {
        setConnections(taskList);
        addToPlaceholder();
    }

    private void setConnections(ObservableList<ReadOnlyTask> taskList) {
        taskListView.setItems(taskList);
        taskListView.setCellFactory(listView -> new TaskListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    private void setEventHandlerForSelectionChangeEvent() {
        taskListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in task list panel changed to : '" + newValue + "'");
                raise(new TaskPanelSelectionChangedEvent(newValue));
            }
        });
    }

    /** Clears the task list view of any selection */
    public void clear() {
        taskListView.getSelectionModel().clearSelection();
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            taskListView.scrollTo(index);
            taskListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class TaskListViewCell extends ListCell<ReadOnlyTask> {

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(TaskCard.load(task, getIndex() + 1).getLayout());
            }
        }
    }

}
```
###### \java\seedu\whatnow\ui\UiManager.java
``` java
import com.google.common.eventbus.Subscribe;
import javafx.application.Platform;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.image.Image;
import javafx.stage.Stage;
import seedu.whatnow.MainApp;
import seedu.whatnow.commons.core.ComponentManager;
import seedu.whatnow.commons.core.Config;
import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.events.model.AddTaskEvent;
import seedu.whatnow.commons.events.model.UpdateTaskEvent;
import seedu.whatnow.commons.events.model.WhatNowChangedEvent;
import seedu.whatnow.commons.events.storage.DataSavingExceptionEvent;
import seedu.whatnow.commons.events.ui.ShowHelpRequestEvent;
import seedu.whatnow.commons.util.StringUtil;
import seedu.whatnow.logic.Logic;
import seedu.whatnow.model.UserPrefs;
import seedu.whatnow.model.task.Task;
import java.util.logging.Logger;

/**
 * The manager of the UI component.
 */
public class UiManager extends ComponentManager implements Ui {
    private static final Logger logger = LogsCenter.getLogger(UiManager.class);
    private static final String ICON_APPLICATION = "/images/whatnow_32.png";
    private static final String MESSAGE_TASK_ADDED = "A task was added";
    private static final String MESSAGE_TASK_UPDATED = "A task was updated";

    private Logic logic;
    private Config config;
    private UserPrefs prefs;
    private MainWindow mainWindow;

    public UiManager(Logic logic, Config config, UserPrefs prefs) {
        super();
        this.logic = logic;
        this.config = config;
        this.prefs = prefs;
    }

    @Override
    public void start(Stage primaryStage) {
        logger.info("Starting UI...");
        primaryStage.setTitle(config.getAppTitle());

        // Set the application icon.
        primaryStage.getIcons().add(getImage(ICON_APPLICATION));

        try {
            mainWindow = MainWindow.load(primaryStage, config, prefs, logic);
            mainWindow.show(); // This should be called before creating other UI
                               // parts
            mainWindow.fillInnerParts();

        } catch (Throwable e) {
            logger.severe(StringUtil.getDetails(e));
            showFatalErrorDialogAndShutdown("Fatal error during initializing", e);
        }
    }

    @Override
    public void stop() {
        prefs.updateLastUsedGuiSetting(mainWindow.getCurrentGuiSetting());
        mainWindow.hide();
    }

    private void showFileOperationAlertAndWait(String description, String details, Throwable cause) {
        final String content = details + ":\n" + cause.toString();
        showAlertDialogAndWait(AlertType.ERROR, "File Op Error", description, content);
    }

    private Image getImage(String imagePath) {
        return new Image(MainApp.class.getResourceAsStream(imagePath));
    }

    void showAlertDialogAndWait(Alert.AlertType type, String title, String headerText, String contentText) {
        showAlertDialogAndWait(mainWindow.getPrimaryStage(), type, title, headerText, contentText);
    }

    private static void showAlertDialogAndWait(Stage owner, AlertType type, String title, String headerText,
            String contentText) {
        final Alert alert = new Alert(type);
        alert.getDialogPane().getStylesheets().add("view/DarkTheme.css");
        alert.initOwner(owner);
        alert.setTitle(title);
        alert.setHeaderText(headerText);
        alert.setContentText(contentText);

        alert.showAndWait();
    }

    private void showFatalErrorDialogAndShutdown(String title, Throwable e) {
        logger.severe(title + " " + e.getMessage() + StringUtil.getDetails(e));
        showAlertDialogAndWait(Alert.AlertType.ERROR, title, e.getMessage(), e.toString());
        Platform.exit();
        System.exit(1);
    }

    // ==================== Event Handling Code
    // =================================================================

    @Subscribe
    private void handleDataSavingExceptionEvent(DataSavingExceptionEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        showFileOperationAlertAndWait("Could not save data", "Could not save data to file", event.exception);
    }

    @Subscribe
    private void handleShowHelpEvent(ShowHelpRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.handleHelp();
    }

    @Subscribe
    public void handleAddTaskEvent(AddTaskEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, MESSAGE_TASK_ADDED));
        Task task = event.task;

        if (task.getTaskType().equals("floating")) {
            mainWindow.getTaskListPanel().scrollTo(logic.getFilteredTaskList().indexOf(task));
            mainWindow.getScheduleListPanel().clear();
        } else {
            mainWindow.getScheduleListPanel().scrollTo(logic.getFilteredScheduleList().indexOf(task));
            mainWindow.getTaskListPanel().clear();
        }
    }

    @Subscribe
    public void handleUpdateTaskEvent(UpdateTaskEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, MESSAGE_TASK_UPDATED));
        Task task = event.task;

        if (task.getTaskType().equals("floating")) {
            mainWindow.getTaskListPanel().scrollTo(logic.getFilteredTaskList().indexOf(task));
            mainWindow.getScheduleListPanel().clear();
        } else {
            mainWindow.getScheduleListPanel().scrollTo(logic.getFilteredScheduleList().indexOf(task));
            mainWindow.getTaskListPanel().clear();
        }
    }
    
    @Subscribe
    public void handleWhatNowChangedEvent(WhatNowChangedEvent abce) {
        mainWindow.getStatusPanel().postMessage("Number of ongoing tasks in schedule: " 
                + String.valueOf(logic.getFilteredScheduleList().size() 
                + "\n"
                + "Number of overdue tasks in schedule: " + String.valueOf(logic.getOverdueScheduleList().size())));
    }
}
```
###### \java\seedu\whatnow\ui\UiPart.java
``` java
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.layout.AnchorPane;
import javafx.stage.Modality;
import javafx.stage.Stage;
import seedu.whatnow.commons.core.EventsCenter;
import seedu.whatnow.commons.events.BaseEvent;
import seedu.whatnow.commons.util.AppUtil;

/**
 * Base class for UI parts. A 'UI part' represents a distinct part of the UI.
 * e.g. Windows, dialogs, panels, status bars, etc.
 */
public abstract class UiPart {

    /**
     * The primary stage for the UI Part.
     */
    protected Stage primaryStage;

    public UiPart() {

    }

    /**
     * Raises the event via {@link EventsCenter#post(BaseEvent)}
     * 
     * @param event
     */
    protected void raise(BaseEvent event) {
        EventsCenter.getInstance().post(event);
    }

    /**
     * Registers the object as an event handler at the {@link EventsCenter}
     * 
     * @param handler
     *            usually {@code this}
     */
    protected void registerAsAnEventHandler(Object handler) {
        EventsCenter.getInstance().registerHandler(handler);
    }

    /**
     * Override this method to receive the main Node generated while loading the
     * view from the .fxml file.
     * 
     * @param node
     */
    public abstract void setNode(Node node);

    /**
     * Override this method to return the name of the fxml file. e.g.
     * {@code "MainWindow.fxml"}
     * 
     * @return
     */
    public abstract String getFxmlPath();

    public void setStage(Stage primaryStage) {
        this.primaryStage = primaryStage;
    }

    /**
     * Creates a modal dialog.
     * 
     * @param title
     *            Title of the dialog.
     * @param parentStage
     *            The owner stage of the dialog.
     * @param scene
     *            The scene that will contain the dialog.
     * @return the created dialog, not yet made visible.
     */
    protected Stage createDialogStage(String title, Stage parentStage, Scene scene) {
        Stage dialogStage = new Stage();
        dialogStage.setTitle(title);
        dialogStage.initModality(Modality.WINDOW_MODAL);
        dialogStage.initOwner(parentStage);
        dialogStage.setScene(scene);
        return dialogStage;
    }

    /**
     * Sets the given image as the icon for the primary stage of this UI Part.
     * 
     * @param iconSource
     *            e.g. {@code "/images/help_icon.png"}
     */
    protected void setIcon(String iconSource) {
        primaryStage.getIcons().add(AppUtil.getImage(iconSource));
    }

    /**
     * Sets the given image as the icon for the given stage.
     * 
     * @param stage
     * @param iconSource
     *            e.g. {@code "/images/help_icon.png"}
     */
    protected void setIcon(Stage stage, String iconSource) {
        stage.getIcons().add(AppUtil.getImage(iconSource));
    }

    /**
     * Sets the placeholder for UI parts that reside inside another UI part.
     * 
     * @param placeholder
     */
    public void setPlaceholder(AnchorPane placeholder) {
        // Do nothing by default.
    }

    public Stage getPrimaryStage() {
        return primaryStage;
    }
}
```
###### \java\seedu\whatnow\ui\UiPartLoader.java
``` java
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.layout.AnchorPane;
import javafx.stage.Stage;
import seedu.whatnow.MainApp;

/**
 * A utility class to load UiParts from FXML files.
 */
public class UiPartLoader {
    private final static String FXML_FILE_FOLDER = "/view/";

    public static <T extends UiPart> T loadUiPart(Stage primaryStage, T controllerSeed) {
        return loadUiPart(primaryStage, null, controllerSeed);
    }

    /**
     * Returns the ui class for a specific UI Part.
     *
     * @param primaryStage
     *            The primary stage for the view.
     * @param placeholder
     *            The placeholder where the loaded Ui Part is added.
     * @param sampleUiPart
     *            The sample of the expected UiPart class.
     * @param <T>
     *            The type of the UiPart
     */
    public static <T extends UiPart> T loadUiPart(Stage primaryStage, AnchorPane placeholder, T sampleUiPart) {
        FXMLLoader loader = new FXMLLoader();
        loader.setLocation(MainApp.class.getResource(FXML_FILE_FOLDER + sampleUiPart.getFxmlPath()));
        Node mainNode = loadLoader(loader, sampleUiPart.getFxmlPath());
        UiPart controller = loader.getController();
        controller.setStage(primaryStage);
        controller.setPlaceholder(placeholder);
        controller.setNode(mainNode);
        return (T) controller;
    }

    /**
     * Returns the ui class for a specific UI Part.
     *
     * @param seedUiPart
     *            The UiPart object to be used as the ui.
     * @param <T>
     *            The type of the UiPart
     */

    public static <T extends UiPart> T loadUiPart(T seedUiPart) {
        FXMLLoader loader = new FXMLLoader();
        loader.setLocation(MainApp.class.getResource(FXML_FILE_FOLDER + seedUiPart.getFxmlPath()));
        loader.setController(seedUiPart);
        loadLoader(loader, seedUiPart.getFxmlPath());
        return seedUiPart;
    }

    private static Node loadLoader(FXMLLoader loader, String fxmlFileName) {
        try {
            return loader.load();
        } catch (Exception e) {
            String errorMessage = "FXML Load Error for " + fxmlFileName;
            throw new RuntimeException(errorMessage, e);
        }
    }

}
```
