# A0139772U
###### \java\seedu\whatnow\commons\core\UnmodifiableObservableList.java
``` java
package seedu.whatnow.commons.core;

import javafx.beans.InvalidationListener;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.transformation.FilteredList;
import javafx.collections.transformation.SortedList;

import java.text.Collator;
import java.util.*;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;

/**
 * Unmodifiable view of an observable list
 */
public class UnmodifiableObservableList<E> implements ObservableList<E> {

    public static final String MUTATION_OP_EXCEPTION_MESSAGE = "Attempted to modify an unmodifiable view";

    private final ObservableList<? extends E> backingList;

    public UnmodifiableObservableList(ObservableList<? extends E> backingList) {
        if (backingList == null) {
            throw new NullPointerException();
        }
        this.backingList = backingList;
    }
    
    @Override
    public final void addListener(ListChangeListener<? super E> listener) {
        backingList.addListener(listener);
    }

    @Override
    public final void removeListener(ListChangeListener<? super E> listener) {
        backingList.removeListener(listener);
    }

    @Override
    public final void addListener(InvalidationListener listener) {
        backingList.addListener(listener);
    }

    @Override
    public final void removeListener(InvalidationListener listener) {
        backingList.removeListener(listener);
    }

    @Override
    public final boolean addAll(Object... elements) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final boolean setAll(Object... elements) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final boolean setAll(Collection<? extends E> col) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }
    
    @Override
    public final boolean removeAll(Object... elements) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }
    
    @Override
    public final boolean retainAll(Object... elements) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final void remove(int from, int to) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }


    @Override
    public final FilteredList<E> filtered(Predicate<E> predicate) {
        return new FilteredList<>(this, predicate);
    }

    @Override
    public final SortedList<E> sorted(Comparator<E> comparator) {
        return new SortedList<>(this, comparator);
    }

    @SuppressWarnings("unchecked")
    @Override
    public final SortedList<E> sorted() {
        return sorted(Comparator.nullsFirst((o1, o2) -> {
            if (o1 instanceof Comparable) {
                return ((Comparable) o1).compareTo(o2);
            }
            return Collator.getInstance().compare(o1.toString(), o2.toString());
        }));
    }

    @Override
    public final int size() {
        return backingList.size();
    }

    @Override
    public final boolean isEmpty() {
        return backingList.isEmpty();
    }
    
    @Override
    public final boolean contains(Object o) {
        return backingList.contains(o);
    }
    
    @Override
    public final Iterator<E> iterator() {
        return new Iterator<E>() {
            private final Iterator<? extends E> i = backingList.iterator();

            public final boolean hasNext() {
                return i.hasNext();
            }
            public final E next() {
                return i.next();
            }
            public final void remove() {
                throw new UnsupportedOperationException();
            }
            @Override
            public final void forEachRemaining(Consumer<? super E> action) {
                // Use backing collection version
                i.forEachRemaining(action);
            }
        };
    }

    @Override
    public final Object[] toArray() {
        return backingList.toArray();
    }

    @Override
    public final <T> T[] toArray(T[] a) {
        return backingList.toArray(a);
    }

    @Override
    public final boolean add(E o) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }
    
    @Override
    public final boolean remove(Object o) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final boolean containsAll(Collection<?> c) {
        return backingList.containsAll(c);
    }

    @Override
    public final boolean addAll(Collection<? extends E> c) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final boolean addAll(int index, Collection<? extends E> c) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }
    
    @Override
    public final boolean removeAll(Collection<?> c) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }
    
    @Override
    public final boolean retainAll(Collection<?> c) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final void replaceAll(UnaryOperator<E> operator) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final void sort(Comparator<? super E> c) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }
    
    @Override
    public final void clear() {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    
    @Override
    public final boolean equals(Object o) {
        return o == this || backingList.equals(o);
    }

    @Override
    public final int hashCode() {
        return backingList.hashCode();
    }

    
    @Override
    public final E get(int index) {
        return backingList.get(index);
    }

    @SuppressWarnings("unchecked")
    @Override
    public final Object set(int index, Object element) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final void add(int index, Object element) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @Override
    public final E remove(int index) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }
    
    @Override
    public final int indexOf(Object o) {
        return backingList.indexOf(o);
    }
    
    @Override
    public final int lastIndexOf(Object o) {
        return backingList.lastIndexOf(o);
    }

    @Override
    public final ListIterator<E> listIterator() {
        return listIterator(0);
    }
    
    @Override
    public final ListIterator<E> listIterator(int index) {
        return new ListIterator<E>() {
            private final ListIterator<? extends E> i = backingList.listIterator(index);

            public final boolean hasNext() {
                return i.hasNext();
            }
            public final E next() {
                return i.next();
            }
            public final boolean hasPrevious() {
                return i.hasPrevious();
            }
            public final E previous() {
                return i.previous();
            }
            public final int nextIndex() {
                return i.nextIndex();
            }
            public final int previousIndex() {
                return i.previousIndex();
            }

            public final void remove() {
                throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
            }
            public final void set(E e) {
                throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
            }
            public final void add(E e) {
                throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
            }

            @Override
            public final void forEachRemaining(Consumer<? super E> action) {
                i.forEachRemaining(action);
            }
        };
    }

    @Override
    public final List<E> subList(int fromIndex, int toIndex) {
        return Collections.unmodifiableList(backingList.subList(fromIndex, toIndex));
    }

    @Override
    public final boolean removeIf(Predicate<? super E> filter) {
        throw new UnsupportedOperationException(MUTATION_OP_EXCEPTION_MESSAGE);
    }

    @SuppressWarnings("unchecked")
    @Override
    public final Stream<E> stream() {
        return (Stream<E>) backingList.stream();
    }
    
    @Override
    public final void forEach(Consumer<? super E> action) {
        backingList.forEach(action);
    }

}
```
###### \java\seedu\whatnow\commons\util\FxViewUtil.java
``` java
package seedu.whatnow.commons.util;

import javafx.scene.Node;
import javafx.scene.layout.AnchorPane;

/**
 * Contains utility methods for JavaFX views
 */
public class FxViewUtil {

    public static void applyAnchorBoundaryParameters(Node node, double left, double right, double top, double bottom) {
        AnchorPane.setBottomAnchor(node, bottom);
        AnchorPane.setLeftAnchor(node, left);
        AnchorPane.setRightAnchor(node, right);
        AnchorPane.setTopAnchor(node, top);
    }
}
```
###### \java\seedu\whatnow\logic\commands\AddCommand.java
``` java
package seedu.whatnow.logic.commands;

import java.text.ParseException;
import java.util.HashSet;
import java.util.Set;

import seedu.whatnow.commons.exceptions.IllegalValueException;
import seedu.whatnow.model.tag.Tag;
import seedu.whatnow.model.tag.UniqueTagList;
import seedu.whatnow.model.task.*;
import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Adds a task to WhatNow.
 */
public class AddCommand extends UndoAndRedo {

	public static final String COMMAND_WORD = "add";

	public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to WhatNow. \n"
			+ "Parameters: \"TASK_NAME\" [t/TAG]...\n"
	        + "Parameters: \"TASK_NAME\" [on/by/from] [today/tomorrow/DATE] [to] [today/tomorrow/DATE] [t/TAG]...\n"
			+ "Parameters: \"TASK_NAME\" [by/at/from] [TIME] [till/to] [TIME] [t/TAG]...\n"
			+ "Example: \n"
			+ COMMAND_WORD + " \"Buy groceries\" on 23/2/2017 t/highPriority\n"
			+ COMMAND_WORD + " \"Buy dinner\" at 6pm t/highPriority\n"
			+ COMMAND_WORD + " \"Lesson\" on 24/2/2017 from 8.30am to 4:30pm t/lowPriority\n"
			+ COMMAND_WORD + " \"Submit homework\" by tomorrow 12pm t/lowPriority\n";

	public static final String MESSAGE_SUCCESS = "New task added: %1$s";
	public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in WhatNow";
	private static final String STATUS_INCOMPLETE = "incomplete";

	private final Task toAdd;
	
```
###### \java\seedu\whatnow\logic\commands\DeleteCommand.java
``` java
package seedu.whatnow.logic.commands;

import seedu.whatnow.commons.core.Messages;
import seedu.whatnow.commons.core.UnmodifiableObservableList;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.Task;
import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Deletes a task identified using it's last displayed index from WhatNow.
 */
public class DeleteCommand extends UndoAndRedo {

	public static final String COMMAND_WORD = "delete";

	public static final String MESSAGE_USAGE = COMMAND_WORD
			+ ": Deletes the task identified by the index number used in the last task listing.\n"
			+ "Parameters: INDEX (must be a positive integer)\n"
			+ "Example: " + COMMAND_WORD + " 1";

	public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %1$s";

	private static final String TASK_TYPE_FLOATING = "todo";

	private final int targetIndex;
	private final String taskType;

	public DeleteCommand(String taskType, int targetIndex) {
		this.targetIndex = targetIndex;
		this.taskType = taskType;
	}


	@Override
	public CommandResult execute() {

		UnmodifiableObservableList<ReadOnlyTask> lastShownList;

		if (taskType.equals(TASK_TYPE_FLOATING)) {
			lastShownList = model.getCurrentFilteredTaskList();
		} else {
			lastShownList = model.getCurrentFilteredScheduleList();
		}
		if (lastShownList.size() < targetIndex) {
			indicateAttemptToExecuteIncorrectCommand();
			return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
		}
		ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);

		assert model != null;	 
		try {
			model.deleteTask(taskToDelete);
			model.getUndoStack().push(this);
			model.getDeletedStackOfTasks().push(taskToDelete);
		} catch (TaskNotFoundException tnfe) {
			assert false : "The target task cannot be missing";
		}
		return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));
	}

```
###### \java\seedu\whatnow\logic\commands\FindCommand.java
``` java
package seedu.whatnow.logic.commands;

import java.util.Set;

/**
 * Finds and lists all tasks in WhatNow whose name contains any of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks with"
            + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " Online quiz";

    private final Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList(keywords).size()
                + model.getFilteredScheduleList(keywords).size()));
    }
}
```
###### \java\seedu\whatnow\logic\commands\ListCommand.java
``` java
package seedu.whatnow.logic.commands;

/**
 * Lists all tasks in WhatNow to the user.
 */
public class ListCommand extends UndoAndRedo{

	public static final String COMMAND_WORD = "list";

	public static final String MESSAGE_SUCCESS = "Listed all tasks";

	public static final String MESSAGE_LIST_NOT_ENTERED = " No previous list command was entered";

	public static final String MESSAGE_LIST_NO_REDO_LIST = " No list command to redo";

	public static final String TASK_STATUS_DONE = "done";
	
	public static final String TASK_STATUS_COMPLETED = "completed";
	
	public static final String TASK_STATUS_ALL = "all";
	
	public static final String TASK_STATUS_INCOMPLETE = "incomplete";
	
	public static final String MESSAGE_USAGE = COMMAND_WORD 
			+ ": the task specified\n"
			+ "Parameters: done\n"
			+ "Examples: " + COMMAND_WORD + " done or " + COMMAND_WORD + " all or " + COMMAND_WORD;

	public String type;

	public ListCommand(String type) {
		this.type = type;
	}

	private void mapInputToCorrectArgumentForExecution() {
		if (type.equals(TASK_STATUS_DONE)) {
			type = TASK_STATUS_COMPLETED;
		} else if (type.equals(TASK_STATUS_ALL)) {
			type = TASK_STATUS_ALL;
		} else {
			type = TASK_STATUS_INCOMPLETE;
		}
	}

	@Override
	public CommandResult execute() {
		mapInputToCorrectArgumentForExecution();
		if (type.equals(TASK_STATUS_ALL)) {
			model.updateFilteredListToShowAll();
			model.updateFilteredScheduleListToShowAll();
			model.getUndoStack().push(this);
			model.getStackOfListTypes().push(TASK_STATUS_ALL);
		} else if (type.equals(TASK_STATUS_INCOMPLETE)) {
			model.updateFilteredListToShowAllIncomplete();
			model.updateFilteredScheduleListToShowAllIncomplete();
			model.getUndoStack().push(this);
			model.getStackOfListTypes().push(TASK_STATUS_INCOMPLETE);
		} else {
			model.updateFilteredListToShowAllCompleted();
			model.updateFilteredScheduleListToShowAllCompleted();
			model.getUndoStack().push(this);
			model.getStackOfListTypes().push(TASK_STATUS_COMPLETED);
		}
		return new CommandResult(MESSAGE_SUCCESS);
	}
```
###### \java\seedu\whatnow\logic\commands\MarkDoneCommand.java
``` java
package seedu.whatnow.logic.commands;

import seedu.whatnow.commons.core.Messages;
import seedu.whatnow.commons.core.UnmodifiableObservableList;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Marks a task identified using it's last displayed index from WhatNow as completed.
 */
public class MarkDoneCommand extends UndoAndRedo {


	public static final String COMMAND_WORD = "done";

	public static final String MESSAGE_USAGE = COMMAND_WORD
			+ ": Mark the task identified by the index number used in the last task listing as completed.\n"
			+ "Parameters: TODO/SCHEDULE INDEX (must be a positive integer)\n"
			+ "Example: " + COMMAND_WORD + " todo 1\n"
			+ "Example: " + COMMAND_WORD + " schedule 1";

	public static final String MESSAGE_MARK_TASK_SUCCESS = "Task marked as completed: %1$s";
	public static final String MESSAGE_MARK_TASK_FAIL = "Unable to mark task as complete";
	private static final String TASK_TYPE_FLOATING = "todo";

	public final String taskType;
	public final int targetIndex;

	public MarkDoneCommand(String taskType, int targetIndex) {
		this.taskType = taskType;
		this.targetIndex = targetIndex;
	}


	@Override
	public CommandResult execute() {
		UnmodifiableObservableList<ReadOnlyTask> lastShownList;
		if (taskType.equals(TASK_TYPE_FLOATING)) {
			model.updateFilteredListToShowAllIncomplete();
			lastShownList = model.getCurrentFilteredTaskList();
		} else {
			model.updateFilteredScheduleListToShowAllIncomplete();
			lastShownList = model.getCurrentFilteredScheduleList();
		}

		if (lastShownList.size() < targetIndex) {
			indicateAttemptToExecuteIncorrectCommand();
			return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
		}

		ReadOnlyTask taskToMark = lastShownList.get(targetIndex - 1);

		try {
			model.markTask(taskToMark);
			model.getUndoStack().push(this);
			model.getStackOfMarkDoneTask().push(taskToMark);
			model.getStackOfMarkDoneTaskTaskType().push(taskType);
		} catch (TaskNotFoundException tnfe) {
			return new CommandResult(String.format(MESSAGE_MARK_TASK_FAIL));
		}

		return new CommandResult(String.format(MESSAGE_MARK_TASK_SUCCESS, taskToMark));
	}
```
###### \java\seedu\whatnow\logic\commands\UpdateCommand.java
``` java
    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList;
        
        if (taskType.equals(TASK_TYPE_TODO) || taskType.equalsIgnoreCase(TASK_TYPE_FLOATING)) {
            lastShownList = model.getCurrentFilteredTaskList();
        } else {
            lastShownList = model.getCurrentFilteredScheduleList();
        }

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToUpdate = lastShownList.get(targetIndex - ONE);
        updateTheCorrectField(taskToUpdate);
        
        try {
            model.updateTask(taskToUpdate, toUpdate);
            model.getOldTask().push(taskToUpdate);
            model.getNewTask().push(toUpdate);
            model.getUndoStack().push(this);
        } catch (TaskNotFoundException tnfe) {
            assert false : "The target task cannot be missing";
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }
        return new CommandResult(String.format(MESSAGE_UPDATE_TASK_SUCCESS, "\nFrom: " + taskToUpdate + " \nTo: " + toUpdate));
    }

```
###### \java\seedu\whatnow\logic\Logic.java
``` java
package seedu.whatnow.logic;

import java.text.ParseException;

import javafx.collections.ObservableList;
import seedu.whatnow.logic.commands.CommandResult;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * API of the Logic component
 */
public interface Logic {
    /**
     * Executes the command and returns the result.
     * @param commandText The command as entered by the user.
     * @return the result of the command execution.
     * @throws ParseException 
     * @throws TaskNotFoundException 
     * @throws DuplicateTaskException 
     */
    CommandResult execute(String commandText) throws ParseException, DuplicateTaskException, TaskNotFoundException;

    /** Returns the filtered list of tasks */
    ObservableList<ReadOnlyTask> getFilteredTaskList();
    
    /** Returns the filtered list of schedule */
    ObservableList<ReadOnlyTask> getFilteredScheduleList();

}
```
###### \java\seedu\whatnow\logic\LogicManager.java
``` java
package seedu.whatnow.logic;

import javafx.collections.ObservableList;
import seedu.whatnow.commons.core.ComponentManager;
import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.logic.commands.Command;
import seedu.whatnow.logic.commands.CommandResult;
import seedu.whatnow.logic.parser.Parser;
import seedu.whatnow.model.Model;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;
import seedu.whatnow.storage.Storage;

import java.text.ParseException;
import java.util.logging.Logger;

/**
 * The main LogicManager of the app.
 */
public class LogicManager extends ComponentManager implements Logic {
    private final Logger logger = LogsCenter.getLogger(LogicManager.class);

    private final Model model;
    private final Parser parser;

    public LogicManager(Model model, Storage storage) {
        this.model = model;
        this.parser = new Parser();
    }

    @Override
    public CommandResult execute(String commandText) throws ParseException, DuplicateTaskException, TaskNotFoundException {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        Command command = parser.parseCommand(commandText);
        command.setData(model);
        return command.execute();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return model.getFilteredTaskList();
    }
    
    @Override
    public ObservableList<ReadOnlyTask> getFilteredScheduleList() {
        return model.getFilteredScheduleList();
    }
}
```
###### \java\seedu\whatnow\model\Model.java
``` java
package seedu.whatnow.model;

import java.io.IOException;
import java.nio.file.Path;
import java.util.Set;
import java.util.Stack;

import seedu.whatnow.commons.core.Config;
import seedu.whatnow.commons.core.UnmodifiableObservableList;
import seedu.whatnow.commons.exceptions.DataConversionException;
import seedu.whatnow.logic.commands.Command;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.Task;
import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * The API of the Model component.
 */
public interface Model {
    
```
###### \java\seedu\whatnow\model\Model.java
``` java
    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getCurrentFilteredTaskList();
    
    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList();
    
    /** Returns the filtered task list with filter keyword as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList(Set<String> key);

    /** Updates the filter of the filtered task list to show all tasks */
    void updateFilteredListToShowAll();
    
    /** Updates the filter of the filtered task list to show all ongoing tasks */
    void updateFilteredListToShowAllIncomplete();
    
    /** Updates the filter of the filtered task list to show all completed tasks */
    void updateFilteredListToShowAllCompleted();

    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredTaskList(Set<String> keywords);
    
    /** Updates the filter of the filtered task list to show only task of a specific status specified by the keyword */
    void updateFilteredListToShowAllByStatus(Set<String> keyword);
    
    /** Update the given task */
    void updateTask(ReadOnlyTask old, Task toUpdate) throws TaskNotFoundException, DuplicateTaskException;

    /** Mark the given task as completed */
    void markTask(ReadOnlyTask target) throws TaskNotFoundException;
   
    /** Mark the given task as incomplete */
	void unMarkTask(ReadOnlyTask target) throws TaskNotFoundException;
	
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
package seedu.whatnow.model;

import javafx.collections.FXCollections;
import javafx.collections.transformation.FilteredList;
import javafx.collections.transformation.SortedList;
import seedu.whatnow.commons.core.ComponentManager;
import seedu.whatnow.commons.core.Config;
import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.core.UnmodifiableObservableList;
import seedu.whatnow.commons.events.model.AddTaskEvent;
import seedu.whatnow.commons.events.model.ConfigChangedEvent;
import seedu.whatnow.commons.events.model.UpdateTaskEvent;
import seedu.whatnow.commons.events.model.WhatNowChangedEvent;
import seedu.whatnow.commons.exceptions.DataConversionException;
import seedu.whatnow.commons.util.StringUtil;
import seedu.whatnow.logic.commands.Command;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.Task;
import seedu.whatnow.model.task.UniqueTaskList;
import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

import java.io.IOException;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.Stack;
import java.util.logging.Logger;

/**
 * Represents the in-memory model of the WhatNow data.
 * All changes to any model should be synchronized.
 */
public class ModelManager extends ComponentManager implements Model {

    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);
    private static final String TASK_TYPE_FLOATING = "floating";
    private static final String TASK_TYPE_NOT_FLOATING = "not_floating";
    private static final String TASK_STATUS_COMPLETED = "completed";
    private static final String TASK_STATUS_INCOMPLETE = "incomplete";

    private final WhatNow whatNow;
    private final FilteredList<Task> filteredTasks;
    private FilteredList<Task> filteredSchedules;
    private final Stack<Command> stackOfUndo;
    private final Stack<Command> stackOfRedo;
    private final Stack<ReadOnlyTask> stackOfOldTask;
    private final Stack<ReadOnlyTask> stackOfNewTask;
    private final Stack<ReadOnlyWhatNow> stackOfWhatNow;
    private final Stack<ReadOnlyTask> stackOfDeletedTasks;
    private final Stack<ReadOnlyTask> stackOfDeletedTasksRedo;
    private final Stack<ReadOnlyTask> stackOfDeletedTasksAdd;
    private final Stack<ReadOnlyTask> stackOfDeletedTasksAddRedo;
    private final Stack<ReadOnlyTask> stackOfMarkDone;
    private final Stack<ReadOnlyTask> stackOfMarkUndone;
    private final Stack<String> stackOfMarkDoneTaskTypes;
    private final Stack<String> stackOfMarkUndoneTaskTypes;
    private final Stack<String> stackOfListTypes;
    private final Stack<String> stackOfListTypesRedo;
    
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public synchronized void markTask(ReadOnlyTask target) throws TaskNotFoundException {
        whatNow.markTask(target);
        indicateWhatNowChanged();
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getAllTaskTypeList() {
        filteredTasks.setPredicate(null);
        return new UnmodifiableObservableList<>(filteredTasks);
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        updateFilteredListToShowAllIncomplete();
        return new UnmodifiableObservableList<>(filteredTasks);
    }
    
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getCurrentFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList(Set<String> keyword) {
        updateFilteredTaskList(keyword);
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    @Override
    public void updateFilteredListToShowAll() {
        String[] taskType = {TASK_TYPE_FLOATING};
        Set<String> keyword = new HashSet<>(Arrays.asList(taskType));
        FXCollections.sort(filteredTasks.getSource());
        updateFilteredTaskList(new PredicateExpression(new TaskTypeQualifier(keyword)));
    }

    @Override
    public void updateFilteredListToShowAllIncomplete() {
        FXCollections.sort(filteredTasks.getSource());
        filteredTasks.setPredicate(p -> {
            if ((p.getTaskType().equals((TASK_TYPE_FLOATING)) && (p.getStatus().equals(TASK_STATUS_INCOMPLETE)))) {
                return true;
            } else {
                return false;
            }
        });
    }

    @Override
    public void updateFilteredListToShowAllCompleted() {
        FXCollections.sort(filteredTasks.getSource());
        filteredTasks.setPredicate(p -> {
            if ((p.getTaskType().equals((TASK_TYPE_FLOATING)) && (p.getStatus().equals(TASK_STATUS_COMPLETED)))) {
                return true;
            } else {
                return false;
            }
        });
    }

    @Override
    public void updateFilteredListToShowAllByStatus(Set<String> keyword) {
        updateFilteredTaskList(new PredicateExpression(new TaskStatusQualifier(keyword)));
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords){
        filteredTasks.setPredicate(p -> {
            if ((keywords.stream()
                    .filter(key -> StringUtil.containsIgnoreCase(p.getName().fullName, key))
                    .findAny()
                    .isPresent()) && p.getTaskType().equals(TASK_TYPE_FLOATING))  {
                return true;
            } else {
                return false;
            }
        });
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }
    
    //=========== Filtered Schedule List Accessors ===============================================================
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override 
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredScheduleList() {
        updateFilteredScheduleListToShowAllIncomplete();
        return new UnmodifiableObservableList<>(filteredSchedules);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getCurrentFilteredScheduleList() {
        return new UnmodifiableObservableList<>(filteredSchedules);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredScheduleList(Set<String> keyword) {
        updateFilteredScheduleList(keyword);
        return new UnmodifiableObservableList<>(filteredSchedules);
    }

    @Override
    public void updateFilteredScheduleListToShowAll() {
        String[] taskType = {TASK_TYPE_NOT_FLOATING};
        Set<String> keyword = new HashSet<>(Arrays.asList(taskType));
        FXCollections.sort(filteredSchedules.getSource());
        updateFilteredScheduleList(new PredicateExpression(new TaskTypeQualifier(keyword)));
    }

    @Override
    public void updateFilteredScheduleListToShowAllIncomplete() {
        FXCollections.sort(filteredSchedules.getSource());
        filteredSchedules.setPredicate(p -> {
            if ((p.getTaskType().equals((TASK_TYPE_NOT_FLOATING)) && (p.getStatus().equals(TASK_STATUS_INCOMPLETE)))) {
                return true;
            } else {
                return false;
            }
        });
    }

    @Override
    public void updateFilteredScheduleListToShowAllCompleted() {
        FXCollections.sort(filteredSchedules.getSource());
        filteredSchedules.setPredicate(p -> {
            if ((p.getTaskType().equals((TASK_TYPE_NOT_FLOATING)) && (p.getStatus().equals(TASK_STATUS_COMPLETED)))) {
                return true;
            } else {
                return false;
            }
        });
    }

    @Override
    public void updateFilteredScheduleListToShowAllByStatus(Set<String> keyword) {
        updateFilteredScheduleList(new PredicateExpression(new TaskStatusQualifier(keyword)));
    }

    @Override
    public void updateFilteredScheduleList(Set<String> keywords){
        filteredSchedules.setPredicate(p -> {
            if ((keywords.stream()
                    .filter(key -> StringUtil.containsIgnoreCase(p.getName().fullName, key))
                    .findAny()
                    .isPresent()) && p.getTaskType().equals(TASK_TYPE_NOT_FLOATING))  {
                return true;
            } else {
                return false;
            }
        });
    }

    private void updateFilteredScheduleList(Expression expression) {
        filteredSchedules.setPredicate(expression::satisfies);
    }

    //========== Inner classes/interfaces used for filtering ==================================================
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsIgnoreCase(task.getName().fullName, keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    private class TaskStatusQualifier implements Qualifier {
        private Set<String> status;

        TaskStatusQualifier(Set<String> status) {
            this.status = status;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return status.stream()
                    .filter(keyword -> StringUtil.containsIgnoreCase(task.getStatus(), keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "Status=" + String.join(", ", status);
        }
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    private class TaskTypeQualifier implements Qualifier {
        private Set<String> taskType;

        TaskTypeQualifier(Set<String> taskType) {
            this.taskType = taskType;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return taskType.stream()
                    .filter(keyword -> StringUtil.containsIgnoreCase(task.getTaskType(), keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "TaskType=" + String.join(", ", taskType);
        }
    }
}
```
###### \java\seedu\whatnow\model\task\ReadOnlyTask.java
``` java
package seedu.whatnow.model.task;

import seedu.whatnow.model.tag.UniqueTagList;

/**
 * A read-only immutable interface for a Task in the whatnow.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyTask {

    Name getName();
    String getTaskDate();
    String getStartDate();
    String getEndDate();
    String getTaskTime();
    String getStartTime();
    String getEndTime();

    /**
     * The returned TagList is a deep copy of the internal TagList,
     * changes on the returned list will not affect the task's internal tags.
     */
    UniqueTagList getTags();
    
    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        if (isBothFloating(other)) {
            return other == this // short circuit if same object
                    || (other != null // this is first to avoid NPE below
                    && other.getName().equals(this.getName())
                    && other.getTags().equals(this.getTags()));
        } else if (isBothDeadline(other)) {
            if (other.getTaskTime() == null && this.getTaskTime() == null) {
                return other == this // short circuit if same object
                        || (other != null // this is first to avoid NPE below
                        && other.getName().equals(this.getName())
                        && other.getTaskDate().equals(this.getTaskDate())
                        && other.getTags().equals(this.getTags()));
            } else if (other.getTaskTime() != null && this.getTaskTime() != null) {
                return other == this // short circuit if same object
                        || (other != null // this is first to avoid NPE below
                        && other.getName().equals(this.getName())
                        && other.getTaskDate().equals(this.getTaskDate())
                        && other.getTags().equals(this.getTags())
                        && other.getTaskTime().equals(this.getTaskTime()));
            } else {
                return false;
            }
        } else if (isBothEvent(other)) {
            if (other.getStartTime() == null && this.getStartTime() == null) {
                return other == this // short circuit if same object
                        || (other != null // this is first to avoid NPE below
                        && other.getName().equals(this.getName())
                        && other.getStartDate().equals(this.getStartDate())
                        && other.getEndDate().equals(this.getEndDate())
                        && other.getTags().equals(this.getTags()));               
            } else if (other.getStartTime() != null && this.getStartTime() != null) {
                return other == this // short circuit if same object
                        || (other != null // this is first to avoid NPE below
                        && other.getName().equals(this.getName())
                        && other.getStartDate().equals(this.getStartDate())
                        && other.getEndDate().equals(this.getEndDate())
                        && other.getStartTime().equals(this.getStartTime())
                        && other.getEndTime().equals(this.getEndTime())
                        && other.getTags().equals(this.getTags()));             
            } else {
                return false;
            }
        } else {
            return false;
        }
    }
    
    default boolean isBothFloating(ReadOnlyTask task) {
        return this.getTaskDate() == null && task.getTaskDate() == null
                && this.getStartDate() == null && task.getStartDate() == null;
    }
    
    default boolean isBothDeadline(ReadOnlyTask task) {
        return this.getTaskDate() != null && task.getTaskDate() != null
                && this.getStartDate() == null && task.getStartDate() == null;
    }
    
    default boolean isBothEvent(ReadOnlyTask task) {
        return this.getTaskDate() == null && task.getTaskDate() == null
                && this.getStartDate() != null && task.getStartDate() != null;
    }
    
    /**
     * Return the status of the task.
     * @return
     */
    String getStatus();
    
    /**
     * Return the task type of the task.
     * @return
     */
    String getTaskType();
    
```
###### \java\seedu\whatnow\model\task\ReadOnlyTask.java
``` java
    /**
     * Returns a string representation of this Task's tags
     */
    default String tagsString() {
        final StringBuffer buffer = new StringBuffer();
        final String separator = ", ";
        getTags().forEach(tag -> buffer.append(tag).append(separator));
        if (buffer.length() == 0) {
            return "";
        } else {
            return buffer.substring(0, buffer.length() - separator.length());
        }
    }
}
```
###### \java\seedu\whatnow\model\task\Task.java
``` java
package seedu.whatnow.model.task;

import java.util.Comparator;
import java.util.Objects;

import seedu.whatnow.commons.util.CollectionUtil;
import seedu.whatnow.model.tag.UniqueTagList;

/**
 * Represents a Task in WhatNow.
 * Guarantees: details are present and not null, field values are validated.
 */
public class Task implements ReadOnlyTask, Comparable<Task> {

    private Name name;
    private String taskDate;
    private String startDate;
    private String endDate;
    private String taskTime;
    private String startTime;
    private String endTime;
    private UniqueTagList tags;
    private String status;
    private String taskType;
    
    private static final String FLOATING = "floating";
    private static final String NOT_FLOATING = "not_floating";
    private static final int COMPARE_TO_IS_EQUAL = 0;
    private static final int COMPARE_TO_IS_NOT_EQUAL = 0;
    
    public Task() {
        
    }
    
```
###### \java\seedu\whatnow\model\task\Task.java
``` java
    public int compareTo(Task task) {
        if (isBothFloating(task)) {
            return COMPARE_TO_IS_EQUAL;
        } else if (isBothDeadline(task)) {
            if (this.taskDate.equals(task.taskDate)) {
                if (this.taskTime == null && task.taskTime == null) {
                    return COMPARE_TO_IS_EQUAL;
                } else if (this.taskTime != null && task.taskTime != null) {
                    if (this.taskTime.equals(task.taskTime)) {
                        return COMPARE_TO_IS_EQUAL;
                    } else {
                        return this.taskTime.compareToIgnoreCase(task.taskTime);
                    }
                } else {
                    return COMPARE_TO_IS_NOT_EQUAL;
                }
            } else {
                return this.taskDate.compareToIgnoreCase(task.taskDate);
            }
        } else if (isBothEvent(task)) {
            if (this.startDate.equals(task.startDate)) {
                if (this.getStartTime() == null && task.getStartTime() == null) {
                    return COMPARE_TO_IS_EQUAL;
                } else if (this.startTime != null && task.startTime != null) {
                    if (this.startTime.equals(task.startTime) && this.endTime.equals(task.endTime)) {
                        return COMPARE_TO_IS_EQUAL;
                    } else if (this.startTime.equals(task.startTime) && !this.endTime.equals(task.endTime)){
                        return this.endTime.compareToIgnoreCase(task.endDate);
                    } else {
                        return this.startTime.compareToIgnoreCase(task.startTime);
                    }
                } else {
                    return COMPARE_TO_IS_NOT_EQUAL;
                }
            } else {
                return this.startDate.compareToIgnoreCase(task.startDate);
            }
        } else {
            return COMPARE_TO_IS_EQUAL;
        }
    }
    
    private boolean isBothFloating(Task task) {
        return this.taskDate == null && task.taskDate == null
                && this.startDate == null && task.startDate == null;
    }
    
    private boolean isBothDeadline(Task task) {
        return this.taskDate != null && task.taskDate != null
                && this.startDate == null && task.startDate == null;
    }
    
    private boolean isBothEvent(Task task) {
        return this.taskDate == null && task.taskDate == null
                && this.startDate != null && task.startDate != null;
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, taskDate, startDate, endDate, taskTime, startTime, endTime, tags, status, taskType);
    }

    @Override
    public String toString() {
        return getAsText();
    }

}
```
###### \java\seedu\whatnow\model\task\UniqueTaskList.java
``` java
package seedu.whatnow.model.task;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import seedu.whatnow.commons.exceptions.DuplicateDataException;
import seedu.whatnow.commons.util.CollectionUtil;

import java.util.*;

/**
 * A list of tasks that enforces uniqueness between its elements and does not allow nulls.
 *
 * Supports a minimal set of list operations.
 *
 * @see Task#equals(Object)
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueTaskList implements Iterable<Task> {

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicateTaskException extends DuplicateDataException {
        protected DuplicateTaskException() {
            super("Operation would result in duplicate tasks");
        }
    }

    /**
     * Signals that an operation targeting a specified task in the list would fail because
     * there is no such matching task in the list.
     */
    public static class TaskNotFoundException extends Exception {}

    public static class NoPrevCommandException extends Exception {
    	public  NoPrevCommandException() {
    		super("No previous Command was found");
    	}
    }
    
    private ObservableList<Task> internalList = FXCollections.observableArrayList();
    
 //   private Stack<Task[]> reqStack = new Stack<>();
    
    //private Task[] array = new Task[];
    /**
     * Constructs empty TaskList.
     */
    public UniqueTaskList() {}

    /**
     * Returns true if the list contains an equivalent task as the given argument.
     */
    public boolean contains(ReadOnlyTask toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Adds a task to the list.
     *
     * @throws DuplicateTaskException if the task to add is a duplicate of an existing task in the list.
     */
    public void add(Task toAdd) throws DuplicateTaskException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTaskException();
        }
        
        internalList.add(toAdd);
    }

    /**
     * Removes the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean remove(ReadOnlyTask toRemove) throws TaskNotFoundException {
        assert toRemove != null;
        final boolean taskFoundAndDeleted = internalList.remove(toRemove);
        if (!taskFoundAndDeleted) {
            throw new TaskNotFoundException();
        }
        return taskFoundAndDeleted;
    }
    
```
###### \java\seedu\whatnow\model\task\UniqueTaskList.java
``` java
    /**
     * Mark the equivalent task from the list as completed.
     */
    public boolean mark(ReadOnlyTask target) throws TaskNotFoundException {
        assert target!= null;
        final boolean taskFoundAndMarked = internalList.contains(target);
        if (!taskFoundAndMarked) {
            throw new TaskNotFoundException();
        }
        internalList.get(internalList.indexOf(target)).setStatus("completed");
        internalList.set(internalList.indexOf(target), internalList.get(internalList.indexOf(target)));
        return taskFoundAndMarked;
    }
    
```
###### \java\seedu\whatnow\storage\JsonUserPrefsStorage.java
``` java
import java.io.File;
import java.io.IOException;
import java.util.Optional;
import java.util.logging.Logger;

import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.exceptions.DataConversionException;
import seedu.whatnow.commons.util.FileUtil;
import seedu.whatnow.model.UserPrefs;

/**
 * A class to access UserPrefs stored in the hard disk as a json file
 */
public class JsonUserPrefsStorage implements UserPrefsStorage{

    private static final Logger logger = LogsCenter.getLogger(JsonUserPrefsStorage.class);

    private String filePath;

    public JsonUserPrefsStorage(String filePath){
        this.filePath = filePath;
    }

    @Override
    public Optional<UserPrefs> readUserPrefs() throws DataConversionException, IOException {
        return readUserPrefs(filePath);
    }

    @Override
    public void saveUserPrefs(UserPrefs userPrefs) throws IOException {
        saveUserPrefs(userPrefs, filePath);
    }

    /**
     * Similar to {@link #readUserPrefs()}
     * @param prefsFilePath location of the data. Cannot be null.
     * @throws DataConversionException if the file format is not as expected.
     */
    public Optional<UserPrefs> readUserPrefs(String prefsFilePath) throws DataConversionException {
        assert prefsFilePath != null;

        File prefsFile = new File(prefsFilePath);

        if (!prefsFile.exists()) {
            logger.info("Prefs file "  + prefsFile + " not found");
            return Optional.empty();
        }

        UserPrefs prefs;

        try {
            prefs = FileUtil.deserializeObjectFromJsonFile(prefsFile, UserPrefs.class);
        } catch (IOException e) {
            logger.warning("Error reading from prefs file " + prefsFile + ": " + e);
            throw new DataConversionException(e);
        }

        return Optional.of(prefs);
    }

    /**
     * Similar to {@link #saveUserPrefs(UserPrefs)}
     * @param prefsFilePath location of the data. Cannot be null.
     */
    public void saveUserPrefs(UserPrefs userPrefs, String prefsFilePath) throws IOException {
        assert userPrefs != null;
        assert prefsFilePath != null;

        FileUtil.serializeObjectToJsonFile(new File(prefsFilePath), userPrefs);
    }
}
```
###### \java\seedu\whatnow\ui\CommandBox.java
``` java
import com.google.common.eventbus.Subscribe;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.SplitPane;
import javafx.scene.control.TextField;
import javafx.scene.layout.AnchorPane;
import javafx.stage.Stage;
import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.events.ui.IncorrectCommandAttemptedEvent;
import seedu.whatnow.commons.util.FxViewUtil;
import seedu.whatnow.logic.Logic;
import seedu.whatnow.logic.commands.*;
import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

import java.text.ParseException;
import java.util.logging.Logger;

public class CommandBox extends UiPart {
    private final Logger logger = LogsCenter.getLogger(CommandBox.class);
    private static final String FXML = "CommandBox.fxml";

    private AnchorPane placeHolderPane;
    private AnchorPane commandPane;
    private ResultDisplay resultDisplay;
    String previousCommandTest;

    private Logic logic;

    @FXML
    private TextField commandTextField;
    private CommandResult mostRecentResult;

    public static CommandBox load(Stage primaryStage, AnchorPane commandBoxPlaceholder,
            ResultDisplay resultDisplay, Logic logic) {
        CommandBox commandBox = UiPartLoader.loadUiPart(primaryStage, commandBoxPlaceholder, new CommandBox());
        commandBox.configure(resultDisplay, logic);
        commandBox.addToPlaceholder();
        return commandBox;
    }

    public void configure(ResultDisplay resultDisplay, Logic logic) {
        this.resultDisplay = resultDisplay;
        this.logic = logic;
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(commandTextField);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandTextField, 0.0, 0.0, 0.0, 0.0);
    }

    @Override
    public void setNode(Node node) {
        commandPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }


    @FXML
    private void handleCommandInputChanged() throws ParseException, DuplicateTaskException, TaskNotFoundException {
        //Take a copy of the command text
        previousCommandTest = commandTextField.getText();

        /* We assume the command is correct. If it is incorrect, the command box will be changed accordingly
         * in the event handling code {@link #handleIncorrectCommandAttempted}
         */
        setStyleToIndicateCorrectCommand();
        mostRecentResult = logic.execute(previousCommandTest);
        resultDisplay.postMessage(mostRecentResult.feedbackToUser);
        
        logger.info("Result: " + mostRecentResult.feedbackToUser);
    }


    /**
     * Sets the command box style to indicate a correct command.
     */
    private void setStyleToIndicateCorrectCommand() {
        commandTextField.getStyleClass().remove("error");
        commandTextField.setText("");
    }

    @Subscribe
    private void handleIncorrectCommandAttempted(IncorrectCommandAttemptedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event,"Invalid command: " + previousCommandTest));
        setStyleToIndicateIncorrectCommand();
        restoreCommandText();
    }

    /**
     * Restores the command box text to the previously entered command
     */
    private void restoreCommandText() {
        commandTextField.setText(previousCommandTest);
    }

    /**
     * Sets the command box style to indicate an error
     */
    private void setStyleToIndicateIncorrectCommand() {
        commandTextField.getStyleClass().add("error");
    }

}
```
###### \java\seedu\whatnow\ui\MainWindow.java
``` java
import javafx.fxml.FXML;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCombination;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;
import javafx.stage.Stage;
import seedu.whatnow.commons.core.Config;
import seedu.whatnow.commons.core.GuiSettings;
import seedu.whatnow.commons.events.ui.ExitAppRequestEvent;
import seedu.whatnow.logic.Logic;
import seedu.whatnow.model.UserPrefs;
import seedu.whatnow.model.task.ReadOnlyTask;

/**
 * The Main Window. Provides the basic application layout containing
 * a menu bar and space where other JavaFX elements can be placed.
 */
public class MainWindow extends UiPart {

    private static final String ICON = "/images/whatnow_32.png";
    private static final String FXML = "MainWindow.fxml";
    public static final int MIN_HEIGHT = 600;
    public static final int MIN_WIDTH = 450;

    private Logic logic;

    // Independent Ui parts residing in this Ui container
    private ScheduleListPanel scheduleListPanel;
    private TaskListPanel taskListPanel;
    private ResultDisplay resultDisplay;
    private StatusBarFooter statusBarFooter;
    private CommandBox commandBox;
    private Config config;
    private UserPrefs userPrefs;

    // Handles to elements of this Ui container
    private VBox rootLayout;
    private Scene scene;

    private String whatNowName;

    @FXML
    private AnchorPane scheduleListPlaceholder;

    @FXML
    private AnchorPane commandBoxPlaceholder;

    @FXML
    private MenuItem helpMenuItem;

    @FXML
    private AnchorPane taskListPanelPlaceholder;

    @FXML
    private AnchorPane resultDisplayPlaceholder;

    @FXML
    private AnchorPane statusbarPlaceholder;
    
    public MainWindow() {
        super();
    }

    @Override
    public void setNode(Node node) {
        rootLayout = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    public static MainWindow load(Stage primaryStage, Config config, UserPrefs prefs, Logic logic) {

        MainWindow mainWindow = UiPartLoader.loadUiPart(primaryStage, new MainWindow());
        mainWindow.configure(config.getAppTitle(), config.getWhatNowName(), config, prefs, logic);
        return mainWindow;
    }

    private void configure(String appTitle, String whatNowName, Config config, UserPrefs prefs,
                           Logic logic) {

        //Set dependencies
        this.logic = logic;
        this.whatNowName = whatNowName;
        this.config = config;
        this.userPrefs = prefs;

        //Configure the UI
        setTitle(appTitle);
        setIcon(ICON);
        setWindowMinSize();
        setWindowDefaultSize(prefs);
        
        scene = new Scene(rootLayout);
        primaryStage.setScene(scene);

        setAccelerators();
    }

    private void setAccelerators() {
        helpMenuItem.setAccelerator(KeyCombination.valueOf("F1"));
    }

    void fillInnerParts() {
        scheduleListPanel = ScheduleListPanel.load(primaryStage, getScheduleListPlaceholder(), logic.getFilteredScheduleList());
        taskListPanel = TaskListPanel.load(primaryStage, getTaskListPlaceholder(), logic.getFilteredTaskList());
        resultDisplay = ResultDisplay.load(primaryStage, getResultDisplayPlaceholder());
        statusBarFooter = StatusBarFooter.load(primaryStage, getStatusbarPlaceholder(), config.getWhatNowFilePath());
        commandBox = CommandBox.load(primaryStage, getCommandBoxPlaceholder(), resultDisplay, logic);
    }

    private AnchorPane getCommandBoxPlaceholder() {
        return commandBoxPlaceholder;
    }

    private AnchorPane getStatusbarPlaceholder() {
        return statusbarPlaceholder;
    }

    private AnchorPane getResultDisplayPlaceholder() {
        return resultDisplayPlaceholder;
    }

    public AnchorPane getTaskListPlaceholder() {
        return taskListPanelPlaceholder;
    }
    
    private AnchorPane getScheduleListPlaceholder() {
        return scheduleListPlaceholder;
    }

    public void hide() {
        primaryStage.hide();
    }

    private void setTitle(String appTitle) {
        primaryStage.setTitle(appTitle);
    }

    /**
     * Sets the default size based on user preferences.
     */
    protected void setWindowDefaultSize(UserPrefs prefs) {
        primaryStage.setHeight(prefs.getGuiSettings().getWindowHeight());
        primaryStage.setWidth(prefs.getGuiSettings().getWindowWidth());
        if (prefs.getGuiSettings().getWindowCoordinates() != null) {
            primaryStage.setX(prefs.getGuiSettings().getWindowCoordinates().getX());
            primaryStage.setY(prefs.getGuiSettings().getWindowCoordinates().getY());
        }
    }

    private void setWindowMinSize() {
        primaryStage.setMinHeight(MIN_HEIGHT);
        primaryStage.setMinWidth(MIN_WIDTH);
    }

    /**
     * Returns the current size and the position of the main Window.
     */
    public GuiSettings getCurrentGuiSetting() {
        return new GuiSettings(primaryStage.getWidth(), primaryStage.getHeight(),
                (int) primaryStage.getX(), (int) primaryStage.getY());
    }

    @FXML
    public void handleHelp() {
        HelpWindow helpWindow = HelpWindow.load(primaryStage);
        helpWindow.show();
    }

    public void show() {
        primaryStage.show();
    }

    /**
     * Closes the application.
     */
    @FXML
    private void handleExit() {
        raise(new ExitAppRequestEvent());
    }

    public TaskListPanel getTaskListPanel() {
        return this.taskListPanel;
    }
    
    public ScheduleListPanel getScheduleListPanel() {
        return this.scheduleListPanel;
    }
}
```
###### \java\seedu\whatnow\ui\ResultDisplay.java
``` java
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.scene.Node;
import javafx.scene.control.TextArea;
import javafx.scene.layout.AnchorPane;
import javafx.stage.Stage;
import seedu.whatnow.commons.util.FxViewUtil;

/**
 * A ui for the status bar that is displayed at the header of the application.
 */
public class ResultDisplay extends UiPart {
    public static final String RESULT_DISPLAY_ID = "resultDisplay";
    private static final String STATUS_BAR_STYLE_SHEET = "result-display";
    private TextArea resultDisplayArea;
    private final StringProperty displayed = new SimpleStringProperty("");

    private static final String FXML = "ResultDisplay.fxml";

    private AnchorPane placeHolder;

    private AnchorPane mainPane;

    public static ResultDisplay load(Stage primaryStage, AnchorPane placeHolder) {
        ResultDisplay statusBar = UiPartLoader.loadUiPart(primaryStage, placeHolder, new ResultDisplay());
        statusBar.configure();
        return statusBar;
    }

    public void configure() {
        resultDisplayArea = new TextArea();
        resultDisplayArea.setEditable(false);
        resultDisplayArea.setId(RESULT_DISPLAY_ID);
        resultDisplayArea.getStyleClass().removeAll();
        resultDisplayArea.getStyleClass().add(STATUS_BAR_STYLE_SHEET);
        resultDisplayArea.setText("");
        resultDisplayArea.textProperty().bind(displayed);
        FxViewUtil.applyAnchorBoundaryParameters(resultDisplayArea, 0.0, 0.0, 0.0, 0.0);
        mainPane.getChildren().add(resultDisplayArea);
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);
    }

    @Override
    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    public void postMessage(String message) {
        displayed.setValue(message);
    }

}
```
###### \java\seedu\whatnow\ui\ScheduleListPanel.java
``` java
import javafx.application.Platform;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.SplitPane;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.events.ui.TaskPanelSelectionChangedEvent;
import seedu.whatnow.model.task.ReadOnlyTask;

import java.util.logging.Logger;

/**
 * Panel containing the list of tasks.
 */
public class ScheduleListPanel extends UiPart {
    private final Logger logger = LogsCenter.getLogger(TaskListPanel.class);
    private static final String FXML = "ScheduleListPanel.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;

    @FXML
    private ListView<ReadOnlyTask> scheduleListView;

    public ScheduleListPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static ScheduleListPanel load(Stage primaryStage, AnchorPane scheduleListPlaceholder,
                                       ObservableList<ReadOnlyTask> taskList) {
        ScheduleListPanel scheduleListPanel =
                UiPartLoader.loadUiPart(primaryStage, scheduleListPlaceholder, new ScheduleListPanel());
        scheduleListPanel.configure(taskList);
        return scheduleListPanel;
    }

    private void configure(ObservableList<ReadOnlyTask> scheduleList) {
        setConnections(scheduleList);
        addToPlaceholder();
    }

    private void setConnections(ObservableList<ReadOnlyTask> scheduleList) {
        scheduleListView.setItems(scheduleList);
        scheduleListView.setCellFactory(listView -> new ScheduleListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    private void setEventHandlerForSelectionChangeEvent() {
        scheduleListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in task list panel changed to : '" + newValue + "'");
                raise(new TaskPanelSelectionChangedEvent(newValue));
            }
        });
    }

    /** Clears the schedule list view of any selection */
    public void clear() {
        scheduleListView.getSelectionModel().clearSelection();
    }
    
    public void scrollTo(int index) {
        Platform.runLater(() -> {
            scheduleListView.scrollTo(index);
            scheduleListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class ScheduleListViewCell extends ListCell<ReadOnlyTask> {

        public ScheduleListViewCell() {
        }

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(TaskCard.load(task, getIndex() + 1).getLayout());
            }
        }
    }

}
```
###### \java\seedu\whatnow\ui\TaskCard.java
``` java
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import seedu.whatnow.model.task.ReadOnlyTask;

public class TaskCard extends UiPart{

    private static final String FXML = "TaskListCard.fxml";
    private static final String INCOMPLETE = "";

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label taskDate;
    @FXML
    private Label startDate;
    @FXML
    private Label endDate;
    @FXML
    private Label taskTime;
    @FXML
    private Label startTime;
    @FXML
    private Label endTime;
    @FXML
    private Label id;
    @FXML
    private Label tags;
    @FXML
    private Label status;

    private ReadOnlyTask task;
    private int displayedIndex;

    public TaskCard(){

    }

    public static TaskCard load(ReadOnlyTask task, int displayedIndex){
        TaskCard card = new TaskCard();
        card.task = task;
        card.displayedIndex = displayedIndex;
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        name.setText(task.getName().fullName);
        id.setText(displayedIndex + ". ");

        if(task.getTaskDate() != null) {
        	taskDate.setText(task.getTaskDate());
        } else if(task.getTaskDate() == null) {
        	taskDate.setText("");
        }
        
        if(task.getStartDate() != null) {
            startDate.setText(task.getStartDate());
        } else if(task.getStartDate() == null) {
            startDate.setText("");
        }
        
        if(task.getEndDate() != null) {
            endDate.setText("to " + task.getEndDate());
        } else if(task.getEndDate() == null) {
            endDate.setText("");
        }
        
        if(task.getTaskTime() != null) {
            taskTime.setText(task.getTaskTime());
        } else if(task.getTaskTime() == null) {
            taskTime.setText("");
        }
        
        if(task.getStartTime() != null) {
            startTime.setText(task.getStartTime());
        } else if(task.getStartTime() == null) {
            startTime.setText("");
        }
        
        if(task.getEndTime() != null) {
            if (task.getEndDate() == null)
                endTime.setText("to " + task.getEndTime());
            else if (task.getEndDate() != null)
                endTime.setText(task.getEndTime());
        } else if(task.getEndTime() == null) {
            endTime.setText("");
        }
        
        tags.setText(task.tagsString());
        if (task.getStatus().equals("incomplete")) {
            status.setText(INCOMPLETE);
        } else {
            status.setText(task.getStatus());
        }
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox)node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \java\seedu\whatnow\ui\TaskListPanel.java
``` java
import javafx.application.Platform;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.scene.control.SplitPane;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.events.ui.TaskPanelSelectionChangedEvent;
import seedu.whatnow.model.task.ReadOnlyTask;

import java.util.logging.Logger;

/**
 * Panel containing the list of tasks.
 */
public class TaskListPanel extends UiPart {
    private final Logger logger = LogsCenter.getLogger(TaskListPanel.class);
    private static final String FXML = "TaskListPanel.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;

    @FXML
    private ListView<ReadOnlyTask> taskListView;

    public TaskListPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static TaskListPanel load(Stage primaryStage, AnchorPane taskListPlaceholder,
                                       ObservableList<ReadOnlyTask> taskList) {
        TaskListPanel taskListPanel =
                UiPartLoader.loadUiPart(primaryStage, taskListPlaceholder, new TaskListPanel());
        taskListPanel.configure(taskList);
        return taskListPanel;
    }

    private void configure(ObservableList<ReadOnlyTask> taskList) {
        setConnections(taskList);
        addToPlaceholder();
    }

    private void setConnections(ObservableList<ReadOnlyTask> taskList) {
        taskListView.setItems(taskList);
        taskListView.setCellFactory(listView -> new TaskListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    private void setEventHandlerForSelectionChangeEvent() {
        taskListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in task list panel changed to : '" + newValue + "'");
                raise(new TaskPanelSelectionChangedEvent(newValue));
            }
        });
    }
    
    /** Clears the task list view of any selection */
    public void clear() {
        taskListView.getSelectionModel().clearSelection();
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            taskListView.scrollTo(index);
            taskListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class TaskListViewCell extends ListCell<ReadOnlyTask> {

        public TaskListViewCell() {
        }

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(TaskCard.load(task, getIndex() + 1).getLayout());
            }
        }
    }

}
```
###### \java\seedu\whatnow\ui\UiManager.java
``` java
import com.google.common.eventbus.Subscribe;
import javafx.application.Platform;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.image.Image;
import javafx.stage.Stage;
import seedu.whatnow.MainApp;
import seedu.whatnow.commons.core.ComponentManager;
import seedu.whatnow.commons.core.Config;
import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.events.model.AddTaskEvent;
import seedu.whatnow.commons.events.model.UpdateTaskEvent;
import seedu.whatnow.commons.events.storage.DataSavingExceptionEvent;
import seedu.whatnow.commons.events.ui.JumpToListRequestEvent;
import seedu.whatnow.commons.events.ui.ShowHelpRequestEvent;
import seedu.whatnow.commons.events.ui.TaskPanelSelectionChangedEvent;
import seedu.whatnow.commons.util.StringUtil;
import seedu.whatnow.logic.Logic;
import seedu.whatnow.model.UserPrefs;
import seedu.whatnow.model.task.Task;

import java.util.logging.Logger;

/**
 * The manager of the UI component.
 */
public class UiManager extends ComponentManager implements Ui {
    private static final Logger logger = LogsCenter.getLogger(UiManager.class);
    private static final String ICON_APPLICATION = "/images/whatnow_32.png";
    private static final String MESSAGE_TASK_ADDED = "A task was added";
    private static final String MESSAGE_TASK_UPDATED = "A task was updated";

    private Logic logic;
    private Config config;
    private UserPrefs prefs;
    private MainWindow mainWindow;

    public UiManager(Logic logic, Config config, UserPrefs prefs) {
        super();
        this.logic = logic;
        this.config = config;
        this.prefs = prefs;
    }

    @Override
    public void start(Stage primaryStage) {
        logger.info("Starting UI...");
        primaryStage.setTitle(config.getAppTitle());

        //Set the application icon.
        primaryStage.getIcons().add(getImage(ICON_APPLICATION));

        try {
            mainWindow = MainWindow.load(primaryStage, config, prefs, logic);
            mainWindow.show(); //This should be called before creating other UI parts
            mainWindow.fillInnerParts();

        } catch (Throwable e) {
            logger.severe(StringUtil.getDetails(e));
            showFatalErrorDialogAndShutdown("Fatal error during initializing", e);
        }
    }

    @Override
    public void stop() {
        prefs.updateLastUsedGuiSetting(mainWindow.getCurrentGuiSetting());
        mainWindow.hide();
    }

    private void showFileOperationAlertAndWait(String description, String details, Throwable cause) {
        final String content = details + ":\n" + cause.toString();
        showAlertDialogAndWait(AlertType.ERROR, "File Op Error", description, content);
    }

    private Image getImage(String imagePath) {
        return new Image(MainApp.class.getResourceAsStream(imagePath));
    }

    void showAlertDialogAndWait(Alert.AlertType type, String title, String headerText, String contentText) {
        showAlertDialogAndWait(mainWindow.getPrimaryStage(), type, title, headerText, contentText);
    }

    private static void showAlertDialogAndWait(Stage owner, AlertType type, String title, String headerText,
                                               String contentText) {
        final Alert alert = new Alert(type);
        alert.getDialogPane().getStylesheets().add("view/DarkTheme.css");
        alert.initOwner(owner);
        alert.setTitle(title);
        alert.setHeaderText(headerText);
        alert.setContentText(contentText);

        alert.showAndWait();
    }

    private void showFatalErrorDialogAndShutdown(String title, Throwable e) {
        logger.severe(title + " " + e.getMessage() + StringUtil.getDetails(e));
        showAlertDialogAndWait(Alert.AlertType.ERROR, title, e.getMessage(), e.toString());
        Platform.exit();
        System.exit(1);
    }

    //==================== Event Handling Code =================================================================

    @Subscribe
    private void handleDataSavingExceptionEvent(DataSavingExceptionEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        showFileOperationAlertAndWait("Could not save data", "Could not save data to file", event.exception);
    }

    @Subscribe
    private void handleShowHelpEvent(ShowHelpRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.handleHelp();
    }

    @Subscribe
    private void handleJumpToListRequestEvent(JumpToListRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getTaskListPanel().scrollTo(event.targetIndex);
    }
    
    @Subscribe
    public void handleAddTaskEvent(AddTaskEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, MESSAGE_TASK_ADDED));
        Task task = event.task;
        
        if (task.getTaskType().equals("floating")) {
            mainWindow.getTaskListPanel().scrollTo(logic.getFilteredTaskList().indexOf(task));
            mainWindow.getScheduleListPanel().clear();
        } else {
            mainWindow.getScheduleListPanel().scrollTo(logic.getFilteredScheduleList().indexOf(task));
            mainWindow.getTaskListPanel().clear();
        }
    }
    
    @Subscribe
    public void handleUpdateTaskEvent(UpdateTaskEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, MESSAGE_TASK_UPDATED));
        Task task = event.task;
        
        if (task.getTaskType().equals("floating")) {
            mainWindow.getTaskListPanel().scrollTo(logic.getFilteredTaskList().indexOf(task));
            mainWindow.getScheduleListPanel().clear();
        } else {
            mainWindow.getScheduleListPanel().scrollTo(logic.getFilteredScheduleList().indexOf(task));
            mainWindow.getTaskListPanel().clear();
        }
    }
}
```
###### \java\seedu\whatnow\ui\UiPart.java
``` java
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.layout.AnchorPane;
import javafx.stage.Modality;
import javafx.stage.Stage;
import seedu.whatnow.commons.core.EventsCenter;
import seedu.whatnow.commons.events.BaseEvent;
import seedu.whatnow.commons.util.AppUtil;

/**
 * Base class for UI parts.
 * A 'UI part' represents a distinct part of the UI. e.g. Windows, dialogs, panels, status bars, etc.
 */
public abstract class UiPart {

    /**
     * The primary stage for the UI Part.
     */
    Stage primaryStage;

    public UiPart(){

    }

    /**
     * Raises the event via {@link EventsCenter#post(BaseEvent)}
     * @param event
     */
    protected void raise(BaseEvent event){
        EventsCenter.getInstance().post(event);
    }

    /**
     * Registers the object as an event handler at the {@link EventsCenter}
     * @param handler usually {@code this}
     */
    protected void registerAsAnEventHandler(Object handler) {
        EventsCenter.getInstance().registerHandler(handler);
    }

    /**
     * Override this method to receive the main Node generated while loading the view from the .fxml file.
     * @param node
     */
    public abstract void setNode(Node node);

    /**
     * Override this method to return the name of the fxml file. e.g. {@code "MainWindow.fxml"}
     * @return
     */
    public abstract String getFxmlPath();

    public void setStage(Stage primaryStage) {
        this.primaryStage = primaryStage;
    }


    /**
     * Creates a modal dialog.
     * @param title Title of the dialog.
     * @param parentStage The owner stage of the dialog.
     * @param scene The scene that will contain the dialog.
     * @return the created dialog, not yet made visible.
     */
    protected Stage createDialogStage(String title, Stage parentStage, Scene scene) {
        Stage dialogStage = new Stage();
        dialogStage.setTitle(title);
        dialogStage.initModality(Modality.WINDOW_MODAL);
        dialogStage.initOwner(parentStage);
        dialogStage.setScene(scene);
        return dialogStage;
    }

    /**
     * Sets the given image as the icon for the primary stage of this UI Part.
     * @param iconSource e.g. {@code "/images/help_icon.png"}
     */
    protected void setIcon(String iconSource) {
        primaryStage.getIcons().add(AppUtil.getImage(iconSource));
    }

    /**
     * Sets the given image as the icon for the given stage.
     * @param stage
     * @param iconSource e.g. {@code "/images/help_icon.png"}
     */
    protected void setIcon(Stage stage, String iconSource) {
        stage.getIcons().add(AppUtil.getImage(iconSource));
    }

    /**
     * Sets the placeholder for UI parts that reside inside another UI part.
     * @param placeholder
     */
    public void setPlaceholder(AnchorPane placeholder) {
        //Do nothing by default.
    }

    public Stage getPrimaryStage() {
        return primaryStage;
    }
}
```
###### \java\seedu\whatnow\ui\UiPartLoader.java
``` java
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.layout.AnchorPane;
import javafx.stage.Stage;
import seedu.whatnow.MainApp;

/**
 * A utility class to load UiParts from FXML files.
 */
public class UiPartLoader {
    private final static String FXML_FILE_FOLDER = "/view/";

    public static <T extends UiPart> T loadUiPart(Stage primaryStage, T controllerSeed) {
        return loadUiPart(primaryStage, null, controllerSeed);
    }

    /**
     * Returns the ui class for a specific UI Part.
     *
     * @param primaryStage The primary stage for the view.
     * @param placeholder The placeholder where the loaded Ui Part is added.
     * @param sampleUiPart The sample of the expected UiPart class.
     * @param <T> The type of the UiPart
     */
    public static <T extends UiPart> T loadUiPart(Stage primaryStage, AnchorPane placeholder, T sampleUiPart) {
        FXMLLoader loader = new FXMLLoader();
        loader.setLocation(MainApp.class.getResource(FXML_FILE_FOLDER + sampleUiPart.getFxmlPath()));
        Node mainNode = loadLoader(loader, sampleUiPart.getFxmlPath());
        UiPart controller = loader.getController();
        controller.setStage(primaryStage);
        controller.setPlaceholder(placeholder);
        controller.setNode(mainNode);
        return (T)controller;
    }

    /**
     * Returns the ui class for a specific UI Part.
     *
     * @param seedUiPart The UiPart object to be used as the ui.
     * @param <T> The type of the UiPart
     */

    public static <T extends UiPart> T loadUiPart(T seedUiPart) {
        FXMLLoader loader = new FXMLLoader();
        loader.setLocation(MainApp.class.getResource(FXML_FILE_FOLDER + seedUiPart.getFxmlPath()));
        loader.setController(seedUiPart);
        loadLoader(loader, seedUiPart.getFxmlPath());
        return seedUiPart;
    }


    private static Node loadLoader(FXMLLoader loader, String fxmlFileName) {
        try {
            return loader.load();
        } catch (Exception e) {
            String errorMessage = "FXML Load Error for " + fxmlFileName;
            throw new RuntimeException(errorMessage, e);
        }
    }

}
```
