# A0139128A
###### \java\seedu\whatnow\logic\commands\AddCommand.java
``` java
	@Override
	public CommandResult execute() {
		assert model != null;
		try {
			model.addTask(toAdd);
			model.getUndoStack().push(COMMAND_WORD);
			model.getDeletedStackOfTasksAdd().push(toAdd);
			Recurrence recurring = new Recurrence(toAdd.getPeriod(), toAdd.getTaskDate(), toAdd.getStartDate(), toAdd.getEndDate(), toAdd.getEndPeriod());
			model.clearRedoAll();
			if (recurring.hasRecurring()) {
			    addRecurring(recurring);
			}
		} catch (UniqueTaskList.DuplicateTaskException e) {
			return new CommandResult(MESSAGE_DUPLICATE_TASK);
		}
		return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
	}
}
```
###### \java\seedu\whatnow\logic\commands\ClearCommand.java
``` java
    /**
     * Executes the ClearCommand to delete all task data on WhatNow
     */
    @Override
    public CommandResult execute() {
        assert model != null;

        model.resetData(WhatNow.getEmptyWhatNow());
        model.getUndoStack().push(COMMAND_WORD);
        model.clearRedoAll();
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Redo the previous action "
            + "Parameters: No parameters" + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = "Redo Successfully";
    
    public static final String MESSAGE_FAIL = "Redo failure due to unexisting undo commands";

    public static final String UNKNOWN_COMMAND_FOUND = "Unknown Command found";

    public static final String MESSAGE_LIST_NO_REDO_LIST = " No list command to redo";
    
    private static final Logger logger = LogsCenter.getLogger(StorageManager.class);

```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    @Override
    public CommandResult execute() throws TaskNotFoundException {
        assert model != null;
        if (model.getRedoStack().isEmpty()) {
            return new CommandResult(MESSAGE_FAIL);
        } else {
            String reqCommand = model.getRedoStack().pop();
            model.getUndoStack().push(reqCommand);
            return performReqRedo(reqCommand);
        }
    }

```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    private CommandResult performRedoAdd() {
        assert model != null;
        if (model.getDeletedStackOfTasksAddRedo().isEmpty()) {
            return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
        } else {
            try {
                ReadOnlyTask reqTask = model.getDeletedStackOfTasksAddRedo().pop();
                model.addTask((Task) reqTask);
                model.getDeletedStackOfTasksAdd().push(reqTask);
            } catch (DuplicateTaskException e) {
                return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
            }
            return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS));
        }
    }

```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    private CommandResult performRedoDelete() {
        if (model.getDeletedStackOfTasksRedo().isEmpty() || model.getDeletedStackOfTasksIndexRedo().isEmpty()) {
            return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
        } else {
            ReadOnlyTask taskToDelete = model.getDeletedStackOfTasksRedo().pop();
            model.getDeletedStackOfTasks().push(taskToDelete);
            int idxToRedoAdd = model.getDeletedStackOfTasksIndexRedo().pop();
            try {
                model.deleteTask((Task) taskToDelete);
                model.getDeletedStackOfTasksIndex().push(idxToRedoAdd);
            } catch (TaskNotFoundException tnfe) {
                return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
            }
            return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS));
        }
    }

```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    private CommandResult performRedoList() {
        if (model.getStackOfListTypesRedo().isEmpty()) {
            return new CommandResult(MESSAGE_LIST_NO_REDO_LIST);
        } else {
            String prevCommandListType = model.getStackOfListTypesRedo().pop();
            model.getStackOfListTypes().push(prevCommandListType);
            return performReqRedoList(prevCommandListType);
        }
    }

    private CommandResult performReqRedoList(String prevCommandListType) {
        if (prevCommandListType.equals(ListCommand.TASK_STATUS_ALL)) {
            model.updateFilteredListToShowAll();
            model.updateFilteredScheduleListToShowAll();
            return new CommandResult(RedoCommand.MESSAGE_SUCCESS);
        } else if (prevCommandListType.equals(ListCommand.TASK_STATUS_INCOMPLETE)) {
            model.updateFilteredListToShowAllIncomplete();
            model.updateFilteredScheduleListToShowAllIncomplete();
            return new CommandResult(RedoCommand.MESSAGE_SUCCESS);
        } else {
            model.updateFilteredListToShowAllCompleted();
            model.updateFilteredScheduleListToShowAllCompleted();
            return new CommandResult(RedoCommand.MESSAGE_SUCCESS);
        }
    }

```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    private CommandResult performRedoMarkDone() {
        if (model.getStackOfMarkDoneTaskRedo().isEmpty()) {
            return new CommandResult(RedoCommand.MESSAGE_FAIL);
        } else {
            ReadOnlyTask taskToMark = model.getStackOfMarkDoneTaskRedo().pop();
            try {
                model.markTask(taskToMark);
                model.getStackOfMarkDoneTask().push(taskToMark);
            } catch (TaskNotFoundException tnfe) {
                return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
            }
            return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS));
        }
    }

```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    private CommandResult performRedoMarkUnDone() {
        if (model.getStackOfMarkUndoneTaskRedo().isEmpty()) {
            return new CommandResult(RedoCommand.MESSAGE_FAIL);
        } else {
            ReadOnlyTask taskToMark = model.getStackOfMarkUndoneTaskRedo().pop();
            try {
                model.unMarkTask(taskToMark);   
                model.getStackOfMarkUndoneTask().push(taskToMark);
            } catch (TaskNotFoundException tnfe) {
                return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
            }
            return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS));
        }
    }

```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    private CommandResult performRedoUpdate() throws TaskNotFoundException {
        assert model != null;
        if (model.getOldNextTask().isEmpty() && model.getNewNextTask().isEmpty()) {
            return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
        } else {
            try {
                Task toChangeInto = (Task) model.getOldNextTask().pop();
                Task original = (Task) model.getNewNextTask().pop();
                
                model.updateTask(original, toChangeInto);
                model.getOldTask().push(original);
                model.getCurrentTask().push(toChangeInto);
            } catch (UniqueTaskList.DuplicateTaskException utle) {
                return new CommandResult(RedoCommand.MESSAGE_FAIL);
            }
            return new CommandResult(RedoCommand.MESSAGE_SUCCESS);
        }
    }

```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    private CommandResult performRedoClear() {
        model.resetData(WhatNow.getEmptyWhatNow());
        return new CommandResult(RedoCommand.MESSAGE_SUCCESS);
    }
}
```
###### \java\seedu\whatnow\logic\commands\UndoCommand.java
``` java
package seedu.whatnow.logic.commands;

import java.io.IOException;
import java.nio.file.FileSystems;
import java.util.Optional;
import java.util.logging.Logger;

import seedu.whatnow.commons.core.Config;
import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.exceptions.DataConversionException;
import seedu.whatnow.commons.util.ConfigUtil;
import seedu.whatnow.commons.util.StringUtil;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.Task;
import seedu.whatnow.model.task.UniqueTaskList;
import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;
import seedu.whatnow.storage.StorageManager;

public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo previous task in WhatNow "
            + "Parameters: No parameters" + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = "Undo Successfully";
    public static final String MESSAGE_FAIL = "Undo failure due to unexisting previous commands";

    public static final String UNKNOWN_COMMAND_FOUND = "Unknown Command Found in Undo";

    public static final String MESSAGE_LIST_NOT_ENTERED = " No previous list command was entered";

    private static final Logger logger = LogsCenter.getLogger(StorageManager.class);
    
    public final String ADD_COMMAND = "add";
    public final String DELETE_COMMAND = "delete";
    public final String LIST_COMMAND = "list";
    public final String MARKDONE_COMMAND = "done";
    public final String MARKUNDONE_COMMAND = "undone";
    public final String UPDATE_COMMAND = "update";
    public final String CLEAR_COMMAND = "clear";
    public final String CHANGE_COMMAND = "change";

    @Override
    public CommandResult execute() throws DuplicateTaskException, TaskNotFoundException {
        assert model != null;
        if (model.getUndoStack().isEmpty()) {
            return new CommandResult(MESSAGE_FAIL);
        } else {
            String reqCommand = model.getUndoStack().pop();
            model.getRedoStack().push(reqCommand);
            return performReqUndo(reqCommand);
        }
    }

    private CommandResult performReqUndo(String reqCommand) throws TaskNotFoundException {
        if (reqCommand.equals(ADD_COMMAND)) {
            return performUndoAdd();
        } else if (reqCommand.equals(DELETE_COMMAND)) {
            return performUndoDelete();
        } else if (reqCommand.equals(LIST_COMMAND)) {
            return performUndoList();
        } else if (reqCommand.equals(MARKDONE_COMMAND)) {
            return performUndoMarkDone();
        } else if (reqCommand.equals(MARKUNDONE_COMMAND)) {
            return performUndoMarkUnDone();
        } else if (reqCommand.equals(UPDATE_COMMAND)) {
            return performUndoUpdate();
        } else if (reqCommand.equals(CLEAR_COMMAND)) {
            return performUndoClear();
        } else if(reqCommand.equals(CHANGE_COMMAND)) {
            return performUndoChange();
        } else {
            return new CommandResult(UNKNOWN_COMMAND_FOUND);
        }
    }

    private CommandResult performUndoAdd() {
        assert model != null;
        if (model.getDeletedStackOfTasksAdd().isEmpty()) {
            return new CommandResult(String.format(UndoCommand.MESSAGE_FAIL));
        } else {
            try {
                ReadOnlyTask reqTask = model.getDeletedStackOfTasksAdd().pop();
                model.getDeletedStackOfTasksAddRedo().push(reqTask);
                model.deleteTask(reqTask);
            } catch (TaskNotFoundException tnfe) {
                return new CommandResult(String.format(UndoCommand.MESSAGE_FAIL));
            }
            return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS));
        }
    }

```
###### \java\seedu\whatnow\model\Model.java
``` java
    /**
     * Clears existing backing model and replaces with the provided new data.
     */
    void resetData(ReadOnlyWhatNow newData);

    /**
     * Reverts to the pre-existing backing model and replaces with backup-ed
     * data
     */
    void revertData();

    /** Returns the WhatNow */
    ReadOnlyWhatNow getWhatNow();

    // =========== Methods for Task List
    // ===============================================================

    /** Deletes the given task. */
    int deleteTask(ReadOnlyTask target) throws TaskNotFoundException;

    /** Adds the given task */
    void addTask(Task task) throws DuplicateTaskException;

    /** Adds the given task at specific index */
    void addTaskSpecific(Task task, int idx) throws DuplicateTaskException;

```
###### \java\seedu\whatnow\model\Model.java
``` java
    /** Gets the UndoStack if possible */
    Stack<String> getUndoStack();

    /** Gets the redoStack if possible */
    Stack<String> getRedoStack();

    /** Gets the oldTask if possible */
    Stack<ReadOnlyTask> getOldTask();

    /** Gets the currentTask if possible */
    Stack<ReadOnlyTask> getCurrentTask();

    /** Gets the OldnextTask if possible */
    Stack<ReadOnlyTask> getOldNextTask();
    
    /** Gets the NewNextTask if possible */
    Stack<ReadOnlyTask> getNewNextTask();
    
    /** Gets the deletedStackOfTask that corresponds to deleteCommand */
    Stack<ReadOnlyTask> getDeletedStackOfTasks();

    /** Gets the deletedStackOfTsksIndex that corresponds to deleteCommand */
    Stack<Integer> getDeletedStackOfTasksIndex();

    /** Gets the deletedStackOfTaskRedo that corresponds to deleteCommand */
    Stack<ReadOnlyTask> getDeletedStackOfTasksRedo();

    /**
     * Gets the deletedStackOfTasksIndexRedo that corresponds to deleteCommand
     */
    Stack<Integer> getDeletedStackOfTasksIndexRedo();

    /** Gets the deleted StackOfTasks that corresponds to AddCommand */
    Stack<ReadOnlyTask> getDeletedStackOfTasksAdd();

    /** Gets the deleted StackOfTasksRedo that corresponds to AddCommand */
    Stack<ReadOnlyTask> getDeletedStackOfTasksAddRedo();

    /** Gets Stack of Task that were marked */
    Stack<ReadOnlyTask> getStackOfMarkDoneTask();

    /** Gets stack of Task that were marked and corresponds to RedoCommand */
    Stack<ReadOnlyTask> getStackOfMarkDoneTaskRedo();

    /** Gets stack of Task that were marked and corresponds to UndoneCommand */
    Stack<ReadOnlyTask> getStackOfMarkUndoneTask();

    /** Gets stack of Task that were marked and corresponds to RedoCommand */
    Stack<ReadOnlyTask> getStackOfMarkUndoneTaskRedo();

    /**
     * Gets a stack of String that corresponds to the list of commands that were
     * executed
     */
    Stack<String> getStackOfListTypes();

    /**
     * Gets a stack of String that corresponds to the list of Commands that were
     * undone
     */
    Stack<String> getStackOfListTypesRedo();
    
    /**Clears All relevant Redo Stacks when a new Command has been executed */
    void clearRedoAll();
    
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public void resetData(ReadOnlyWhatNow newData) {
        stackOfWhatNow.push(new WhatNow(whatNow));
        whatNow.resetData(newData);
        initialiseFreeTime();
        indicateWhatNowChanged();
    }

    @Override
    public synchronized void revertData() {
        whatNow.revertEmptyWhatNow(stackOfWhatNow.pop());
        indicateWhatNowChanged();
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    public synchronized void addTaskSpecific(Task task, int idx) throws UniqueTaskList.DuplicateTaskException {
        whatNow.addTaskSpecific(task, idx);
        updateFilteredListToShowAllIncomplete();
        indicateAddTask(task, true);
        indicateWhatNowChanged();
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<String> getUndoStack() {
        return stackOfUndo;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<String> getRedoStack() {
        return stackOfRedo;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getOldTask() {
        return stackOfOldTask;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getCurrentTask() {
        return stackOfCurrentTask;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getOldNextTask() {
        return stackOfOldNextTask;
    }
    
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    public Stack<ReadOnlyTask> getNewNextTask() {
        return stackOfNewNextTask;
    }
    
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getDeletedStackOfTasks() {
        return stackOfDeletedTasks;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    public Stack<Integer> getDeletedStackOfTasksIndex() {
        return stackOfDeletedTaskIndex;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    public Stack<Integer> getDeletedStackOfTasksIndexRedo() {
        return stackOfDeletedTaskIndexRedo;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getDeletedStackOfTasksRedo() {
        return stackOfDeletedTasksRedo;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getDeletedStackOfTasksAdd() {
        return stackOfDeletedTasksAdd;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getDeletedStackOfTasksAddRedo() {
        return stackOfDeletedTasksAddRedo;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getStackOfMarkDoneTask() {
        return stackOfMarkDone;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getStackOfMarkDoneTaskRedo() {
        return stackOfMarkDoneRedo;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    public Stack<ReadOnlyTask> getStackOfMarkUndoneTaskRedo() {
        return stackOfMarkUndoneRedo;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<String> getStackOfListTypes() {
        return stackOfListTypes;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<String> getStackOfListTypesRedo() {
        return stackOfListTypesRedo;
    }
    
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public void clearRedoAll() {
        clearAllRedoStack();
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    private void clearAllRedoStack() {
        while(!getRedoStack().isEmpty()) {
            getRedoStack().pop();
        }
        while(!getOldNextTask().isEmpty()) {
            getOldNextTask().pop();
        }
        while(!getNewNextTask().isEmpty()) {
            getNewNextTask().pop();
        }
        while(!getDeletedStackOfTasksRedo().isEmpty()) {
            getDeletedStackOfTasksRedo().pop();
        }
        while(!getDeletedStackOfTasksIndexRedo().isEmpty()) {
            getDeletedStackOfTasksIndexRedo().pop();
        }
        while(!getDeletedStackOfTasksAddRedo().isEmpty()) {
            getDeletedStackOfTasksAddRedo().pop();
        }
        while(!getStackOfMarkDoneTaskRedo().isEmpty()) {
            getStackOfMarkDoneTaskRedo().pop();
        }
        while(!getStackOfMarkUndoneTaskRedo().isEmpty()) {
            getStackOfMarkUndoneTaskRedo().pop();
        }
        while(!getStackOfListTypesRedo().isEmpty()) {
            getStackOfListTypesRedo().pop();
        }
        while(!getStackOfChangeFileLocationNew().isEmpty()) {
            getStackOfChangeFileLocationNew().pop();
        } 
    }

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    
    private static final Logger logger = LogsCenter.getLogger(TaskDate.class);
    
    public static final String MESSAGE_NAME_CONSTRAINTS = "Task Date should be represented as one of the followings:\n"
            + "dd/mm/yyyy\n" + "day month year\n" + "today\n" + "tomorrow\n";
    public static final String EXPIRED_TASK_DATE = "Task Date cannot be in the past!";
    public static final String INVALID_TASK_DATE_RANGE_FORMAT = "The task date range is invalid!";
    public static final String INVALID_TASK_DATE_NO_DATE = "Please input a date.";
    public static final String INVALID_TASK_DATE = "The task date is invalid.";

    public static final String DATE_ALPHA_WITH_YEAR_VALIDATION_REGEX = "([0-9]{2}+[\\w\\.])+([0-9]{4})";
    public static final String DATE_ALPHA_WITHOUT_YEAR_VALIDATION_REGEX = "([0-9]{2}+[\\w\\.])";

    public static final String DATE_NUM_SLASH_WITH_YEAR_VALIDATION_REGEX = "([0-9]{2}+)/([0-9]{2}+)/([0-9]{4})"; 
    public static final String DATE_NUM_SLASH_WITHOUT_YEAR_VALIDATION_REGEX = "([0-9]{2})/([0-9]{2})";
    public static final String DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_DAY_REGEX = "([0-9]{1}+)/([0-9]{2}+)/([0-9]{4})";
    public static final String DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_MONTH_REGEX = "([0-9]{2}+)/([1-9]{1}+)/([0-9]{4})";
    public static final String DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_DAY_AND_MONTH_REGEX = "([0-9]{1}+)/([0-9]{1}+)/([0-9]{4})";

    public static final String DATE_NUM_SLASH_WITH_YEAR_FORMAT = "dd/MM/yyyy";

    private static final Pattern DAYS_MONDAY = Pattern.compile("((?:monday|mon))", Pattern.CASE_INSENSITIVE);
    private static final Pattern DAYS_TUESDAY = Pattern.compile("((?:tuesday|tue|tues))", Pattern.CASE_INSENSITIVE);
    private static final Pattern DAYS_WEDNESDAY = Pattern.compile("((?:wednesday|wed))", Pattern.CASE_INSENSITIVE);
    private static final Pattern DAYS_THURSDAY = Pattern.compile("((?:thursday|thur|thu))", Pattern.CASE_INSENSITIVE);
    private static final Pattern DAYS_FRIDAY = Pattern.compile("((?:friday|fri))", Pattern.CASE_INSENSITIVE);
    private static final Pattern DAYS_SATURDAY = Pattern.compile("((?:saturday|sat))", Pattern.CASE_INSENSITIVE);
    private static final Pattern DAYS_SUNDAY = Pattern.compile("((?:sunday|sun))", Pattern.CASE_INSENSITIVE);
    private static final Pattern TODAY = Pattern.compile("((?:today|tdy))", Pattern.CASE_INSENSITIVE);
    private static final Pattern TOMORROW = Pattern.compile("((?:tomorrow|tmr))", Pattern.CASE_INSENSITIVE);

    private static final Pattern DAYS_IN_FULL = Pattern
            .compile("^(monday|tuesday|wednesday|thursday|friday|saturday|sunday)$", Pattern.CASE_INSENSITIVE);
    private static final Pattern DAYS_IN_SHORT = Pattern.compile("^(mon|tue|tues|wed|thu|thur|fri|sat|sun)$",
            Pattern.CASE_INSENSITIVE);

    private static String fullDate;
    private static String startDate;
    private static String endDate;

    //author@@ A0141021H
    private static final String JANUARY_FULL = "january";
    private static final String FEBRUARY_FULL = "february";
    private static final String MARCH_FULL = "march";
    private static final String APRIL_FULL = "april";
    private static final String MAY_FULL = "may";
    private static final String JUNE_FULL = "june";
    private static final String JULY_FULL = "july";
    private static final String AUGUST_FULL = "august";
    private static final String SEPTEMBER_FULL = "september";
    private static final String OCTOBER_FULL = "october";
    private static final String NOVEMBER_FULL = "november";
    private static final String DECEMBER_FULL = "december";

    private static final String JANUARY_SHORT = "jan";
    private static final String FEBRUARY_SHORT = "feb";
    private static final String MARCH_SHORT = "mar";
    private static final String APRIL_SHORT = "apr";
    private static final String JUNE_SHORT = "jun";
    private static final String JULY_SHORT = "jul";
    private static final String AUGUST_SHORT = "aug";
    private static final String SEPTEMBER_SHORT = "sep";
    private static final String OCTOBER_SHORT = "oct";
    private static final String NOVEMBER_SHORT = "nov";
    private static final String DECEMBER_SHORT = "dec";

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    /**
     * Validates given date
     *
     * @throw IllegalValueException if given date is invalid
     */
    public TaskDate(String taskDate, String startDate, String endDate) throws IllegalValueException, ParseException {
        if (taskDate == null && startDate != null && endDate != null) {
            if (TODAY.matcher(startDate).find() || TOMORROW.matcher(startDate).find()) {
                startDate = performStartDate(startDate);
            }
            if (TODAY.matcher(endDate).find() || TOMORROW.matcher(endDate).find()) {
                endDate = performEndDate(endDate);
            }
            if (!isValidDateRange(startDate, endDate)) {
                throw new IllegalValueException(INVALID_TASK_DATE_RANGE_FORMAT);
            }
        } else {
            if (!isValidDate(taskDate)) {
                throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
            }
            if (TODAY.matcher(taskDate).find()) {
                fullDate = assignTodayDate();
            } else if (TOMORROW.matcher(taskDate).find()) {
                fullDate = assignTmrDate();
            }
        }
    }

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    /** Assigns the appropriate today's or tomorrow date to startDate */
    public static String performStartDate(String startDate) {
        if (TODAY.matcher(startDate).find()) {
            return assignTodayDate();
        } else {
            return assignTmrDate();
        }
    }

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    /** Assigns the appropriate today's or tomorrow date to endDate */
    public static String performEndDate(String endDate) {
        if (TODAY.matcher(endDate).find()) {
            return assignTodayDate();
        } else {
            return assignTmrDate();
        }
    }

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    /** Assigns today's date to the the appropriate date required and returns it */
    public static String assignTodayDate() {
        String todayDate;
        DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
        Calendar cal = Calendar.getInstance();

        todayDate = dateFormat.format(cal.getTime());
        return todayDate;
    }

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    /** Assigns tmr's date to the appropriate date required and returns it */
    public static String assignTmrDate() {
        String tmrDate;
        DateFormat dateFormat2 = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
        Calendar cal2 = Calendar.getInstance();

        cal2.add(Calendar.DATE, INCREASE_DATE_BY_ONE_DAY);

        tmrDate = dateFormat2.format(cal2.getTime());
        return tmrDate;
    }

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    /**
     * @param test
     *            is a given user date input
     * @return the validity of the user date input by passing it to methods of
     *         different regex
     * @throws ParseException
     * @throws IllegalValueException
     */
    private static boolean isValidDate(String reqDate) throws ParseException, IllegalValueException {

        if (TODAY.matcher(reqDate).find() || TOMORROW.matcher(reqDate).find()) {
            return true;
        } else {
            return isValidNumDate(reqDate);
        }
    }

    /**
     * This function finds the respective regex that matches the user input and
     * sends to isValidDateRangeValidator to check if the two dates are really
     * valid
     * 
     * @param startDate
     *            is the user input startingDate
     * @param endDate
     *            is the user input endingDate
     * @return true is valid date range, else false
     * @throws ParseException
     */
```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    private static boolean isValidDateRange(String startDate, String endDate) throws ParseException {
        return isValidDateRangeValidator(startDate, endDate);
    }

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    private static boolean isValidDateRangeValidator(String beforeDate, String afterDate) {
        if (beforeDate == null && afterDate == null) {
            return true;
        }
        boolean convertedFromDay = false;
        if (isDay(beforeDate) && isDay(afterDate)) {
            beforeDate = formatDayToDate(beforeDate);
            afterDate = formatDayToDate(afterDate);
            convertedFromDay = true;
        } else if (isDay(beforeDate)) {
            beforeDate = formatDayToDate(beforeDate);
            convertedFromDay = true;
        } else if (isDay(afterDate)) {
            afterDate = formatDayToDate(afterDate);
            convertedFromDay = true;
        }
        boolean validDateRange = false;
        boolean sameDate = false;
        SimpleDateFormat sdf = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
        Date beginDate = null;
        Date finishDate = null;
        try {
            beginDate = sdf.parse(beforeDate);
            finishDate = sdf.parse(afterDate);
            if (beginDate.before(finishDate)) {
                validDateRange = true;
            } else {
                if (convertedFromDay) {
                    afterDate = isBeforeEarlierThanAfter(finishDate);
                    finishDate = sdf.parse(afterDate);
                    if (beginDate.before(finishDate)) {
                        validDateRange = true;
                    }
                }
            }
            if (beginDate.equals(finishDate)) {
                sameDate = true;
            }
        } catch (ParseException e) {
            return false;
        }
        /**
         * Following is done because the default date gotten from currentDate is
         * always 0000(time) i.e. always earlier than the user inputDates
         */
        Calendar before = new GregorianCalendar();
        before = setGregorian(before, beginDate);
        beginDate = before.getTime();

        Calendar after = new GregorianCalendar();
        after = setGregorian(after, finishDate);
        finishDate = after.getTime();

        /**
         * Following checks if the user input date is invalid i.e before today's
         * date
         */
        Calendar current = new GregorianCalendar();
        current = setGregorianCurrent(current);
        Date currDate = current.getTime();

        if (currDate.compareTo(beginDate) > 0 || currDate.compareTo(finishDate) > 0) {
            return false;
        } else if (!validDateRange && !sameDate) {
            return false;
        } else {
            startDate = beforeDate;
            endDate = afterDate;
            return true;
        }
    }

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    /**
     * returns a week ahead of the input date when a day is entered
     */
    public static String isBeforeEarlierThanAfter(Date finishDate) {

        SimpleDateFormat sdf = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
        Calendar cal = Calendar.getInstance();
        cal.setTime(finishDate);
        cal.add(Calendar.DATE, INCREASE_DATE_BY_SEVEN_DAYS);

        return sdf.format(cal.getTime());
    }

    /**
     * @param test
     *            is the date input by the user
     * @param format
     *            is the type of format that the date input will be tested
     *            against with
     * @return the validity of the user input
     * @throws ParseException
     * @throws IllegalValueException
     */
    private static boolean isValidNumDate(String incDate) throws ParseException, IllegalValueException {
        Date inputDate = null;
        if (isDay(incDate)) {
            incDate = formatDayToDate(incDate);
        }
        try {
            DateFormat df = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
            df.setLenient(false);

            inputDate = df.parse(incDate);
        } catch (ParseException ex) {
            logger.warning("TaskDate.java, isValidNumDate:\n" + ex.getMessage());
            return false;
        }

        Calendar input = new GregorianCalendar();
        input = setGregorian(input, inputDate);
        inputDate = input.getTime();

        /**
         * Following checks if the user input date is invalid i.e before today's
         * date
         */
        Calendar current = new GregorianCalendar();
        current = setGregorianCurrent(current);
        Date currDate = current.getTime();

        if (currDate.compareTo(inputDate) > 0) {
            throw new IllegalValueException(EXPIRED_TASK_DATE);
        }
    
        fullDate = formatDateToStandardDate(incDate);
        return true;
    }

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    public static boolean isDay(String inputDay) {
        return (DAYS_MONDAY.matcher(inputDay).find() || DAYS_TUESDAY.matcher(inputDay).find()
                || DAYS_WEDNESDAY.matcher(inputDay).find() || DAYS_THURSDAY.matcher(inputDay).find()
                || DAYS_FRIDAY.matcher(inputDay).find() || DAYS_SATURDAY.matcher(inputDay).find()
                || DAYS_SUNDAY.matcher(inputDay).find());
    }

    /**
     * This method checks the validity of the month entered by the user.
     */
    public static boolean isValidMonth(String mth) {
        String month = mth.toLowerCase();
        if (month.equals(JANUARY_FULL) || month.equals(JANUARY_SHORT)) {
            return true;
        } else if (month.equals(FEBRUARY_FULL) || month.equals(FEBRUARY_SHORT)) {
            return true;
        } else if (month.equals(MARCH_FULL) || month.equals(MARCH_SHORT)) {
            return true;
        } else if (month.equals(APRIL_FULL) || month.equals(APRIL_SHORT)) {
            return true;
        } else if (month.equals(MAY_FULL)) {
            return true;
        } else if (month.equals(JUNE_FULL) || month.equals(JUNE_SHORT)) {
            return true;
        } else if (month.equals(JULY_FULL) || month.equals(JULY_SHORT)) {
            return true;
        } else if (month.equals(AUGUST_FULL) || month.equals(AUGUST_SHORT)) {
            return true;
        } else if (month.equals(SEPTEMBER_FULL) || month.equals(SEPTEMBER_SHORT)) {
            return true;
        } else if (month.equals(OCTOBER_FULL) || month.equals(OCTOBER_SHORT)) {
            return true;
        } else if (month.equals(NOVEMBER_FULL) || month.equals(NOVEMBER_SHORT)) {
            return true;
        } else if (month.equals(DECEMBER_FULL) || month.equals(DECEMBER_SHORT)) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * This method sets the date to be of the latest time as a date always comes
     * attached with a default time and there is a need to overwrite this timing
     * to the latest so that it can be compared with the current date
     */
```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    private static Calendar setGregorian(Calendar cal, Date reqDate) {
        cal.setTime(reqDate);
        cal.set(Calendar.HOUR_OF_DAY, 23);
        cal.set(Calendar.MINUTE, 59);
        cal.set(Calendar.SECOND, 59);
        return cal;
    }

    /** Gets the current Date and set it to earliest */
```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    private static Calendar setGregorianCurrent(Calendar cal) {
        cal.set(Calendar.HOUR_OF_DAY, 00);
        cal.set(Calendar.MINUTE, 00);
        cal.set(Calendar.SECOND, 00);
        return cal;
    }

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    @Override
    public String toString() {
        if (fullDate == null) {
            return startDate + " " + endDate;
        } else {
            return fullDate;
        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDate // instanceof handles nulls
                        && this.fullDate.equals(((TaskDate) other).fullDate)); // state
        // check
    }

    /** Returns the fullDate */
    public String getDate() {
        return fullDate;
    }

    /** Returns the startDate */
    public String getStartDate() {
        return this.startDate;
    }

    /** Returns the endDate */
    public String getEndDate() {
        return this.endDate;
    }

```
###### \java\seedu\whatnow\model\task\TaskTime.java
``` java
    private static final Logger logger = LogsCenter.getLogger(TaskTime.class);

    public static final String TWELVE_HOUR_WITH_MINUTES_COLON_REGEX = "(((\\d|\\d\\d):\\d\\d)(am|pm))";
    public static final String TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT = "h:mma"; //E.g. 1:50pm

    public static final String DATE_NUM_SLASH_WITH_YEAR_FORMAT = "dd/MM/yyyy";

    public static final String INVALID_TIME_MESSAGE = "Entered an invalid time format";
    public static final String INVALID_TIME_RANGE_MESSAGE = "Entered an invalid time range format";
    public static final String INVALID_DATE_MESSAGE = "Entered an invalid date format";
    public static final String INVALID_DATE_RANGE_MESSAGE = "Entered an invalid date range format";

    private String time = null;
    private String startTime = null;
    private String endTime = null;
    private String date = null;
    private String startDate = null;
    private String endDate = null;

    private static String TODAY_ARG = "today";
    private static String TMR_ARG = "tomorrow";

```
###### \java\seedu\whatnow\model\task\TaskTime.java
``` java
    public TaskTime(String time, String startTime, String endTime, String date, String startDate, String endDate)
            throws IllegalValueException {
        if(date != null && startDate == null && endDate == null) {
            if (!isValidDate(date)) {
                throw new IllegalValueException(INVALID_DATE_MESSAGE);
            }
            if (TODAY.matcher(date).find()) {
                this.date = TaskDate.assignTodayDate();
            } else if (TOMORROW.matcher(date).find()) {
                this.date = TaskDate.assignTmrDate();
            }
        }
        else if (date == null && startDate != null && endDate != null) {
            if (TODAY.matcher(startDate).find() || TOMORROW.matcher(startDate).find()) {
                startDate = TaskDate.performStartDate(startDate);
            }
            if (TODAY.matcher(endDate).find() || TOMORROW.matcher(endDate).find()) {
                endDate = TaskDate.performEndDate(endDate);
            }
            if (!isValidDateRange(startDate, endDate)) {
                throw new IllegalValueException(INVALID_DATE_RANGE_MESSAGE);
            }
        }
        if (!isValidTime(time)) {
            throw new IllegalValueException(INVALID_TIME_MESSAGE);
        }
        if (!isValidTimeRange(startTime, endTime)) {
            throw new IllegalValueException(INVALID_TIME_RANGE_MESSAGE);
        }
    }

    public String getFullString() {
        return (date + " " + startDate + " " + endDate + " " + time + " " + startTime + " " + endTime);
    }

    /** returns time */
    public String getTime() {
        return this.time;
    }

    /** returns startTime */
    public String getStartTime() {
        return this.startTime;
    }

    /** returns endTime */
    public String getEndTime() {
        return this.endTime;
    }

    /** returns currentDate */
    public String getDate() {
        return this.date;
    }

    /** returns startDate */
    public String getStartDate() {
        return this.startDate;
    }

    /** returns endDate */
    public String getEndDate() {
        return this.endDate;
    }

    /**
     * This function checks if the reqTime by the user is valid by finding the
     * corresponding format and passes to the method isValidTimeSeq upon finding
     * a match
     * 
     * @param reqTime is the user inputTime
     * @return true if the userInput time is valid, else false
     */
    private boolean isValidTime(String reqTime) {
        if (reqTime == null) {
            return true;
        } else {
            return isValidTimeSeq(reqTime);
        }
    }

    /**
     * Checks if given time given by the user is valid
     * 
     * @param reqTime is the time input by the user
     * @param format    is the format that matches the reqTime's format
     * @return true if the format is valid, else false
     */
    private boolean isValidTimeSeq(String reqTime) {
        /** First checks if it is indeed valid */
        boolean currEarlierThanInput = false;
        Date inputTime = null;
        Date todayTime = null;
        try {
            String currentTime = new SimpleDateFormat(TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT).format(new Date());
            DateFormat tf = new SimpleDateFormat(TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT);
            tf.setLenient(false);

            inputTime = tf.parse(reqTime);
            todayTime = tf.parse(currentTime);
            if (todayTime.before(inputTime)) {
                currEarlierThanInput = true;
            }
        } catch (ParseException ex) {
            logger.warning("At TaskTime.java\n" + ex.getMessage());
            return false;
        }
        /**
         * Attempts to put today's date, if currentTime is earlier than
         * inputTime, put tomorrow's date instead
         */
        if (startDate == null && endDate == null && date == null) {
            return assignTodayOrTmr(currEarlierThanInput, reqTime);
        } else if (date != null) { /** Implies that only 1 date exists */
            if (date.equalsIgnoreCase(TODAY_ARG)) {
                if (currEarlierThanInput) {
                    DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
                    Calendar cal = Calendar.getInstance();
                    String taskDate = dateFormat.format(cal.getTime());
                    date = taskDate;
                    time = reqTime;
                    return true;
                } else
                    return false;
            } else if (date.equalsIgnoreCase(TMR_ARG)) {
                DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
                Calendar cal = Calendar.getInstance();
                cal.add(Calendar.DATE, 1);
                date = dateFormat.format(cal.getTime());
                time = reqTime;
                return true;
            } else {
                if(currEarlierThanInput) {
                    time = reqTime;
                    return true;
                } else {
                    return false;
                }
            }
        } else {
            time = reqTime;
            return true;
        }
    }

    /**
     * Appends today or tomorrow's date depending on currentTime if a date was
     * not input by the user
     * 
     * @param currEarlierThanInput
     *            indicates if a currentTime is indeed earlier than an input
     * @param reqTime
     *            indicates the inputTime by the user
     * @return true regardless as a single inputTime by the user is treated by a
     *         valid
     */
    private boolean assignTodayOrTmr(boolean currEarlierThanInput, String reqTime) {
        if (currEarlierThanInput) {
            DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
            Calendar cal = Calendar.getInstance();
            String taskDate = dateFormat.format(cal.getTime());
            date = taskDate;
            time = reqTime;
            return true;
        } else {
            DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
            Calendar cal = Calendar.getInstance();
            cal.add(Calendar.DATE, 1);
            date = dateFormat.format(cal.getTime());
            time = reqTime;
            return true;
        }

    }
    /**
     * This function checks if the givenTimeRange is valid by finding the
     * corresponding regex and passes its corresponding format to a method
     * isValidNumTime
     * 
     * @param beforeTime
     *            is the startTime input by the user
     * @param afterTime
     *            is the endTime input by the user
     * @return true if the timeRangeIsValid, else false
     */
    private boolean isValidTimeRange(String beforeTime, String afterTime) {
        if (beforeTime == null && afterTime == null && time != null) {
            return true;
        } else {
            return isValidNumTime(beforeTime, afterTime);
        }
    }

    /**
     * This function checks the validity of the time range and finds
     * 
     * @param beforeTime
     *            is the user input starting time
     * @param afterTime
     *            is the user input ending time
     * @return true if valid timeFormat range, else return false
     */
    private boolean isValidNumTime(String beforeTime, String afterTime) {
        boolean inputEarlierThanCurrent = false;
        boolean beforeEarlierThanAfter = false;
        Date inputBeforeTime = null;
        Date inputAfterTime = null;
        Date todayTime = null;
        try {
            String currentTime = new SimpleDateFormat(TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT).format(new Date());
            DateFormat tf = new SimpleDateFormat(TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT);
            tf.setLenient(false);
            inputBeforeTime = tf.parse(beforeTime);
            inputAfterTime = tf.parse(afterTime);
            todayTime = tf.parse(currentTime);
            if (inputBeforeTime.before(todayTime) || inputAfterTime.before(todayTime)) {
                inputEarlierThanCurrent = true;
            }
            if (inputBeforeTime.before(inputAfterTime)) {
                beforeEarlierThanAfter = true;
            }
        } catch (ParseException ex) {
            logger.warning("At TaskTime.java, isValidNumTime:\n" + ex.getMessage());
            return false;
        }

        if (beforeEarlierThanAfter) {
            return performBeforeEarlierThanAfter(inputEarlierThanCurrent, beforeTime, afterTime);
        } else {
            if (startDate != null && endDate != null) {
                if (!startDate.equals(endDate)) {
                    startTime = beforeTime;
                    endTime = afterTime;
                    return true;
                } else {
                    return false;
                }
            }
            return false;
        }
    }

    /**
     * If user input earlierTime is indeed earlier than afterTime, compares with
     * currTime and appends the correct date and respective time
     * 
     * @return true if Time range is indeed valid , else false
     */
    private boolean performBeforeEarlierThanAfter(boolean inputEarlierThanCurrent, String beforeTime, String afterTime) {
        if (startDate == null && endDate == null && date == null) {
            if (!inputEarlierThanCurrent) {
                DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
                Calendar cal = Calendar.getInstance();
                String taskDate = dateFormat.format(cal.getTime());
                date = taskDate;
                startTime = beforeTime;
                endTime = afterTime;
                return true;
            } else {
                DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
                Calendar cal = Calendar.getInstance();
                cal.add(Calendar.DATE, 1);
                date = dateFormat.format(cal.getTime());
                startTime = beforeTime;
                endTime = afterTime;
                return true;
            }
        } else if (date != null) {
            if (date.equals(TODAY_ARG)) {
                if (!inputEarlierThanCurrent) {
                    DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
                    Calendar cal = Calendar.getInstance();
                    String taskDate = dateFormat.format(cal.getTime());
                    date = taskDate;
                    startTime = beforeTime;
                    endTime = afterTime;
                    return true;
                } else {
                    return false;
                }
            } else if (date.equals(TMR_ARG)) {
                DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
                Calendar cal = Calendar.getInstance();
                cal.add(Calendar.DATE, 1);
                date = dateFormat.format(cal.getTime());
                startTime = beforeTime;
                endTime = afterTime;
                return true;
            } else {
                startTime = beforeTime;
                endTime = afterTime;
                return true;
            }
        } else {
            startTime = beforeTime;
            endTime = afterTime;
            return true;
        }
    }

    /**
     * Checks if a particular date is valid i.e. not before currentDate and is a
     * valid sequence num is to be used to indicate what date im referring to
     * i.e. 0 for variable date, 1 for variable startDate, 2 for variable
     * endDate
     * 
     * @return true if valid, else return false
     */
    private boolean isValidDate(String reqDate) {
        if (reqDate == null) {
            date = null;
            return true;
        } else if (reqDate.equalsIgnoreCase(TODAY_ARG)) {
            date = TODAY_ARG;
            return true;
        } else if (reqDate.equalsIgnoreCase(TMR_ARG)) {
            date = TMR_ARG;
            return true;
        } else {
            return isValidNumDate(reqDate);
        }
    }

    /**
     * This function checks whether the givenDate by the user is valid by
     * placing it through different checks.
     * 
     * @param reqDate
     *            is the userInput time
     * @param format
     *            is the format that matches the user inputTime
     * @return true if the time is valid, else false
     */
```
