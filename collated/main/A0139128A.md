# A0139128A
###### \java\seedu\whatnow\logic\commands\AddCommand.java
``` java
	@Override
	public CommandResult execute() {
		assert model != null;
		try {
			model.addTask(toAdd);
			model.getUndoStack().push(COMMAND_WORD);
			model.getDeletedStackOfTasksAdd().push(toAdd);
			Recurrence recurring = new Recurrence(toAdd.getPeriod(), toAdd.getTaskDate(), toAdd.getStartDate(), toAdd.getEndDate(), toAdd.getEndPeriod());
			if (recurring.hasRecurring()) {
			    addRecurring(recurring);
			}
		} catch (UniqueTaskList.DuplicateTaskException e) {
			return new CommandResult(MESSAGE_DUPLICATE_TASK);
		}
		return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
	}
}
```
###### \java\seedu\whatnow\logic\commands\ClearCommand.java
``` java
    @Override
    public CommandResult execute() {
        assert model != null;

        model.resetData(WhatNow.getEmptyWhatNow());
        model.getUndoStack().push(COMMAND_WORD);
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Redo the previous action "
            + "Parameters: No parameters" + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = "Redo Successfully";
    public static final String MESSAGE_FAIL = "Redo failure due to unexisting undo commands";

    public static final String UNKNOWN_COMMAND_FOUND = "Unknown Command found";

    public static final String MESSAGE_LIST_NO_REDO_LIST = " No list command to redo";
    
    private static final Logger logger = LogsCenter.getLogger(StorageManager.class);

```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    @Override
    public CommandResult execute() throws TaskNotFoundException {
        assert model != null;
        if (model.getRedoStack().isEmpty()) {
            return new CommandResult(MESSAGE_FAIL);
        } else {
            String reqCommand = model.getRedoStack().pop();
            model.getUndoStack().push(reqCommand);
            return performReqRedo(reqCommand);
        }
    }

```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    private CommandResult performRedoAdd() {
        assert model != null;
        if (model.getDeletedStackOfTasksAddRedo().isEmpty()) {
            return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
        } else {
            try {
                ReadOnlyTask reqTask = model.getDeletedStackOfTasksAddRedo().pop();
                model.addTask((Task) reqTask);
                model.getDeletedStackOfTasksAdd().push(reqTask);
            } catch (DuplicateTaskException e) {
                return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
            }
            return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS));
        }
    }

```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    private CommandResult performRedoDelete() {
        if (model.getDeletedStackOfTasksRedo().isEmpty() || model.getDeletedStackOfTasksIndexRedo().isEmpty()) {
            return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
        } else {
            ReadOnlyTask taskToDelete = model.getDeletedStackOfTasksRedo().pop();
            model.getDeletedStackOfTasks().push(taskToDelete);
            int idxToRedoAdd = model.getDeletedStackOfTasksIndexRedo().pop();
            try {
                model.deleteTask((Task) taskToDelete);
                model.getDeletedStackOfTasksIndex().push(idxToRedoAdd);
            } catch (TaskNotFoundException tnfe) {
                return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
            }
            return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS));
        }
    }

```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    private CommandResult performRedoList() {
        if (model.getStackOfListTypesRedo().isEmpty()) {
            return new CommandResult(MESSAGE_LIST_NO_REDO_LIST);
        } else {
            String prevCommandListType = model.getStackOfListTypesRedo().pop();
            model.getStackOfListTypes().push(prevCommandListType);
            return performReqRedoList(prevCommandListType);
        }
    }

    private CommandResult performReqRedoList(String prevCommandListType) {
        if (prevCommandListType.equals(ListCommand.TASK_STATUS_ALL)) {
            model.updateFilteredListToShowAll();
            model.updateFilteredScheduleListToShowAll();
            return new CommandResult(UndoCommand.MESSAGE_SUCCESS);
        } else if (prevCommandListType.equals(ListCommand.TASK_STATUS_INCOMPLETE)) {
            model.updateFilteredListToShowAllIncomplete();
            model.updateFilteredScheduleListToShowAllIncomplete();
            return new CommandResult(UndoCommand.MESSAGE_SUCCESS);
        } else {
            model.updateFilteredListToShowAllCompleted();
            model.updateFilteredScheduleListToShowAllCompleted();
            return new CommandResult(UndoCommand.MESSAGE_SUCCESS);
        }
    }

```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    private CommandResult performRedoMarkDone() {
        if (model.getStackOfMarkDoneTaskRedo().isEmpty()) {
            return new CommandResult(RedoCommand.MESSAGE_FAIL);
        } else {
            ReadOnlyTask taskToMark = model.getStackOfMarkDoneTaskRedo().pop();
            try {
                model.markTask(taskToMark);
                model.getStackOfMarkDoneTask().push(taskToMark);
            } catch (TaskNotFoundException tnfe) {
                return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
            }
            return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS));
        }
    }

```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    private CommandResult performRedoMarkUnDone() {
        if (model.getStackOfMarkUndoneTaskRedo().isEmpty()) {
            return new CommandResult(RedoCommand.MESSAGE_FAIL);
        } else {
            ReadOnlyTask taskToMark = model.getStackOfMarkDoneTaskRedo().pop();
            try {
                model.unMarkTask(taskToMark);
                model.getStackOfMarkUndoneTask().push(taskToMark);
            } catch (TaskNotFoundException tnfe) {
                return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
            }
            return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS));
        }
    }

```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    private CommandResult performRedoUpdate() throws TaskNotFoundException {
        assert model != null;
        if (model.getOldTask().isEmpty() && model.getNewTask().isEmpty()) {
            return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
        } else {
            ReadOnlyTask originalTask = model.getNewTask().pop();
            ReadOnlyTask wantedTask = model.getOldTask().pop();
            model.getOldTask().push(originalTask);
            model.getNewTask().push(wantedTask);
            try {
                model.updateTask(originalTask, (Task) wantedTask);
            } catch (UniqueTaskList.DuplicateTaskException utle) {
                model.getOldTask().pop();
                model.getNewTask().pop();
                return new CommandResult(RedoCommand.MESSAGE_FAIL);
            }
            return new CommandResult(RedoCommand.MESSAGE_SUCCESS);
        }
    }

```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
    private CommandResult performRedoClear() {
        model.resetData(WhatNow.getEmptyWhatNow());
        return new CommandResult(RedoCommand.MESSAGE_SUCCESS);
    }
}
```
###### \java\seedu\whatnow\logic\commands\UndoCommand.java
``` java
package seedu.whatnow.logic.commands;

import java.io.IOException;
import java.nio.file.FileSystems;
import java.util.Optional;
import java.util.logging.Logger;

import seedu.whatnow.commons.core.Config;
import seedu.whatnow.commons.core.LogsCenter;
import seedu.whatnow.commons.exceptions.DataConversionException;
import seedu.whatnow.commons.util.ConfigUtil;
import seedu.whatnow.commons.util.StringUtil;
import seedu.whatnow.model.task.ReadOnlyTask;
import seedu.whatnow.model.task.Task;
import seedu.whatnow.model.task.UniqueTaskList;
import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;
import seedu.whatnow.storage.StorageManager;

public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo previous task in WhatNow "
            + "Parameters: No parameters" + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = "Undo Successfully";
    public static final String MESSAGE_FAIL = "Undo failure due to unexisting previous commands";

    public static final String UNKNOWN_COMMAND_FOUND = "Unknown Command Found in Undo";

    public static final String MESSAGE_LIST_NOT_ENTERED = " No previous list command was entered";

    private static final Logger logger = LogsCenter.getLogger(StorageManager.class);
    
    public final String ADD_COMMAND = "add";
    public final String DELETE_COMMAND = "delete";
    public final String LIST_COMMAND = "list";
    public final String MARKDONE_COMMAND = "done";
    public final String MARKUNDONE_COMMAND = "undone";
    public final String UPDATE_COMMAND = "update";
    public final String CLEAR_COMMAND = "clear";
    public final String CHANGE_COMMAND = "change";

    @Override
    public CommandResult execute() throws DuplicateTaskException, TaskNotFoundException {
        assert model != null;
        if (model.getUndoStack().isEmpty()) {
            return new CommandResult(MESSAGE_FAIL);
        } else {
            String reqCommand = model.getUndoStack().pop();
            model.getRedoStack().push(reqCommand);
            return performReqUndo(reqCommand);
        }
    }

    private CommandResult performReqUndo(String reqCommand) throws TaskNotFoundException {
        if (reqCommand.equals(ADD_COMMAND)) {
            return performUndoAdd();
        } else if (reqCommand.equals(DELETE_COMMAND)) {
            return performUndoDelete();
        } else if (reqCommand.equals(LIST_COMMAND)) {
            return performUndoList();
        } else if (reqCommand.equals(MARKDONE_COMMAND)) {
            return performUndoMarkDone();
        } else if (reqCommand.equals(MARKUNDONE_COMMAND)) {
            return performUndoMarkUnDone();
        } else if (reqCommand.equals(UPDATE_COMMAND)) {
            return performUndoUpdate();
        } else if (reqCommand.equals(CLEAR_COMMAND)) {
            return performUndoClear();
        } else if(reqCommand.equals(CHANGE_COMMAND)) {
            return performUndoChange();
        } else {
            return new CommandResult(UNKNOWN_COMMAND_FOUND);
        }
    }

    private CommandResult performUndoAdd() {
        assert model != null;
        if (model.getDeletedStackOfTasksAdd().isEmpty()) {
            return new CommandResult(String.format(UndoCommand.MESSAGE_FAIL));
        } else {
            try {
                ReadOnlyTask reqTask = model.getDeletedStackOfTasksAdd().pop();
                model.getDeletedStackOfTasksAddRedo().push(reqTask);
                model.deleteTask(reqTask);
            } catch (TaskNotFoundException tnfe) {
                return new CommandResult(String.format(UndoCommand.MESSAGE_FAIL));
            }
            return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS));
        }
    }

```
###### \java\seedu\whatnow\model\Model.java
``` java
    /**
     * Clears existing backing model and replaces with the provided new data.
     */
    void resetData(ReadOnlyWhatNow newData);

    /**
     * Reverts to the pre-existing backing model and replaces with backup-ed
     * data
     */
    void revertData();

    /** Returns the WhatNow */
    ReadOnlyWhatNow getWhatNow();

    // =========== Methods for Task List
    // ===============================================================

    /** Deletes the given task. */
    int deleteTask(ReadOnlyTask target) throws TaskNotFoundException;

    /** Adds the given task */
    void addTask(Task task) throws DuplicateTaskException;

    /** Adds the given task at specific index */
    void addTaskSpecific(Task task, int idx) throws DuplicateTaskException;

```
###### \java\seedu\whatnow\model\Model.java
``` java
    /** Gets the UndoStack if possible */
    Stack<String> getUndoStack();

    /** Gets the redoStack if possible */
    Stack<String> getRedoStack();

    /** Gets the oldTask if possible */
    Stack<ReadOnlyTask> getOldTask();

    /** Gets the newTask if possible */
    Stack<ReadOnlyTask> getNewTask();

    /** Gets the deletedStackOfTask that corresponds to deleteCommand */
    Stack<ReadOnlyTask> getDeletedStackOfTasks();

    /** Gets the deletedStackOfTsksIndex that corresponds to deleteCommand */
    Stack<Integer> getDeletedStackOfTasksIndex();

    /** Gets the deletedStackOfTaskRedo that corresponds to deleteCommand */
    Stack<ReadOnlyTask> getDeletedStackOfTasksRedo();

    /**
     * Gets the deletedStackOfTasksIndexRedo that corresponds to deleteCommand
     */
    Stack<Integer> getDeletedStackOfTasksIndexRedo();

    /** Gets the deleted StackOfTasks that corresponds to AddCommand */
    Stack<ReadOnlyTask> getDeletedStackOfTasksAdd();

    /** Gets the deleted StackOfTasksRedo that corresponds to AddCommand */
    Stack<ReadOnlyTask> getDeletedStackOfTasksAddRedo();

    /** Gets Stack of Task that were marked */
    Stack<ReadOnlyTask> getStackOfMarkDoneTask();

    /** Gets stack of Task that were marked and corresponds to RedoCommand */
    Stack<ReadOnlyTask> getStackOfMarkDoneTaskRedo();

    /** Gets stack of Task that were marked and corresponds to UndoneCommand */
    Stack<ReadOnlyTask> getStackOfMarkUndoneTask();

    /** Gets stack of Task that were marked and corresponds to RedoCommand */
    Stack<ReadOnlyTask> getStackOfMarkUndoneTaskRedo();

    /**
     * Gets a stack of String that corresponds to the list of commands that were
     * executed
     */
    Stack<String> getStackOfListTypes();

    /**
     * Gets a stack of String that corresponds to the list of Commands that were
     * undone
     */
    Stack<String> getStackOfListTypesRedo();
    
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    /**
     * Initializes a ModelManager with the given WhatNow WhatNow and its
     * variables should not be null
     */
    public ModelManager(WhatNow src, UserPrefs userPrefs) {
        super();
        assert src != null;
        assert userPrefs != null;

        logger.fine("Initializing with WhatNow: " + src + " and user prefs " + userPrefs);

        whatNow = new WhatNow(src);
        new Config();
        filteredTasks = new FilteredList<>(whatNow.getTasks());
        filteredSchedules = new FilteredList<>(whatNow.getTasks());
        filteredOverdue = new FilteredList<>(whatNow.getTasks());
        stackOfUndo = new Stack<>();
        stackOfRedo = new Stack<>();
        stackOfOldTask = new Stack<>();
        stackOfNewTask = new Stack<>();
        stackOfWhatNow = new Stack<>();
        stackOfDeletedTasks = new Stack<>();
        stackOfDeletedTaskIndex = new Stack<>();
        stackOfDeletedTasksRedo = new Stack<>();
        stackOfDeletedTaskIndexRedo = new Stack<>();
        stackOfDeletedTasksAdd = new Stack<>();
        stackOfDeletedTasksAddRedo = new Stack<>();
        stackOfMarkDone = new Stack<>();
        stackOfMarkDoneRedo = new Stack<>();
        stackOfMarkUndone = new Stack<>();
        stackOfMarkUndoneRedo = new Stack<>();
        stackOfListTypes = new Stack<>();
        stackOfListTypesRedo = new Stack<>();
        stackOfChangeFileLocationOld = new Stack<>();
        stackOfChangeFileLocationNew = new Stack<>();
        freeTimes = new HashMap<String, FreePeriod>();
        initialiseFreeTime();
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    public ModelManager(ReadOnlyWhatNow initialData, UserPrefs userPrefs) {
        whatNow = new WhatNow(initialData);
        new Config();
        filteredTasks = new FilteredList<>(whatNow.getTasks());
        filteredSchedules = new FilteredList<>(whatNow.getTasks());
        filteredOverdue = new FilteredList<>(whatNow.getTasks());
        stackOfUndo = new Stack<>();
        stackOfRedo = new Stack<>();
        stackOfOldTask = new Stack<>();
        stackOfNewTask = new Stack<>();
        stackOfWhatNow = new Stack<>();
        stackOfDeletedTasks = new Stack<>();
        stackOfDeletedTaskIndex = new Stack<>();
        stackOfDeletedTasksRedo = new Stack<>();
        stackOfDeletedTaskIndexRedo = new Stack<>();
        stackOfDeletedTasksAdd = new Stack<>();
        stackOfDeletedTasksAddRedo = new Stack<>();
        stackOfMarkDone = new Stack<>();
        stackOfMarkDoneRedo = new Stack<>();
        stackOfMarkUndone = new Stack<>();
        stackOfMarkUndoneRedo = new Stack<>();
        stackOfListTypes = new Stack<>();
        stackOfListTypesRedo = new Stack<>();
        stackOfChangeFileLocationOld = new Stack<>();
        stackOfChangeFileLocationNew = new Stack<>();
        freeTimes = new HashMap<String, FreePeriod>();
        initialiseFreeTime();
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public void resetData(ReadOnlyWhatNow newData) {
        stackOfWhatNow.push(new WhatNow(whatNow));
        whatNow.resetData(newData);
        initialiseFreeTime();
        indicateWhatNowChanged();
    }

    @Override
    public synchronized void revertData() {
        whatNow.revertEmptyWhatNow(stackOfWhatNow.pop());
        indicateWhatNowChanged();
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    public synchronized void addTaskSpecific(Task task, int idx) throws UniqueTaskList.DuplicateTaskException {
        whatNow.addTaskSpecific(task, idx);
        updateFilteredListToShowAllIncomplete();
        indicateAddTask(task, true);
        indicateWhatNowChanged();
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<String> getUndoStack() {
        return stackOfUndo;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<String> getRedoStack() {
        return stackOfRedo;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getOldTask() {
        return stackOfOldTask;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getNewTask() {
        return stackOfNewTask;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getDeletedStackOfTasks() {
        return stackOfDeletedTasks;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    public Stack<Integer> getDeletedStackOfTasksIndex() {
        return stackOfDeletedTaskIndex;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    public Stack<Integer> getDeletedStackOfTasksIndexRedo() {
        return stackOfDeletedTaskIndexRedo;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getDeletedStackOfTasksRedo() {
        return stackOfDeletedTasksRedo;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getDeletedStackOfTasksAdd() {
        return stackOfDeletedTasksAdd;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getDeletedStackOfTasksAddRedo() {
        return stackOfDeletedTasksAddRedo;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getStackOfMarkDoneTask() {
        return stackOfMarkDone;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getStackOfMarkDoneTaskRedo() {
        return stackOfMarkDoneRedo;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    public Stack<ReadOnlyTask> getStackOfMarkUndoneTaskRedo() {
        return stackOfMarkUndoneRedo;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<String> getStackOfListTypes() {
        return stackOfListTypes;
    }

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<String> getStackOfListTypesRedo() {
        return stackOfListTypesRedo;
    }
    
```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
public class TaskDate {
    public static final String MESSAGE_NAME_CONSTRAINTS = "Task Date should be represented as one of the followings:\n"
            + "dd/mm/yyyy\n" + "day month year\n" + "today\n" + "tomorrow\n";
    public static final String EXPIRED_TASK_DATE = "Task Date cannot be in the past!";
    public static final String INVALID_TASK_DATE_RANGE_FORMAT = "The task date range is invalid!";

    public static final String DATE_ALPHA_WITH_YEAR_VALIDATION_REGEX = "([0-9]{2}+[\\w\\.])+([0-9]{4})"; // To
                                                                                                         // be
                                                                                                         // updated
    public static final String DATE_ALPHA_WITHOUT_YEAR_VALIDATION_REGEX = "([0-9]{2}+[\\w\\.])";

    public static final String DATE_NUM_SLASH_WITH_YEAR_VALIDATION_REGEX = "([0-9]{2}+)/([0-9]{2}+)/([0-9]{4})"; // "\\d{2}/\\d{2}/\\d{4}";
                                                                                                                 // //To
                                                                                                                 // be
                                                                                                                 // updated
    public static final String DATE_NUM_SLASH_WITHOUT_YEAR_VALIDATION_REGEX = "([0-9]{2})/([0-9]{2})";// "\\d{2}/\\d{2}";
    public static final String DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_DAY_REGEX = "([0-9]{1}+)/([0-9]{2}+)/([0-9]{4})";
    public static final String DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_MONTH_REGEX = "([0-9]{2}+)/([1-9]{1}+)/([0-9]{4})";
    public static final String DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_DAY_AND_MONTH_REGEX = "([0-9]{1}+)/([0-9]{1}+)/([0-9]{4})";

    public static final String DATE_NUM_SLASH_WITH_YEAR_FORMAT = "dd/MM/yyyy";
    public static final String DATE_NUM_SLASH_WITHOUT_YEAR_FORMAT = "dd/MM";
    public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_FORMAT = "d/MM/yyyy";
    public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_MONTH_FORMAT = "dd/M/yyyy";
    public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_AND_MONTH_FORMAT = "d/M/yyyy";

    public static final String DATE_AlPHA_WHITESPACE_WITH_YEAR_FORMAT = "dd MMMM yyyy ";
    public static final String DATE_ALPHA_WHITESPACE_WITHOUT_YEAR_FORMAT = "dd MMMM";

    public static final String DATE_NUM_SLASH_WITH_YEAR_VALIDATION_MODIFIED_REGEX = "^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$";

    public static ArrayList<String> ListOfDateRegex;
    public static ArrayList<String> ListOfDateFormat;

    private static final String TODAY = "today";
    private static final String TMR = "tomorrow";
    private String fullDate;
    private String startDate;
    private String endDate;

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    /**
     * Validates given date
     *
     * @throw IllegalValueException if given date is invalid
     */
    public TaskDate(String taskDate, String startDate, String endDate)
            throws IllegalValueException, java.text.ParseException {
        performAddDateFormatRegex();

        if (taskDate == null && startDate != null && endDate != null) {
            if (!isValidDateRange(startDate, endDate)) {
                throw new IllegalValueException(INVALID_TASK_DATE_RANGE_FORMAT);
            }
        } else {
            if (!isValidDate(taskDate)) {
                throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
            }
            if (taskDate.equals(TODAY)) {
                assignTodayDate(taskDate);
            } else if (taskDate.equals(TMR)) {
                assignTmrDate(taskDate);
            }
        }
    }

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    /**
     * Adds all the relevant Date format and regex that is neeeded to find the
     * corresponding user input
     */
    private void performAddDateFormatRegex() {
        ListOfDateRegex = new ArrayList<String>();
        ListOfDateFormat = new ArrayList<String>();
        ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_VALIDATION_REGEX);
        ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_DAY_REGEX);
        ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_MONTH_REGEX);
        ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_DAY_AND_MONTH_REGEX);
        ListOfDateRegex.add(DATE_NUM_SLASH_WITHOUT_YEAR_VALIDATION_REGEX);
        ListOfDateRegex.add(DATE_ALPHA_WITH_YEAR_VALIDATION_REGEX);
        ListOfDateRegex.add(DATE_ALPHA_WITHOUT_YEAR_VALIDATION_REGEX);
        ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
        ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_FORMAT);
        ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_MONTH_FORMAT);
        ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_AND_MONTH_FORMAT);
        ListOfDateFormat.add(DATE_NUM_SLASH_WITHOUT_YEAR_FORMAT);
        ListOfDateFormat.add(DATE_AlPHA_WHITESPACE_WITH_YEAR_FORMAT);
        ListOfDateFormat.add(DATE_ALPHA_WHITESPACE_WITHOUT_YEAR_FORMAT);
    }

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    /** Assigns today's date to fullDate */
    private void assignTodayDate(String taskDate) {
        DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
        Calendar cal = Calendar.getInstance();
        taskDate = dateFormat.format(cal.getTime());
        fullDate = taskDate;
    }

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    /** Assigns tmr's date to fullDate */
    private void assignTmrDate(String taskDate) {
        DateFormat dateFormat2 = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
        Calendar cal2 = Calendar.getInstance();

        cal2.add(Calendar.DATE, 1);
        taskDate = dateFormat2.format(cal2.getTime());
        fullDate = taskDate;
    }

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    /**
     * 
     * @param test
     *            is a given user date input
     * @return the validity of the user date input by passing it to methods of
     *         different regex
     * @throws java.text.ParseException
     * @throws IllegalValueException
     */
    private boolean isValidDate(String reqDate) throws java.text.ParseException, IllegalValueException {
        if (reqDate.equals(TODAY) || reqDate.equals(TMR)) {
            return true;
        } else {
            for (int i = 0; i < ListOfDateFormat.size() && i < ListOfDateRegex.size(); i++) {
                if (reqDate.matches(ListOfDateRegex.get(i))) {
                    return isValidNumDate(reqDate, ListOfDateFormat.get(i));
                }
            }
            return false;
        }
    }

    /**
     * This function finds the respective regex that matches the user input and
     * sends to isValidDateRangeValidator to check if the two dates are really
     * valid
     * 
     * @param startDate
     *            is the user input startingDate
     * @param endDate
     *            is the user input endingDate
     * @return true is valid date range, else false
     * @throws java.text.ParseException
     */
```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    private boolean isValidDateRange(String startDate, String endDate) throws java.text.ParseException {
        for (int i = 0; i < ListOfDateFormat.size() && i < ListOfDateRegex.size(); i++) {
            if ((startDate.matches(ListOfDateRegex.get(i)) && (endDate.matches(ListOfDateRegex.get(i))))) {
                return isValidDateRangeValidator(startDate, endDate, ListOfDateFormat.get(i));
            }
        }
        return false;
    }

```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
    private boolean isValidDateRangeValidator(String beforeDate, String afterDate, String format) {
        if (beforeDate == null && afterDate == null) {
            return true;
        }
        boolean validDateRange = false;
        boolean sameDate = false;
        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
        Date beginDate = null;
        Date finishDate = null;
        try {
            beginDate = sdf.parse(beforeDate);
            finishDate = sdf.parse(afterDate);
            if (beginDate.before(
                    finishDate)) { /**
                                    * Checks if supposedly earlier date is
                                    * indeed earlier than the later date
                                    */
                validDateRange = true;
            }
            if (beginDate
                    .equals(finishDate)) { /**
                                            * Checks if supposedly earlier date
                                            * is indeed equals to the later date
                                            */
                sameDate = true;
            }
        } catch (ParseException e) {
            return false;
        }
        /**
         * Following is done because the default date gotten from currentDate is
         * always 0000(time) i.e. always earlier than the user inputDates
         */
        Calendar before = new GregorianCalendar();
        before = setGregorian(before, beginDate);
        beginDate = before.getTime();

        Calendar after = new GregorianCalendar();
        after = setGregorian(after, finishDate);
        finishDate = after.getTime();

        /**
         * Following checks if the user input date is invalid i.e before today's
         * date
         */
        Calendar current = new GregorianCalendar();
        current = setGregorianCurrent(current);
        Date currDate = current.getTime();

        if (currDate.compareTo(beginDate) > 0 || currDate.compareTo(finishDate) > 0) {
            return false;
        } else if (!validDateRange && !sameDate) {
            return false;
        } else {
            startDate = beforeDate;
            endDate = afterDate;
            return true;
        }
    }

    /**
     * @param test
     *            is the date input by the user
     * @param format
     *            is the type of format that the date input will be tested
     *            against with
     * @return the validity of the user input
     * @throws java.text.ParseException
     * @throws IllegalValueException
     */
    private boolean isValidNumDate(String incDate, String format)
            throws java.text.ParseException, IllegalValueException {
        Date inputDate = null;
        try {
            DateFormat df = new SimpleDateFormat(format);
            df.setLenient(false);

            inputDate = df.parse(incDate);
        } catch (ParseException ex) {
            ex.printStackTrace();
            return false;
        }

        Calendar input = new GregorianCalendar();
        input = setGregorian(input, inputDate);
        inputDate = input.getTime();

        /**
         * Following checks if the user input date is invalid i.e before today's
         * date
         */
        Calendar current = new GregorianCalendar();
        current = setGregorianCurrent(current);
        Date currDate = current.getTime();

        if (currDate.compareTo(inputDate) > 0) {
            throw new IllegalValueException(EXPIRED_TASK_DATE);
        }

        /**
         * The following will ensure the date format to be
         * DATE_NUM_SLASH_WITH_YEAR_FORMAT
         */
        if (format.equals(DATE_NUM_SLASH_WITHOUT_YEAR_FORMAT)) {
            Calendar now = Calendar.getInstance();
            int yearInt = now.get(Calendar.YEAR);
            String year = String.valueOf(yearInt);
            incDate.concat(year);
            fullDate = incDate;
            return true;
        } else if (format.equals(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_FORMAT)) {
            fullDate = "0" + incDate;
            return true;
        } else if (format.equals(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_MONTH_FORMAT)) {
            String toReplaceFullDate = incDate;
            String[] split = toReplaceFullDate.split("/");
            fullDate = split[0] + "/0" + split[1] + "/" + split[2];
            return true;
        } else if (format.equals(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_AND_MONTH_FORMAT)) {
            String toReplaceFullDate = incDate;
            String[] split = toReplaceFullDate.split("/");
            fullDate = "0" + split[0] + "/0" + split[1] + "/" + split[2];
            return true;
        } else {
            fullDate = incDate;
            return true;
        }
    }

    /**
     * This method sets the date to be of the latest time as a date always comes
     * attached with a default time and there is a need to overwrite this timing
     * to the latest so that it can be compared with the current date
     */
    private Calendar setGregorian(Calendar cal, Date reqDate) {
        cal.setTime(reqDate);
        cal.set(Calendar.HOUR_OF_DAY, 23);
        cal.set(Calendar.MINUTE, 59);
        cal.set(Calendar.SECOND, 59);
        return cal;
    }

    /** Gets the current Date and set it to earliest */
    private Calendar setGregorianCurrent(Calendar cal) {
        cal.set(Calendar.HOUR_OF_DAY, 00);
        cal.set(Calendar.MINUTE, 00);
        cal.set(Calendar.SECOND, 00);
        return cal;
    }

    @Override
    public String toString() {
        if (fullDate == null) {
            return startDate + " " + endDate;
        } else {
            return fullDate;
        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDate // instanceof handles nulls
                        && this.fullDate.equals(((TaskDate) other).fullDate)); // state
                                                                               // check
    }

    /** Returns the fullDate */
    public String getDate() {
        return fullDate;
    }

    /** Returns the startDate */
    public String getStartDate() {
        return this.startDate;
    }

    /** Returns the endDate */
    public String getEndDate() {
        return this.endDate;
    }
}
```
###### \java\seedu\whatnow\model\task\TaskTime.java
``` java
package seedu.whatnow.model.task;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;

import seedu.whatnow.commons.exceptions.IllegalValueException;

/**
 * This class checks if the user input date and time are of a valid one by
 * checking currentTime/currentDate/Range and throws its respective message if
 * the input is invalid
 */
public class TaskTime {

    public static final String TWELVE_HOUR_WITH_MINUTES_COLON_REGEX = "(((\\d|\\d\\d):\\d\\d)(am|pm))";
    public static final String TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT = "h:mma"; //E.g. 1:50pm
    public static final String TWELVE_HOUR_WITH_MINUTES_DOT_REGEX = "(((\\d|\\d\\d)\\.\\d\\d)(am|pm))";
    public static final String TWELVE_HOUR_WITH_MINUTES_DOT_FORMAT = "h.mma"; //E.g.1.45pm
    public static final String TWELVE_HOUR_WITHOUT_MINUTES_REGEX = "([1]*[0-9]{1}+)(am|pm)";
    public static final String TWELVE_HOUR_WITHOUT_MINUTES_EXTEND_FORMAT = "hha";

    public static final String DATE_NUM_SLASH_WITH_YEAR_FORMAT = "dd/MM/yyyy";
    public static final String DATE_NUM_SLASH_WITH_YEAR_VALIDATION_REGEX = "([0-9]{2}+)/([0-9]{2}+)/([0-9]{4})";

    public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_FORMAT = "d/MM/yyyy";
    public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_VALIDATION_REGEX = "([1-9]{1}+)/([0-9]{2}+)/([0-9]{4})";

    public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_MONTH_FORMAT = "dd/M/yyyy";
    public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_MONTH_VALIDATION_REGEX = "([1-9]{2}+)/([1-9]{1}+)/([0-9]{4})";

    public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_AND_MONTH_FORMAT = "d/M/yyyy";
    public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_AND_MONTH_VALIDATION_REGEX = "([1-9]{1}+)/([1-9]{1}+)/([0-9]{4})";

    public static final String DATE_NUM_SLASH_WITHOUT_YEAR_FORMAT = "dd/MM";
    public static final String DATE_NUM_SLASH_WITHOUT_YEAR_VALIDATION_REGEX = "([1-9]{2}+)/([0-9]{2}+)";

    public static final String DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENED_DAY_FORMAT = "d/MM";
    public static final String DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENED_DAY_VALIDATION_REGEX = "([1-9]{1}+)/([0-9]{2}+)";

    public static final String DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENND_DAY_MONTH_FORMAT = "d/M";
    public static final String DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENED_DAY_MONTH_REGEX = "([1-9]{1}+)/([1-9]{1}+)";

    public static final String DATE_AlPHA_WHITESPACE_WITH_YEAR_FORMAT = "dd MMMM yyyy ";
    public static final String DATE_ALPHA_WHITESPACE_WITHOUT_YEAR_FORMAT = "dd MMMM";

    public static final String DATE_NUM_REGEX_WITH_YEAR = "(0?[1-9]|[12][0-9]|3[01])/(0?[1-9]|1[012])/((19|20)\\d\\d)";

    public static ArrayList<String> ListOfDateRegex;
    public static ArrayList<String> ListOfDateFormat;
    public static ArrayList<String> ListOfTimeRegex;
    public static ArrayList<String> ListOfTimeFormat;
    public final String INVALID_TIME_MESSAGE = "Entered an invalid time format";
    public final String INVALID_TIME_RANGE_MESSAGE = "Entered an invalid time range format";
    public final String INVALID_DATE_MESSAGE = "Entered an invalid date format";
    public final String INVALID_DATE_RANGE_MESSAGE = "Entered an invalid date range format";

    private String time = null;
    private String startTime = null;
    private String endTime = null;
    private String date = null;
    private String startDate = null;
    private String endDate = null;

    private static String TODAY = "today";
    private static String TMR = "tomorrow";

    public TaskTime(String time, String startTime, String endTime, String date, String startDate, String endDate)
            throws IllegalValueException {
        prepareListOfDateAndTimeFormatRegex();
        if (!isValidDate(date)) {
            throw new IllegalValueException(INVALID_DATE_MESSAGE);
        }
        if (!isValidDateRange(startDate, endDate)) {
            throw new IllegalValueException(INVALID_DATE_RANGE_MESSAGE);
        }
        if (!isValidTime(time)) {
            throw new IllegalValueException(INVALID_TIME_MESSAGE);
        }
        if (!isValidTimeRange(startTime, endTime)) {
            throw new IllegalValueException(INVALID_TIME_RANGE_MESSAGE);
        }
    }

    /**
     * Prepares the list of format and regex that will be used to find the
     * corresponding format
     */
    private void prepareListOfDateAndTimeFormatRegex() {

        ListOfDateRegex = new ArrayList<String>();
        ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_VALIDATION_REGEX);
        ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_VALIDATION_REGEX);
        ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_MONTH_VALIDATION_REGEX);
        ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_AND_MONTH_VALIDATION_REGEX);
        ListOfDateRegex.add(DATE_NUM_SLASH_WITHOUT_YEAR_VALIDATION_REGEX);
        ListOfDateRegex.add(DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENED_DAY_VALIDATION_REGEX);
        ListOfDateRegex.add(DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENED_DAY_MONTH_REGEX);

        ListOfDateFormat = new ArrayList<String>();
        ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
        ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_FORMAT);
        ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_MONTH_FORMAT);
        ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_AND_MONTH_FORMAT);
        ListOfDateFormat.add(DATE_NUM_SLASH_WITHOUT_YEAR_FORMAT);
        ListOfDateFormat.add(DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENED_DAY_FORMAT);
        ListOfDateFormat.add(DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENND_DAY_MONTH_FORMAT);

        ListOfTimeRegex = new ArrayList<String>();
        ListOfTimeRegex.add(TWELVE_HOUR_WITH_MINUTES_COLON_REGEX);
        ListOfTimeRegex.add(TWELVE_HOUR_WITH_MINUTES_DOT_REGEX);
        ListOfTimeRegex.add(TWELVE_HOUR_WITHOUT_MINUTES_REGEX); // ListOfTimeRegex.add(TWELVE_HOUR_WITHOUT_MINUTES_EXTEND_REGEX);

        ListOfTimeFormat = new ArrayList<String>();
        ListOfTimeFormat.add(TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT);
        ListOfTimeFormat.add(TWELVE_HOUR_WITH_MINUTES_DOT_FORMAT);
        // ListOfTimeFormat.add(TWELVE_HOUR_WITHOUT_MINUTES_FORMAT);
        ListOfTimeFormat.add(TWELVE_HOUR_WITHOUT_MINUTES_EXTEND_FORMAT);
    }

    public String getFullString() {
        return (date + " " + startDate + " " + endDate + " " + time + " " + startTime + " " + endTime);
    }

    /** returns time */
    public String getTime() {
        return this.time;
    }

    /** returns startTime */
    public String getStartTime() {
        return this.startTime;
    }

    /** returns endTime */
    public String getEndTime() {
        return this.endTime;
    }

    /** returns currentDate */
    public String getDate() {
        return this.date;
    }

    /** returns startDate */
    public String getStartDate() {
        return this.startDate;
    }

    /** returns endDate */
    public String getEndDate() {
        return this.endDate;
    }

    /**
     * This function checks if the reqTime by the user is valid by finding the
     * corresponding format and passes to the method isValidTimeSeq upon finding
     * a match
     * 
     * @param reqTime
     *            is the user inputTime
     * @return true if the userInput time is valid, else false
     */
    public boolean isValidTime(String reqTime) {

        if (reqTime == null) {
            return true;
        } else {
            for (int j = 0; j < ListOfTimeRegex.size(); j++) {
                if (reqTime.matches(ListOfTimeRegex.get(j))) {
                    return isValidTimeSeq(reqTime, ListOfTimeFormat.get(j));
                }
            }
            return false;
        }
    }

    /**
     * Checks if given time given by the user is valid
     * 
     * @param reqTime
     *            is the time input by the user
     * @param format
     *            is the format that matches the reqTime's format
     * @return true if the format is valid, else false
     */
    public boolean isValidTimeSeq(String reqTime, String format) {
        /** First checks if it is indeed valid */
        boolean currEarlierThanInput = false;
        Date inputTime = null;
        Date todayTime = null;
        try {
            String currentTime = new SimpleDateFormat(format).format(new Date());
            DateFormat tf = new SimpleDateFormat(format);
            tf.setLenient(false);

            inputTime = tf.parse(reqTime);
            todayTime = tf.parse(currentTime);
            if (todayTime.before(inputTime)) {
                currEarlierThanInput = true;
            }
        } catch (ParseException ex) {
            ex.printStackTrace();
            return false;
        }
        /**
         * Attempts to put today's date, if currentTime is earlier than
         * inputTime, put tomorrow's date instead
         */
        if (startDate == null && endDate == null && date == null) {
            return appendTodayOrTmr(currEarlierThanInput, reqTime);
        } else if (date != null) { /** Implies that only 1 date exists */
            if (date.toLowerCase().equals(TODAY)) {
                if (currEarlierThanInput) {
                    DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
                    Calendar cal = Calendar.getInstance();
                    String taskDate = dateFormat.format(cal.getTime());
                    date = taskDate;
                    time = reqTime;
                    return true;
                } else
                    return false;
            } else if (date.toLowerCase().equals(TMR)) {
                DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
                Calendar cal = Calendar.getInstance();
                cal.add(Calendar.DATE, 1);
                date = dateFormat.format(cal.getTime());
                time = reqTime;
                return true;
            }
        } else {
            time = reqTime;
            return true;
        }
        return false;
    }

    /**
     * Appends today or tomorrow's date depending on currentTime if a date was
     * not input by the user
     * 
     * @param currEarlierThanInput
     *            indicates if a currentTime is indeed earlier than an input
     * @param reqTime
     *            indicates the inputTime by the user
     * @return true regardless as a single inputTime by the user is treated by a
     *         valid
     */
    public boolean appendTodayOrTmr(boolean currEarlierThanInput, String reqTime) {
        if (currEarlierThanInput) {
            DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
            Calendar cal = Calendar.getInstance();
            String taskDate = dateFormat.format(cal.getTime());
            date = taskDate;
            time = reqTime;
            return true;
        } else {
            DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
            Calendar cal = Calendar.getInstance();
            cal.add(Calendar.DATE, 1);
            date = dateFormat.format(cal.getTime());
            time = reqTime;
            return true;
        }
    }

    /**
     * This function checks if the givenTimeRange is valid by finding the
     * corresponding regex and passes its corresponding format to a method
     * isValidNumTime
     * 
     * @param beforeTime
     *            is the startTime input by the user
     * @param afterTime
     *            is the endTime input by the user
     * @return true if the timeRangeIsValid, else false
     */
    public boolean isValidTimeRange(String beforeTime, String afterTime) {
        if (beforeTime == null && afterTime == null && time != null) {
            return true;
        } else {
            for (int i = 0; i < ListOfTimeRegex.size() && i < ListOfTimeFormat.size(); i++) {
                if (beforeTime.matches(ListOfTimeRegex.get(i)) && afterTime.matches(ListOfTimeRegex.get(i))) {
                    return isValidNumTime(beforeTime, afterTime, ListOfTimeFormat.get(i));
                }
            }
        }
        return false;
    }

    /**
     * This function checks the validity of the time range and finds
     * 
     * @param beforeTime
     *            is the user input starting time
     * @param afterTime
     *            is the user input ending time
     * @param format
     *            is the format that matches the format of the startTime
     * @return true if valid timeFormat range, else return false
     */
    public boolean isValidNumTime(String beforeTime, String afterTime, String format) {
        boolean currEarlierThanInput = false;
        boolean beforeEarlierThanAfter = false;
        Date inputBeforeTime = null;
        Date inputAfterTime = null;
        Date todayTime = null;
        try {
            String currentTime = new SimpleDateFormat(format).format(new Date());
            DateFormat tf = new SimpleDateFormat(format);
            tf.setLenient(false);

            inputBeforeTime = tf.parse(beforeTime);
            inputAfterTime = tf.parse(afterTime);
            todayTime = tf.parse(currentTime);
            if (inputBeforeTime.before(todayTime) || inputAfterTime.before(todayTime)) {
                currEarlierThanInput = true;
            }
            if (inputBeforeTime.before(inputAfterTime)) {
                beforeEarlierThanAfter = true;
            }
        } catch (ParseException ex) {
            ex.printStackTrace();
            return false;
        }

        if (beforeEarlierThanAfter) {
            return performBeforeEarlierThanAfter(currEarlierThanInput, beforeTime, afterTime);
        } else {
            if (startDate != null && endDate != null) {
                if (!startDate.equals(endDate)) {
                    startTime = beforeTime;
                    endTime = afterTime;
                    return true;
                } else {
                    return false;
                }
            }
            return false;
        }
    }

    /**
     * If user input earlierTime is indeed earlier than afterTime, compares with
     * currTime and appends the correct date and respective time
     * 
     * @return true if Time range is indeed valid , else false
     */
    private boolean performBeforeEarlierThanAfter(boolean currEarlierThanInput, String beforeTime, String afterTime) {
        if (startDate == null && endDate == null && date == null) {
            if (!currEarlierThanInput) {
                DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
                Calendar cal = Calendar.getInstance();
                String taskDate = dateFormat.format(cal.getTime());
                date = taskDate;
                startTime = beforeTime;
                endTime = afterTime;
                return true;
            } else {
                DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
                Calendar cal = Calendar.getInstance();
                cal.add(Calendar.DATE, 1);
                date = dateFormat.format(cal.getTime());
                startTime = beforeTime;
                endTime = afterTime;
                return true;
            }
        } else if (date != null) {
            if (date.equals(TODAY)) {
                if (!currEarlierThanInput) {
                    DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
                    Calendar cal = Calendar.getInstance();
                    String taskDate = dateFormat.format(cal.getTime());
                    date = taskDate;
                    startTime = beforeTime;
                    endTime = afterTime;
                    return true;
                } else {
                    return false;
                }
            } else if (date.equals(TMR)) {
                DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
                Calendar cal = Calendar.getInstance();
                cal.add(Calendar.DATE, 1);
                date = dateFormat.format(cal.getTime());
                startTime = beforeTime;
                endTime = afterTime;
                return true;
            } else {
                startTime = beforeTime;
                endTime = afterTime;
                return true;
            }
        } else {
            startTime = beforeTime;
            endTime = afterTime;
            return true;
        }
    }

    /**
     * Checks if a particular date is valid i.e. not before currentDate and is a
     * valid sequence num is to be used to indicate what date im referring to
     * i.e. 0 for variable date, 1 for variable startDate, 2 for variable
     * endDate
     * 
     * @return true if valid, else return false
     */
    public boolean isValidDate(String reqDate) {
        if (reqDate == null) {
            date = null;
            return true;
        } else if (reqDate.toLowerCase().equals(TODAY)) {
            date = TODAY;
            return true;
        } else if (reqDate.toLowerCase().equals(TMR)) {
            date = TMR;
            return true;
        } else {
            for (int i = 0; i < ListOfDateFormat.size() && i < ListOfDateRegex.size(); i++) {
                if (reqDate.matches(ListOfDateRegex.get(i))) {
                    return isValidNumDate(reqDate, ListOfDateFormat.get(i));
                }
            }
            return false;
        }
    }

    /**
     * This function checks whether the givenDate by the user is valid by
     * placing it through different checks.
     * 
     * @param reqDate
     *            is the userInput time
     * @param format
     *            is the format that matches the user inputTime
     * @return true if the time is valid, else false
     */
```
