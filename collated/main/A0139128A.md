# A0139128A
###### \java\seedu\whatnow\logic\commands\AddCommand.java
``` java
	@Override
	public CommandResult execute() {
		assert model != null;
		try {
			model.addTask(toAdd);
			model.getUndoStack().push(this);
			model.getDeletedStackOfTasksAdd().push(toAdd);
		} catch (UniqueTaskList.DuplicateTaskException e) {
			return new CommandResult(MESSAGE_DUPLICATE_TASK);
		}
		return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
	}
	
	@Override
	public CommandResult undo() {
		assert model != null;
		if(model.getDeletedStackOfTasksAdd().isEmpty()) {
			return new CommandResult(String.format(UndoCommand.MESSAGE_FAIL));
		}
		try {
			ReadOnlyTask reqTask = model.getDeletedStackOfTasksAdd().pop();
			model.getDeletedStackOfTasksAddRedo().push(reqTask);
			model.deleteTask(reqTask);
		} catch (TaskNotFoundException pnfe) {
			return new CommandResult(String.format(UndoCommand.MESSAGE_FAIL));
		} 
		return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS));
	}
	
	@Override
	public CommandResult redo() {
		assert model != null;
		if(model.getDeletedStackOfTasksAddRedo().isEmpty()) {
			return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));		}
		try {
			ReadOnlyTask reqTask = model.getDeletedStackOfTasksAddRedo().pop();
			model.getDeletedStackOfTasksAdd().push(reqTask);
			model.addTask((Task)reqTask);
		} catch (DuplicateTaskException e) {
			return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
		}
		return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS));
	}
}
```
###### \java\seedu\whatnow\logic\commands\ClearCommand.java
``` java
    @Override
    public CommandResult execute() {
        assert model != null;
        
        model.resetData(WhatNow.getEmptyWhatNow());
        model.getUndoStack().push(this);
        return new CommandResult(MESSAGE_SUCCESS);
    }
    
	@Override
	public CommandResult undo() {
		assert model != null;
		model.revertData();
		return new CommandResult(UndoCommand.MESSAGE_SUCCESS);
	}
	
	@Override
	public CommandResult redo() {
		model.resetData(WhatNow.getEmptyWhatNow());
		return new CommandResult(RedoCommand.MESSAGE_SUCCESS);
	}
}
```
###### \java\seedu\whatnow\logic\commands\DeleteCommand.java
``` java
	@Override
	public CommandResult undo() {
		if(model.getDeletedStackOfTasks().isEmpty()) {
			return new CommandResult(String.format(UndoCommand.MESSAGE_FAIL));
		}
		ReadOnlyTask taskToReAdd = model.getDeletedStackOfTasks().pop();
		model.getDeletedStackOfTasksRedo().push(taskToReAdd);
		try {
			model.addTask((Task)taskToReAdd);
		} catch(DuplicateTaskException e) {
			return new CommandResult(String.format(UndoCommand.MESSAGE_FAIL));
		}
		return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS));
	}
	
	@Override
	public CommandResult redo() {
		if(model.getDeletedStackOfTasksRedo().isEmpty()) {
			return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
		}
		ReadOnlyTask taskToDelete = model.getDeletedStackOfTasksRedo().pop();
		model.getDeletedStackOfTasks().push(taskToDelete);
		try {
			model.deleteTask((Task) taskToDelete);
		} catch(TaskNotFoundException e) {
			return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
		}
		return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS));
	}
}
```
###### \java\seedu\whatnow\logic\commands\ListCommand.java
``` java
	@Override
	public CommandResult undo(){
		if(model.getStackOfListTypes().isEmpty()) {
			return new CommandResult(MESSAGE_LIST_NOT_ENTERED); 
		}
		else {
			String prevListCommand = model.getStackOfListTypes().pop();
			model.getStackOfListTypesRedo().push(prevListCommand);
			if(model.getStackOfListTypes().isEmpty()) {
				model.updateFilteredListToShowAllIncomplete();
				model.updateFilteredScheduleListToShowAllIncomplete();
				return new CommandResult(UndoCommand.MESSAGE_SUCCESS);
			}
			else {
				String reqCommandListType = model.getStackOfListTypes().peek();
				if(reqCommandListType.equals(TASK_STATUS_ALL)) {
					model.updateFilteredListToShowAll();
					model.updateFilteredScheduleListToShowAll();
					return new CommandResult(UndoCommand.MESSAGE_SUCCESS);
				}
				else if(reqCommandListType.equals(TASK_STATUS_INCOMPLETE)) {
					model.updateFilteredListToShowAllIncomplete();
					model.updateFilteredScheduleListToShowAllIncomplete();
					return new CommandResult(UndoCommand.MESSAGE_SUCCESS);
				}
				else {
					model.updateFilteredListToShowAllCompleted();
					model.updateFilteredScheduleListToShowAllCompleted();
					return new CommandResult(UndoCommand.MESSAGE_SUCCESS);
				}
			}
		}
	}
	
	@Override
	public CommandResult redo() {
		if(model.getStackOfListTypesRedo().isEmpty()) {
			return new CommandResult(MESSAGE_LIST_NO_REDO_LIST);
		}
		else {
			String prevCommandListType = model.getStackOfListTypesRedo().pop();
			model.getStackOfListTypes().push(prevCommandListType);
			if(prevCommandListType.equals(TASK_STATUS_ALL)) {
				model.updateFilteredListToShowAll();
				model.updateFilteredScheduleListToShowAll();
				return new CommandResult(UndoCommand.MESSAGE_SUCCESS);
			}
			else if(prevCommandListType.equals(TASK_STATUS_INCOMPLETE)) {
				model.updateFilteredListToShowAllIncomplete();
				model.updateFilteredScheduleListToShowAllIncomplete();
				return new CommandResult(UndoCommand.MESSAGE_SUCCESS);
			}
			else {
				model.updateFilteredListToShowAllCompleted();
				model.updateFilteredScheduleListToShowAllCompleted();
				return new CommandResult(UndoCommand.MESSAGE_SUCCESS);
			}
		}
	}
}
```
###### \java\seedu\whatnow\logic\commands\MarkDoneCommand.java
``` java
	@Override
	public CommandResult undo() {
		if(model.getStackOfMarkDoneTask().isEmpty() || model.getStackOfMarkDoneTaskTaskType().isEmpty()) {
			return new CommandResult(String.format(UndoCommand.MESSAGE_FAIL));
		}

		ReadOnlyTask taskToReAdd = model.getStackOfMarkDoneTask().pop();
		String taskTypeToReAdd = model.getStackOfMarkDoneTaskTaskType().pop();
		try {
			model.unMarkTask(taskToReAdd);
		} catch(TaskNotFoundException pufe) {
			return new CommandResult(UndoCommand.MESSAGE_FAIL);
		}
		return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS));
	}
	
	@Override
	public CommandResult redo() {
		UnmodifiableObservableList<ReadOnlyTask> lastShownList;
		if (taskType.equals(TASK_TYPE_FLOATING)) {
			lastShownList = model.getCurrentFilteredTaskList();
		} else {
			lastShownList = model.getCurrentFilteredScheduleList();
		}
		if (lastShownList.size() < targetIndex) {
			indicateAttemptToExecuteIncorrectCommand();
			return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
		}
		ReadOnlyTask taskToMark = lastShownList.get(targetIndex - 1);
		try {
			model.markTask(taskToMark);
			model.getStackOfMarkDoneTask().push(taskToMark);
			model.getStackOfMarkDoneTaskTaskType().push(taskType);
		} catch (TaskNotFoundException pnfe) {
			return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
		}
		return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS));
	}
}
```
###### \java\seedu\whatnow\logic\commands\RedoCommand.java
``` java
package seedu.whatnow.logic.commands;

import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

public class RedoCommand extends Command{

	public static final String COMMAND_WORD = "redo";

	public static final String MESSAGE_USAGE = COMMAND_WORD + ": Redo the previous action "
			+ "Parameters: No parameters"
			+ "Example: " + COMMAND_WORD;

	public static final String MESSAGE_SUCCESS = "Redo Successfully";
	public static final String MESSAGE_FAIL = "Redo failure due to unexisting undo commands";
	@Override
	public CommandResult execute() throws TaskNotFoundException {
		assert model != null;
		if(model.getRedoStack().isEmpty()) {
			return new CommandResult(MESSAGE_FAIL);
		}
		else {
			UndoAndRedo reqCommand = (UndoAndRedo) model.getRedoStack().pop();
			model.getUndoStack().push(reqCommand);
			return reqCommand.redo();
		}
	}
}
```
###### \java\seedu\whatnow\logic\commands\UndoAndRedo.java
``` java
package seedu.whatnow.logic.commands;

import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

public abstract class UndoAndRedo extends Command{
	public abstract CommandResult undo() throws DuplicateTaskException, TaskNotFoundException;
	
	public abstract CommandResult redo() throws TaskNotFoundException;
}
```
###### \java\seedu\whatnow\logic\commands\UndoCommand.java
``` java
package seedu.whatnow.logic.commands;

import seedu.whatnow.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.whatnow.model.task.UniqueTaskList.TaskNotFoundException;

public class UndoCommand extends Command{

	public static final String COMMAND_WORD = "undo";

	public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo previous task in WhatNow "
			+ "Parameters: No parameters"
			+ "Example: " + COMMAND_WORD;

	public static final String MESSAGE_SUCCESS = "Undo Successfully";
	public static final String MESSAGE_FAIL = "Undo failure due to unexisting previous commands";

	@Override
	public CommandResult execute() throws DuplicateTaskException, TaskNotFoundException {
		assert model != null;
		if(model.getUndoStack().isEmpty()) {
			return new CommandResult(MESSAGE_FAIL);
		}
		else {
			UndoAndRedo reqCommand = (UndoAndRedo) model.getUndoStack().pop();
			model.getRedoStack().push(reqCommand);
			return reqCommand.undo();
		}
	}
}
```
###### \java\seedu\whatnow\logic\commands\UpdateCommand.java
``` java
	@Override
	public CommandResult undo() throws TaskNotFoundException {
		assert model != null;
		if(model.getOldTask().isEmpty() && model.getNewTask().isEmpty()) {
			return new CommandResult(String.format(UndoCommand.MESSAGE_FAIL));
		}
		else {
			ReadOnlyTask originalTask = model.getOldTask().pop();
			ReadOnlyTask unwantedTask = model.getNewTask().pop();
			model.getOldTask().push(unwantedTask);
			model.getNewTask().push(originalTask);
			try {
				model.updateTask(unwantedTask, (Task) originalTask);
			} catch(UniqueTaskList.DuplicateTaskException e) {
				return new CommandResult(UndoCommand.MESSAGE_FAIL);
			}
			return new CommandResult(UndoCommand.MESSAGE_SUCCESS); 
		}
	}
	
	@Override
	public CommandResult redo() throws TaskNotFoundException {
		assert model != null;
		if(model.getOldTask().isEmpty() && model.getNewTask().isEmpty()) {
			return new CommandResult(String.format(RedoCommand.MESSAGE_FAIL));
		}
		else {
			ReadOnlyTask originalTask = model.getNewTask().pop();
			ReadOnlyTask wantedTask = model.getOldTask().pop();
			model.getOldTask().push(originalTask);
			model.getNewTask().push(wantedTask);
			try {
				model.updateTask(originalTask, (Task) wantedTask);
			} catch (UniqueTaskList.DuplicateTaskException e) {
				return new CommandResult(RedoCommand.MESSAGE_FAIL);
			}
			return new CommandResult(RedoCommand.MESSAGE_SUCCESS);
		}
	}
}
```
###### \java\seedu\whatnow\model\Model.java
``` java
    /** Clears existing backing model and replaces with the provided new data. */
    void resetData(ReadOnlyWhatNow newData);

    /** Reverts to the pre-existing backing model and replaces with backup-ed data */
	void revertData();
    
	/** Returns the WhatNow */
    ReadOnlyWhatNow getWhatNow();
	
    //=========== Methods for Task List ===============================================================

    /** Deletes the given task. */
    void deleteTask(ReadOnlyTask target) throws TaskNotFoundException;

    /** Adds the given task */
    void addTask(Task task) throws DuplicateTaskException;

```
###### \java\seedu\whatnow\model\Model.java
``` java
    /**Gets the UndoStack if possible */
    Stack<Command> getUndoStack();
    
    /**Gets the redoStack if possible*/
    Stack<Command> getRedoStack();
    
    /**Gets the oldTask if possible */
	Stack<ReadOnlyTask> getOldTask();
	
	/**Gets the newTask if possible */
	Stack<ReadOnlyTask> getNewTask();
	
	/** Gets the deletedStackOfTask that corresponds to deleteCommand*/
	Stack<ReadOnlyTask> getDeletedStackOfTasks();

	/** Gets the deletedStackOfTaskRedo that corresponds to deleteCommand*/
	Stack<ReadOnlyTask> getDeletedStackOfTasksRedo();
	
	/** Gets the deleted StackOfTasks that corresponds to AddCommand */
	Stack<ReadOnlyTask> getDeletedStackOfTasksAdd();

	/** Gets the deleted StackOfTasksRedo that corresponds to AddCommand */
	Stack<ReadOnlyTask> getDeletedStackOfTasksAddRedo();
	
	/** Gets Stack of Task that were marked */
	Stack<ReadOnlyTask> getStackOfMarkDoneTask();  
	
	Stack<ReadOnlyTask> getStackOfMarkUndoneTask();
	
	Stack<String> getStackOfMarkUndoneTaskTaskType();
	
	/** Gets stack of TaskTypes corresponding to stackOfMarkDoneTask */
	Stack<String> getStackOfMarkDoneTaskTaskType();
	
	/** Gets a stack of String that corresponds to the list of commands that were executed */
	Stack<String> getStackOfListTypes();
	
	/**Gets a stack of String that corresponds to the list of Commands that were undone */
	Stack<String> getStackOfListTypesRedo();
	
	//@author A0139772U
	//=========== Methods for Schedule List ===============================================================
    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getCurrentFilteredScheduleList();
    
    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredScheduleList();
    
    /** Returns the filtered task list with filter keyword as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredScheduleList(Set<String> key);
    
    /** Updates the filter of the filtered task list to show all tasks */
    void updateFilteredScheduleListToShowAll();
    
    /** Updates the filter of the filtered task list to show all ongoing tasks */
    void updateFilteredScheduleListToShowAllIncomplete();
    
    /** Updates the filter of the filtered task list to show all completed tasks */
    void updateFilteredScheduleListToShowAllCompleted();

    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredScheduleList(Set<String> keywords);
    
    /** Updates the filter of the filtered task list to show only task of a specific status specified by the keyword */
    void updateFilteredScheduleListToShowAllByStatus(Set<String> keyword);

    /** Updates the filter of the filtered task list to display all task types*/
    UnmodifiableObservableList<ReadOnlyTask> getAllTaskTypeList();

```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    /**
     * Initializes a ModelManager with the given WhatNow
     * WhatNow and its variables should not be null
     */
    public ModelManager(WhatNow src, UserPrefs userPrefs) {
        super();
        assert src != null;
        assert userPrefs != null;

        logger.fine("Initializing with WhatNow: " + src + " and user prefs " + userPrefs);

        whatNow = new WhatNow(src);
        new Config();
        filteredTasks = new FilteredList<>(whatNow.getTasks());
        filteredSchedules = new FilteredList<>(whatNow.getTasks());
        stackOfUndo = new Stack<>();
        stackOfRedo = new Stack<>();
        stackOfOldTask = new Stack<>();
        stackOfNewTask = new Stack<>();
        stackOfWhatNow = new Stack<>();
        stackOfDeletedTasks = new Stack<>();
        stackOfDeletedTasksRedo = new Stack<>();
        stackOfDeletedTasksAdd = new Stack<>();
        stackOfDeletedTasksAddRedo = new Stack<>();
        stackOfMarkDone= new Stack<>();
        stackOfMarkUndone = new Stack<>();
        stackOfMarkDoneTaskTypes = new Stack<>();
        stackOfMarkUndoneTaskTypes = new Stack<>();
        stackOfListTypes = new Stack<>();
        stackOfListTypesRedo = new Stack<>();
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    public ModelManager(ReadOnlyWhatNow initialData, UserPrefs userPrefs) {
        whatNow = new WhatNow(initialData);
        new Config();
        filteredTasks = new FilteredList<>(whatNow.getTasks());
        filteredSchedules = new FilteredList<>(whatNow.getTasks());
        stackOfUndo =  new Stack<>();
        stackOfRedo = new Stack<>();
        stackOfOldTask = new Stack<>();
        stackOfNewTask = new Stack<>();
        stackOfWhatNow = new Stack<>();
        stackOfDeletedTasks = new Stack<>();
        stackOfDeletedTasksRedo = new Stack<>();
        stackOfDeletedTasksAdd = new Stack<>();
        stackOfDeletedTasksAddRedo = new Stack<>();
        stackOfMarkDone = new Stack<>();
        stackOfMarkUndone = new Stack<>();
        stackOfMarkDoneTaskTypes = new Stack<>();
        stackOfMarkUndoneTaskTypes = new Stack<>();
        stackOfListTypes = new Stack<>();
        stackOfListTypesRedo = new Stack<>();
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public void resetData(ReadOnlyWhatNow newData) {
        stackOfWhatNow.push(new WhatNow(whatNow));
        whatNow.resetData(newData);
        indicateWhatNowChanged();
    }
    
    @Override
    public synchronized void revertData() {
        whatNow.revertEmptyWhatNow(stackOfWhatNow.pop());
        indicateWhatNowChanged();
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<Command> getUndoStack() {
        return stackOfUndo;
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<Command> getRedoStack() {
        return stackOfRedo;
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getOldTask() {
        return stackOfOldTask;
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getNewTask() {
        return stackOfNewTask;
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getDeletedStackOfTasks() {
        return stackOfDeletedTasks;
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getDeletedStackOfTasksRedo() {
        return stackOfDeletedTasksRedo;
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getDeletedStackOfTasksAdd() {
        return stackOfDeletedTasksAdd;
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getDeletedStackOfTasksAddRedo() {
        return stackOfDeletedTasksAddRedo;
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<ReadOnlyTask> getStackOfMarkDoneTask() {
        return stackOfMarkDone;
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<String> getStackOfMarkDoneTaskTaskType() {
        return stackOfMarkDoneTaskTypes;
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override
    public Stack<String> getStackOfListTypes() {
        return stackOfListTypes;
    }
```
###### \java\seedu\whatnow\model\ModelManager.java
``` java
    @Override 
    public Stack<String> getStackOfListTypesRedo() {
        return stackOfListTypesRedo;
    }
    
    //=========== Filtered Task List Accessors ===============================================================
```
###### \java\seedu\whatnow\model\task\TaskDate.java
``` java
package seedu.whatnow.model.task;

import seedu.whatnow.commons.exceptions.IllegalValueException;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Locale;

import java.text.ParseException;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;

/**
 * This class checks for the validity of the user input date by checking with currentDate, and checking if the date range is valid
 * Throws its respective message if the input is invalid
 * @author A0139128A
 *
 */
//@author A0139128A
public class TaskDate {
	public static final String MESSAGE_NAME_CONSTRAINTS = "Task Date should be represented as one of the followings:"
			+ "dd/mm/yy\n" + "day month year\n" + "today\n" + "tomorrow\n";
	public static final String INVALID_TASK_DATE_RANGE_FORMAT = "The task date range is invalid";
	
	public static final String DATE_ALPHA_WITH_YEAR_VALIDATION_REGEX = "([0-9]{2}+[\\w\\.])+([0-9]{4})";	//To be updated
	public static final String DATE_ALPHA_WITHOUT_YEAR_VALIDATION_REGEX = "([0-9]{2}+[\\w\\.])";

	public static final String DATE_NUM_SLASH_WITH_YEAR_VALIDATION_REGEX = "([0-9]{2}+)/([0-9]{2}+)/([0-9]{4})"; //"\\d{2}/\\d{2}/\\d{4}"; //To be updated
	public static final String DATE_NUM_SLASH_WITHOUT_YEAR_VALIDATION_REGEX = "([0-9]{2})/([0-9]{2})";//"\\d{2}/\\d{2}";
	public static final String DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_DAY_REGEX = "([0-9]{1}+)/([0-9]{2}+)/([0-9]{4})";
	public static final String DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_MONTH_REGEX = "([0-9]{2}+)/([1-9]{1}+)/([0-9]{4})";
	public static final String DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_DAY_AND_MONTH_REGEX = "([0-9]{1}+)/([0-9]{1}+)/([0-9]{4})";

	public static final String DATE_NUM_SLASH_WITH_YEAR_FORMAT = "dd/MM/yyyy";
	public static final String DATE_NUM_SLASH_WITHOUT_YEAR_FORMAT = "dd/MM";
	public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_FORMAT = "d/MM/yyyy";
	public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_MONTH_FORMAT = "dd/M/yyyy";
	public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_AND_MONTH_FORMAT = "d/M/yyyy";

	public static final String DATE_AlPHA_WHITESPACE_WITH_YEAR_FORMAT = "dd MMMM yyyy ";
	public static final String DATE_ALPHA_WHITESPACE_WITHOUT_YEAR_FORMAT = "dd MMMM";	

	public static final String DATE_NUM_SLASH_WITH_YEAR_VALIDATION_MODIFIED_REGEX =	"^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$";

	public static ArrayList<String> ListOfDateRegex;
	public static ArrayList<String> ListOfDateFormat;

	private String fullDate;	
	private String startDate;
	private String endDate;
	
	public TaskDate(String taskDate) throws IllegalValueException, java.text.ParseException{
		ListOfDateRegex = new ArrayList<String>();
		ListOfDateFormat = new ArrayList<String>();
		ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_VALIDATION_REGEX);
		ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_DAY_REGEX);
		ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_MONTH_REGEX);
		ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_DAY_AND_MONTH_REGEX);
		ListOfDateRegex.add(DATE_NUM_SLASH_WITHOUT_YEAR_VALIDATION_REGEX);
		ListOfDateRegex.add(DATE_ALPHA_WITH_YEAR_VALIDATION_REGEX);
		ListOfDateRegex.add(DATE_ALPHA_WITHOUT_YEAR_VALIDATION_REGEX);
		ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
		ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_FORMAT);
		ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_MONTH_FORMAT);
		ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_AND_MONTH_FORMAT);
		ListOfDateFormat.add(DATE_NUM_SLASH_WITHOUT_YEAR_FORMAT);
		ListOfDateFormat.add(DATE_AlPHA_WHITESPACE_WITH_YEAR_FORMAT);
		ListOfDateFormat.add(DATE_ALPHA_WHITESPACE_WITHOUT_YEAR_FORMAT);
		if (taskDate != null) {
			taskDate = taskDate.trim();
			if(!isValidDate(taskDate)) {
				throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
			}
			//Formats the date to be today's date
			if(taskDate.equals("today")) {
				DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
				Calendar cal = Calendar.getInstance();
				taskDate = dateFormat.format(cal.getTime());
				fullDate = taskDate;
			}
			//Formats the date to be tomorrow's date
			else if(taskDate.equals("tomorrow")) {
				DateFormat dateFormat2 = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
				Calendar cal2 = Calendar.getInstance();
				cal2.add(Calendar.DATE, 1);
				taskDate = dateFormat2.format(cal2.getTime());
				fullDate= taskDate;
			}
		}
	}
	/*
	 * Validates given date
	 *
	 * @throw IllegalValueException if given date is invalid
	 */
	public TaskDate(String taskDate, String startDate, String endDate) throws IllegalValueException, java.text.ParseException {
		ListOfDateRegex = new ArrayList<String>();
		ListOfDateFormat = new ArrayList<String>();
		ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_VALIDATION_REGEX);
		ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_DAY_REGEX);
		ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_MONTH_REGEX);
		ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_VALIDATION_SHORTENED_DAY_AND_MONTH_REGEX);
		ListOfDateRegex.add(DATE_NUM_SLASH_WITHOUT_YEAR_VALIDATION_REGEX);
		ListOfDateRegex.add(DATE_ALPHA_WITH_YEAR_VALIDATION_REGEX);
		ListOfDateRegex.add(DATE_ALPHA_WITHOUT_YEAR_VALIDATION_REGEX);
		ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
		ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_FORMAT);
		ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_MONTH_FORMAT);
		ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_AND_MONTH_FORMAT);
		ListOfDateFormat.add(DATE_NUM_SLASH_WITHOUT_YEAR_FORMAT);
		ListOfDateFormat.add(DATE_AlPHA_WHITESPACE_WITH_YEAR_FORMAT);
		ListOfDateFormat.add(DATE_ALPHA_WHITESPACE_WITHOUT_YEAR_FORMAT);
		
		if(taskDate == null && startDate != null &&  endDate != null) {
			if(!isValidDateRange(startDate, endDate)) {
				throw new IllegalValueException(INVALID_TASK_DATE_RANGE_FORMAT);
			}
		}
		else {
			if(!isValidDate(taskDate)) {
				throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
			}
			//Formats the date to be today's date
			if(taskDate.equals("today")) {
				DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
				Calendar cal = Calendar.getInstance();
				taskDate = dateFormat.format(cal.getTime());
				fullDate = taskDate;
			}
			//Formats the date to be tomorrow's date
			else if(taskDate.equals("tomorrow")) {
				DateFormat dateFormat2 = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
				Calendar cal2 = Calendar.getInstance();
				cal2.add(Calendar.DATE, 1);
				taskDate = dateFormat2.format(cal2.getTime());
				fullDate = taskDate;
			}
		}
	}

	/**
	 * 
	 * @param test is a given user date input
	 * @return the validity of the user date input by passing it to methods of different regex
	 * @throws java.text.ParseException
	 */
	public boolean isValidDate(String reqDate) throws java.text.ParseException {	
		if(reqDate.equals("today") || reqDate.equals("tomorrow")) {
			return true;
		}
		else {
			for(int i = 0 ; i < ListOfDateFormat.size() && i < ListOfDateRegex.size(); i++) {
				if(reqDate.matches(ListOfDateRegex.get(i))) {
					return isValidNumDate(reqDate, ListOfDateFormat.get(i));
				}
			}
			return false;
		}
	}
	/**
	 * This function finds the respective regex that matches the user input and sends to
	 * isValidDateRangeValidator to check if the two dates are really valid
	 * @param startDate is the user input startingDate
	 * @param endDate is the user input endingDate
	 * @return true is valid date range, else false
	 * @throws java.text.ParseException
	 */
	public boolean isValidDateRange(String startDate, String endDate) throws java.text.ParseException {
		for(int i=0 ; i < ListOfDateFormat.size() && i < ListOfDateRegex.size(); i++ ) {
			if((startDate.matches(ListOfDateRegex.get(i)) && (endDate.matches(ListOfDateRegex.get(i))))) {
				return isValidDateRangeValidator(startDate, endDate, ListOfDateFormat.get(i));
			}
		}
		return false;
	}
	public boolean isValidDateRangeValidator(String beforeDate, String afterDate, String format) {
		if(beforeDate == null && afterDate == null) {
			return true;
		}
		boolean validDateRange = false;
		boolean sameDate = false;
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
		Date beginDate = null;
		Date finishDate = null;
		try {
			beginDate = sdf.parse(beforeDate);
			finishDate = sdf.parse(afterDate);
			if(beginDate.before(finishDate)) {
				validDateRange = true;
			}
			if(beginDate.equals(finishDate)) {
				sameDate = true;
			}
		} catch (ParseException e) {
			return false;
		}
		Calendar b = new GregorianCalendar();
		b.setTime(beginDate);
		b.set(Calendar.HOUR_OF_DAY, 23);
		b.set(Calendar.MINUTE, 59);
		b.set(Calendar.SECOND, 59);
		beginDate = b.getTime();
		
		Calendar a = new GregorianCalendar();
		a.setTime(beginDate);
		a.set(Calendar.HOUR_OF_DAY, 23);
		a.set(Calendar.MINUTE, 59);
		a.set(Calendar.SECOND, 59);
		finishDate = a.getTime();
		
		//Following checks if the user input date is invalid i.e before today's date
		Calendar c = new GregorianCalendar();
		c.set(Calendar.HOUR_OF_DAY, 00);
		c.set(Calendar.MINUTE, 00);
		c.set(Calendar.SECOND, 00);
		Date currDate = c.getTime();
		
		if(currDate.compareTo(beginDate) > 0 || currDate.compareTo(finishDate) > 0) {
			return false;
		}
		else if(!validDateRange && !sameDate) {
			return false;
		}
		else {
			startDate = beforeDate;
			endDate = afterDate;
			return true;
		}
	}
	
	/**
	 * 
	 * @param test is the user date input
	 * @param format is the type of format the user has chosen to input
	 * @return the validity of format of the user date input and validity i.e. existence of the date input
	 * @throws java.text.ParseException
	 */
	public boolean isValidAlphaDate(String test, String format) throws java.text.ParseException {
		Date tempDate = null;

		//Following will check if the user input date is valid in terms of numerical value i.e. 32nd november
		try {
			DateFormat dateFormat = new SimpleDateFormat(format);
			tempDate = dateFormat.parse(test);
			if(!test.equals(dateFormat.format(format))) {
				tempDate = null;
			}
		} catch(ParseException ex) {
			ex.printStackTrace();
			return false;
		}
		//Following checks if the user input date is invalid i.e before today's date
		Calendar c = new GregorianCalendar();
		c.set(Calendar.HOUR_OF_DAY, 23);
		c.set(Calendar.MINUTE, 59);
		c.set(Calendar.SECOND, 59);
		Date currDate = c.getTime();
		if(currDate.compareTo(tempDate) > 0) {
			return false;
		}
		//Following ensures that the date format keyed in the user will be converted to DATE_NUM_SLASH_WITH_YEAR_FORMAT
		if(format.equals(DATE_AlPHA_WHITESPACE_WITH_YEAR_FORMAT)) {
			String tempToGetMonth;
			String[] splitted = test.split("\\s+");
			tempToGetMonth = splitted[0];
			Date dateToGetMonth = new SimpleDateFormat("MMMMM", Locale.ENGLISH).parse(tempToGetMonth);
			Calendar cal = Calendar.getInstance();
			cal.setTime(dateToGetMonth);
			int month = cal.get(Calendar.MONTH);
			String requiredMonth = String.valueOf(month);
			String requiredDate = splitted[0];
			requiredDate.concat(requiredMonth);
			requiredDate.concat(splitted[2]);
			fullDate = requiredDate;
			return true;
		}
		else if(format.equals(DATE_ALPHA_WHITESPACE_WITHOUT_YEAR_FORMAT)) {
			String tempToGetMonth;
			String[] splitted = test.split("\\s+");
			tempToGetMonth = splitted[0];
			Date dateToGetMonth = new SimpleDateFormat("MMMMM", Locale.ENGLISH).parse(tempToGetMonth);
			Calendar cal = Calendar.getInstance();
			cal.setTime(dateToGetMonth);
			int month = cal.get(Calendar.MONTH);
			String requiredMonth = String.valueOf(month);
			int yearInt = cal.get(Calendar.YEAR);
			String year = String.valueOf(yearInt);
			String requiredDate = splitted[0];
			requiredDate.concat(year);
			return true;
		}
		else
			return false;
	}
	/**
	 * @param test is the date input by the user
	 * @param format is the type of format that the date input will be tested against with
	 * @return the validity of the user input
	 * @throws java.text.ParseException
	 */
	public boolean isValidNumDate(String test, String format) throws java.text.ParseException {
		Date inputDate = null;
		try {
			DateFormat df = new SimpleDateFormat(format);
			df.setLenient(false);

			inputDate = df.parse(test);
		} catch(ParseException ex) {
			ex.printStackTrace();
			return false;
		}
		
		Calendar d = new GregorianCalendar();
		d.setTime(inputDate);
		d.set(Calendar.HOUR_OF_DAY, 23);
		d.set(Calendar.MINUTE, 59);
		d.set(Calendar.SECOND, 59);
		inputDate = d.getTime();
		//Following checks if the user input date is invalid i.e before today's date
		Calendar c = new GregorianCalendar();
		c.set(Calendar.HOUR_OF_DAY, 00);
		c.set(Calendar.MINUTE, 00);
		c.set(Calendar.SECOND, 00);
		Date currDate = c.getTime();
		
		if(currDate.compareTo(inputDate) > 0) {
			return false;
		}
		//The following will ensure the date format to be DATE_NUM_SLASH_WITH_YEAR_FORMAT
		if(format.equals(DATE_NUM_SLASH_WITHOUT_YEAR_FORMAT)) {
			Calendar now = Calendar.getInstance();
			int yearInt = now.get(Calendar.YEAR);
			String year = String.valueOf(yearInt);
			test.concat(year);
			fullDate = test;
			return true;
		}
		else if(format.equals(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_FORMAT)) {
			fullDate = "0"+test;
			return true;
		}
		else if(format.equals(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_MONTH_FORMAT)) {
			String toReplaceFullDate = test;
			String[] split = toReplaceFullDate.split("/");
			fullDate = split[0] + "/0" + split[1] +"/" +split[2];
			return true;
		}
		else if(format.equals(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_AND_MONTH_FORMAT)) {
			String toReplaceFullDate = test;
			String[] split = toReplaceFullDate.split("/");
			fullDate = "0"+ split[0] + "/0" + split[1] + "/" + split[2];
			return true;
		}
		else {
			fullDate = test;
			return true;
		}
	}
	@Override
	public String toString() {
		if(fullDate == null) {
			return startDate + " "  + endDate;
		}
		else {
			return fullDate;
		}
	}
	@Override
	public boolean equals(Object other) {
		return other == this // short circuit if same object
				|| (other instanceof TaskDate // instanceof handles nulls
						&& this.fullDate.equals(((TaskDate) other).fullDate)); // state check
	}
	/** Returns the fullDate */
	public String getDate() {
		return fullDate;
	}
	/** Returns the startDate */
	public String getStartDate() {
		return this.startDate;
	}
	/** Returns the endDate */
	public String getEndDate() {
		return this.endDate;
	}
}
```
###### \java\seedu\whatnow\model\task\TaskTime.java
``` java
package seedu.whatnow.model.task;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;

import seedu.whatnow.commons.exceptions.IllegalValueException;

/** This class checks if the user input date and time are of a valid one by checking currentTime/currentDate/Range and throws
 *  its respective message if the input is invalid
 * @author A0139128A
 *
 */
public class TaskTime {

	public static final String TWELVE_HOUR_WITH_MINUTES_COLON_REGEX = "(((\\d|\\d\\d):\\d\\d)(am|pm))";
	public static final String TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT = "h:mma"; /*E.g. 1:50pm */
	public static final String TWELVE_HOUR_WITH_MINUTES_DOT_REGEX = "(((\\d|\\d\\d)\\.\\d\\d)(am|pm))";
	public static final String TWELVE_HOUR_WITH_MINUTES_DOT_FORMAT = "h.mma";	/*E.g. 1.45pm */
	public static final String TWELVE_HOUR_WITHOUT_MINUTES_REGEX = "([1]*[0-9]{1}+)(am|pm)";
	public static final String TWELVE_HOUR_WITHOUT_MINUTES_EXTEND_FORMAT = "hha";

	public static final String DATE_NUM_SLASH_WITH_YEAR_FORMAT = "dd/MM/yyyy";
	public static final String DATE_NUM_SLASH_WITH_YEAR_VALIDATION_REGEX = "([0-9]{2}+)/([0-9]{2}+)/([0-9]{4})";

	public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_FORMAT = "d/MM/yyyy";
	public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_VALIDATION_REGEX = "([1-9]{1}+)/([0-9]{2}+)/([0-9]{4})";

	public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_MONTH_FORMAT = "dd/M/yyyy";
	public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_MONTH_VALIDATION_REGEX = "([1-9]{2}+)/([1-9]{1}+)/([0-9]{4})";

	public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_AND_MONTH_FORMAT = "d/M/yyyy";
	public static final String DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_AND_MONTH_VALIDATION_REGEX = "([1-9]{1}+)/([1-9]{1}+)/([0-9]{4})";

	public static final String DATE_NUM_SLASH_WITHOUT_YEAR_FORMAT = "dd/MM";
	public static final String DATE_NUM_SLASH_WITHOUT_YEAR_VALIDATION_REGEX = "([1-9]{2}+)/([0-9]{2}+)";

	public static final String DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENED_DAY_FORMAT = "d/MM";
	public static final String DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENED_DAY_VALIDATION_REGEX = "([1-9]{1}+)/([0-9]{2}+)";

	public static final String DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENND_DAY_MONTH_FORMAT = "d/M";
	public static final String DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENED_DAY_MONTH_REGEX = "([1-9]{1}+)/([1-9]{1}+)";

	public static final String DATE_AlPHA_WHITESPACE_WITH_YEAR_FORMAT = "dd MMMM yyyy ";
	public static final String DATE_ALPHA_WHITESPACE_WITHOUT_YEAR_FORMAT = "dd MMMM";	

	public static final String DATE_NUM_REGEX_WITH_YEAR= "(0?[1-9]|[12][0-9]|3[01])/(0?[1-9]|1[012])/((19|20)\\d\\d)";

	public static ArrayList<String> ListOfDateRegex;
	public static ArrayList<String> ListOfDateFormat;
	public static ArrayList<String>	ListOfTimeRegex;
	public static ArrayList<String>	ListOfTimeFormat;
	public final String INVALID_TIME_MESSAGE = "Entered an invalid time format";
	public final String INVALID_TIME_RANGE_MESSAGE = "Entered an invalid time range format";
	public final String INVALID_DATE_MESSAGE = "Entered an invalid date format";
	public final String INVALID_DATE_RANGE_MESSAGE = "Entered an invalid date range format";

	private String time = null;
	private String startTime = null;
	private String endTime = null;
	private String date = null;
	private String startDate = null;
	private String endDate = null;

	public TaskTime(String time, String startTime, String endTime, String date, String startDate, String endDate)  throws IllegalValueException{

		ListOfDateRegex = new ArrayList<String>();
		ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_VALIDATION_REGEX);	ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_VALIDATION_REGEX);	
		ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_MONTH_VALIDATION_REGEX);	ListOfDateRegex.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_AND_MONTH_VALIDATION_REGEX);
		ListOfDateRegex.add(DATE_NUM_SLASH_WITHOUT_YEAR_VALIDATION_REGEX);	ListOfDateRegex.add(DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENED_DAY_VALIDATION_REGEX);	
		ListOfDateRegex.add(DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENED_DAY_MONTH_REGEX);	

		ListOfDateFormat = new ArrayList<String>();
		ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_FORMAT);	ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_FORMAT);
		ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_MONTH_FORMAT);	ListOfDateFormat.add(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_AND_MONTH_FORMAT);
		ListOfDateFormat.add(DATE_NUM_SLASH_WITHOUT_YEAR_FORMAT);	ListOfDateFormat.add(DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENED_DAY_FORMAT);
		ListOfDateFormat.add(DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENND_DAY_MONTH_FORMAT);

		ListOfTimeRegex = new ArrayList<String>();
		ListOfTimeRegex.add(TWELVE_HOUR_WITH_MINUTES_COLON_REGEX); ListOfTimeRegex.add(TWELVE_HOUR_WITH_MINUTES_DOT_REGEX);
		ListOfTimeRegex.add(TWELVE_HOUR_WITHOUT_MINUTES_REGEX);	//ListOfTimeRegex.add(TWELVE_HOUR_WITHOUT_MINUTES_EXTEND_REGEX);

		ListOfTimeFormat = new ArrayList<String>();
		ListOfTimeFormat.add(TWELVE_HOUR_WITH_MINUTES_COLON_FORMAT); ListOfTimeFormat.add(TWELVE_HOUR_WITH_MINUTES_DOT_FORMAT);
		//ListOfTimeFormat.add(TWELVE_HOUR_WITHOUT_MINUTES_FORMAT);
		ListOfTimeFormat.add(TWELVE_HOUR_WITHOUT_MINUTES_EXTEND_FORMAT);
		if(!isValidDate(date)) {
			throw new IllegalValueException(INVALID_DATE_MESSAGE);
		}
		if(!isValidDateRange(startDate, endDate)) {
			throw new IllegalValueException(INVALID_DATE_RANGE_MESSAGE);
		}
		if(!isValidTime(time)) {
			throw new IllegalValueException(INVALID_TIME_MESSAGE);
		}
		if(!isValidTimeRange(startTime, endTime)) {
			throw new IllegalValueException(INVALID_TIME_RANGE_MESSAGE);
		}
	}
	public String getFullString() {
		return (date + " " + startDate  + " " + endDate + " " + time + " " +  startTime + " " + endTime);
	}
	/** returns time */
	public String getTime() {
		return this.time;
	}
	/** returns startTime */
	public String getStartTime() {
		return this.startTime;
	}
	/** returns endTime */
	public String getEndTime() {
		return this.endTime;
	}
	/** returns currentDate */
	public String getDate() {
		return this.date;
	}
	/** returns startDate */
	public String getStartDate() {
		return this.startDate;
	}
	/** returns endDate */
	public String getEndDate() {
		return this.endDate;
	}

	/**
	 * This function checks if the reqTime by the user is valid
	 * by finding the corresponding format and passes to the method
	 * isValidTimeSeq upon finding a match
	 * @param reqTime is the user inputTime
	 * @return true if the userInput time is valid, else false
	 */
	public boolean isValidTime(String reqTime) {
		//i.e. not a deadline but a schedule

		if(reqTime == null) {
			return true;
		}else {
			for(int j=0 ; j < ListOfTimeRegex.size() ; j ++) {
				if(reqTime.matches(ListOfTimeRegex.get(j))) {
					return isValidTimeSeq(reqTime, ListOfTimeFormat.get(j));
				}
			}
			return false;
		}
	}
	/**
	 * Checks if given time given by the user is valid
	 * @param reqTime is the time input by the user
	 * @param format is the format that matches the reqTime's format
	 * @return true if the format is valid, else false
	 */
	public boolean isValidTimeSeq(String reqTime, String format) {
		//First checks if it is indeed valid:
		boolean currEarlierThanInput = false;
		Date inputTime = null;
		Date todayTime = null;
		try {
			String currentTime = new SimpleDateFormat(format).format(new Date());
			DateFormat tf = new SimpleDateFormat(format);
			tf.setLenient(false);

			inputTime = tf.parse(reqTime);
			todayTime = tf.parse(currentTime);
			if(todayTime.before(inputTime)) {
				currEarlierThanInput = true;
			}
		} catch(ParseException ex) {
			ex.printStackTrace();
			return false;
		}
		//Second check on whether this time is before the current Time
		//This check if for e.g. input add "Sth" at 5 pm
		//Attempts to put today's date, if current time is >  5pm, put it as tomorrow instead
		if(startDate == null && endDate == null && date == null) {
			//If currentTime is earlier than input time, puts today's date
			if(currEarlierThanInput) {
				DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
				Calendar cal = Calendar.getInstance();
				String taskDate = dateFormat.format(cal.getTime()); //Gets today's date
				date = taskDate;
				time = reqTime;
				return true;
			}
			//CurrentTime is later than inputTime, puts tmr date instead
			else {
				DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
				Calendar cal = Calendar.getInstance();
				cal.add(Calendar.DATE, 1);
				date = dateFormat.format(cal.getTime());
				time = reqTime;
				return true;
			}
		}
		else if(date != null) {
			//checks for todayDate gets current time and compare with input time, returns false if invalid
			if(date.toLowerCase().equals("today")) {
				if(currEarlierThanInput){
					DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
					Calendar cal = Calendar.getInstance();
					String taskDate = dateFormat.format(cal.getTime()); //Gets today's date
					date = taskDate;
					time = reqTime;
					return true;
				}
				else
					return false;
			}
			//Performs a normal check
			else if(date.toLowerCase().equals("tomorrow")) {
				DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
				Calendar cal = Calendar.getInstance();
				cal.add(Calendar.DATE, 1);
				date = dateFormat.format(cal.getTime());
				time = reqTime;
				return true;
			}
		}
		//E.g. add "Sth" on 22/10/2016 to 23/10/2016 (date has been checked if its valid) at 8pm
		//I.e. date is null, startDate is not null, endDate is not null
		else {
			time = reqTime;
			return true;
		}
		return false;
	}

	/**
	 * This function checks if  the givenTimeRange is valid by finding the corresponding
	 * regex and passes its corresponding format to a method isValidNumTime
	 * @param beforeTime is the startTime input by the user
	 * @param afterTime is the endTime input by the user
	 * @return true if the timeRangeIsValid, else false
	 */
	public boolean isValidTimeRange(String beforeTime, String afterTime) {
		//First check for whether the given two times are valid
		//Second check for whether the dates are present or not i.e.
		//Third check for whether the beforeTime is indeed before the afterTime

		if(beforeTime == null && afterTime == null && time != null) {
			return true;
		}
		else {
			for(int i =0; i < ListOfTimeRegex.size() && i < ListOfTimeFormat.size(); i ++) {
				if(beforeTime.matches(ListOfTimeRegex.get(i)) && afterTime.matches(ListOfTimeRegex.get(i))) {			
					return isValidNumTime(beforeTime, afterTime, ListOfTimeFormat.get(i));
				}
			}
		}
		return false;
	}
	/**
	 * This function checks the validity of the time range and finds 
	 * @param beforeTime is the user input starting time
	 * @param afterTime is the user input ending time
	 * @param format is the format that matches the format of the startTime
	 * @return true if valid timeFormat range, else return false
	 */
	public boolean isValidNumTime(String beforeTime, String afterTime, String format) {
		//First check if two times are valid
		boolean currEarlierThanInput = false;
		boolean beforeEarlierThanAfter = false;
		Date inputBeforeTime = null;
		Date inputAfterTime = null;
		Date todayTime = null;
		try {
			String currentTime = new SimpleDateFormat(format).format(new Date());
			DateFormat tf = new SimpleDateFormat(format);
			tf.setLenient(false);

			inputBeforeTime = tf.parse(beforeTime);
			inputAfterTime = tf.parse(afterTime);
			todayTime = tf.parse(currentTime);
			//The following checks if the user 2 inputTime is before the currentTime
			if(inputBeforeTime.before(todayTime) || inputAfterTime.before(todayTime)) {
				currEarlierThanInput = true;
			}
			//The following checks if the startTime is before endTime
			if(inputBeforeTime.before(inputAfterTime)) {
				beforeEarlierThanAfter = true;
			}
		} catch(ParseException ex) {
			ex.printStackTrace();
			return false;
		}
		
		//Checks if beforeTime is earlier than afterTime
		if(beforeEarlierThanAfter) {
			//This check if for e.g. input add "Sth" from 5pm to 7pm
			//Attempts to put today's date, if current time is >  5pm, put it as tomorrow instead
			if(startDate == null && endDate == null && date == null) {
				//If currentTime is earlier than input time, puts today's date
				if(!currEarlierThanInput) {
					DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
					Calendar cal = Calendar.getInstance();
					String taskDate = dateFormat.format(cal.getTime()); //Gets today's date
					date = taskDate;
					startTime = beforeTime;
					endTime = afterTime;
					return true;
				}
				//CurrentTime is later than inputTime, puts tmr date instead
				else {
					DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
					Calendar cal = Calendar.getInstance();
					cal.add(Calendar.DATE, 1);
					date = dateFormat.format(cal.getTime());
					startTime = beforeTime;
					endTime = afterTime;
					return true;
				}
			}
			else if(date != null){
				if(date.equals("today")) {
					if(!currEarlierThanInput){
						DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
						Calendar cal = Calendar.getInstance();
						String taskDate = dateFormat.format(cal.getTime()); //Gets today's date
						date = taskDate;
						startTime = beforeTime;
						endTime = afterTime;
						return true;
					}
					else
						return false;
				}
				//Performs a normal check
				else if(date.equals("tomorrow")) {
					DateFormat dateFormat = new SimpleDateFormat(DATE_NUM_SLASH_WITH_YEAR_FORMAT);
					Calendar cal = Calendar.getInstance();
					cal.add(Calendar.DATE, 1);
					date = dateFormat.format(cal.getTime());
					startTime = beforeTime;
					endTime = afterTime;
					return true;
				}
				//This date is Valid and is in the future
				else {
					startTime = beforeTime;
					endTime = afterTime;
					return true;
				}
			}
			//Consists of a startDate and EndDate(That has been validated) along with a startTime and endTime
			else {
				startTime = beforeTime;
				endTime = afterTime;
				return true;
			}
		}
		//Meaans time Range is invalid, however i have to check if a dateRange exists
		else {
			if(startDate != null && endDate != null) {
				if(!startDate.equals(endDate)) {
					startTime = beforeTime;
					endTime = afterTime;
					return true;
				}
				else {
					return false;
				}
			}
			return false;
		}
	}

	/**
	 * Checks if a particular date is valid i.e. not before currentDate and is a valid sequence 
	 * num is to be used to indicate what date im referring to i.e. 0 for variable date, 1 for variable startDate, 2 for variable endDate
	 * @return true if valid, else return false
	 */
	public boolean isValidDate(String reqDate) {
		if(reqDate == null) {
			date = null;
			return true;
		}
		else if(reqDate.toLowerCase().equals("today")) {
			date = "today";
			return true;
		}
		else if(reqDate.toLowerCase().equals("tomorrow")) {
			date = "tomorrow";
			return true;
		}
		else {
			for(int i = 0 ; i < ListOfDateFormat.size() && i < ListOfDateRegex.size(); i ++) {
				if(reqDate.matches(ListOfDateRegex.get(i))) {
					return isValidNumDate(reqDate, ListOfDateFormat.get(i));
				}
			}
			return false;
		}
	}

	/**
	 * This function checks whether the givenDate by the user is valid by placing
	 * it through different checks.
	 * @param reqDate is the userInput time
	 * @param format is the format that matches the user inputTime
	 * @return true if the time is valid, else false
	 */
	public boolean isValidNumDate(String reqDate, String format) {

		//First check: whether if this date is of a valid format
		Date tempDate = null;
		try {
			DateFormat df = new SimpleDateFormat(format);
			df.setLenient(false);

			tempDate = df.parse(reqDate);
		} catch(ParseException ex) {
			ex.printStackTrace();
			return false;
		}

		//Second check : whether if this date is of the past
		Calendar d = new GregorianCalendar();
		d.set(Calendar.HOUR_OF_DAY, 23);
		d.set(Calendar.MINUTE, 59);
		d.set(Calendar.SECOND, 59);
		tempDate = d.getTime();
		Calendar c = new GregorianCalendar();
		c.set(Calendar.HOUR_OF_DAY, 00);
		c.set(Calendar.MINUTE, 00);
		c.set(Calendar.SECOND, 00);
		Date currDate = c.getTime();
		if(currDate.compareTo(tempDate) > 0) {
			return false;
		}

		return true;
		//The following formats the date to become a dd/mm/yyyy format

		/*
		//E.g. 1/12/2017
		if(format.equals(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_FORMAT)) {

		}
		//E.g. 11/1/2017
		else if(format.equals(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_MONTH_FORMAT )) {

		}
		//E.g. 1/1/2017
		else if(format.equals(DATE_NUM_SLASH_WITH_YEAR_SHORTENED_DAY_AND_MONTH_FORMAT)) {

		}
		//E.g. 12/12
		else if(format.equals(DATE_NUM_SLASH_WITHOUT_YEAR_FORMAT)) {
			Calendar now = Calendar.getInstance();
			int yearInt = now.get(Calendar.YEAR);
			String year = String.valueOf(yearInt);
			reqDate.concat(year);
		}
		//E.g. 1/12
		else if(format.equals(DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENED_DAY_FORMAT)) {

		}
		//E.g. 1/1
		else if(format.equals(DATE_NUM_SLASH_WITHOUT_YEAR_SHORTENND_DAY_MONTH_FORMAT)) {

		}*/
	}
	/**
	 * Checks if a particular Date range is valid i.e. startDate is before endDate
	 * @return true if range is valid, false if range is invalid
	 */
	public boolean isValidDateRange(String beforeDate, String afterDate) {
		//Checks if the 2 dates are valid
		//Checks if beforeDate is earlier than afterDate
		if(beforeDate == null && afterDate == null) {
			return true;
		}
		boolean validDateRange = false;
		boolean sameDate = false;
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
		Date beginDate = null;
		Date finishDate = null;
		try {
			beginDate = sdf.parse(beforeDate);
			finishDate = sdf.parse(afterDate);
			if(beginDate.before(finishDate)) {
				validDateRange = true;
			}
			if(beginDate.equals(finishDate)) {
				sameDate = true;
			}
		} catch (ParseException e) {
			return false;
		}Calendar b = new GregorianCalendar();
		b.setTime(beginDate);
		b.set(Calendar.HOUR_OF_DAY, 23);
		b.set(Calendar.MINUTE, 59);
		b.set(Calendar.SECOND, 59);
		beginDate = b.getTime();
		
		Calendar a = new GregorianCalendar();
		a.setTime(beginDate);
		a.set(Calendar.HOUR_OF_DAY, 23);
		a.set(Calendar.MINUTE, 59);
		a.set(Calendar.SECOND, 59);
		finishDate = a.getTime();
		//Following checks if the user input date is invalid i.e before today's date
		Calendar c = new GregorianCalendar();
		c.set(Calendar.HOUR_OF_DAY, 00);
		c.set(Calendar.MINUTE, 00);
		c.set(Calendar.SECOND, 00);
		Date currDate = c.getTime();
		if(currDate.compareTo(beginDate) > 0 || currDate.compareTo(finishDate) > 0) {
			return false;
		}
		if(!validDateRange && !sameDate) {
			return false;
		}
		else {
			startDate = beforeDate;
			endDate = afterDate;
			return true;
		}
	}
}
```
